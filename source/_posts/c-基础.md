---
title: c++基础
top: false
cover: false
toc: true
mathjax: true
date: 2022-06-27 09:29:48
password:
summary:
tags: C++基础
categories: C++
---

# C++

# 1. const 的新花样

参考至：[(22条消息) const全局变量和局部变量的区别_weixin_45483780的博客-CSDN博客_const局部变量和全局变量](https://blog.csdn.net/weixin_45483780/article/details/107018603)

### 1.1 c语言

#### 1.1.1 修改

c语言中的const，需要重新读取内存对其进行赋值。所以，本质上是可以强制修改内容，只是语法上不能修改内容。

```c++
#include <stdio.h>

int main() {
	const int x = 10;
	int* p = (int*) &x;
	*p = 99;
	printf("%d", x);
	return 0;
}
```

const[全局变量](https://so.csdn.net/so/search?q=全局变量&spm=1001.2101.3001.7020)在静态区，直接或间接都不可以修改
const局部变量在栈上，可以间接修改
**但是定义为const的变量不建议修改**

#### 1.1.2 作用域

c语言中的const和普通变量的唯一区别就是不能修改（语法上），其他无区别，使用extern在其他文件中也可以使用。

### 1.2 c++

#### 1.2.1 修改

c++ 在编译过程中就直接将值替换给变量，没有访问内存这一步，所以修改变量对于c++还是无效的，打印出来还是初始定义的值。

#### 1.2.2 作用域

c++语言中const只能作用于本文件中，如果其他文件中使用，需要定义在头文件，其他文件引用头文件。

## 2. 类和对象

类只是一个模板，不占用内存空间。对象是类的运行实例，其位于栈上或者堆上。

> 栈
>
> ```c++
> class demo {
>     private:
>     	string name;
>     public:
>     	string nickName;
> }
> 
> int main(){
>     // 栈上
>     demo d1;
>     d1.nickName = "hello";
>     // 堆上
>     demo *d2 = new demo;
>     d2 -> nickName = "hello";
>     
>     return 0;
> }
> 
> ```
## 2.1 string
使用string类需要包含头文件<string>:





```c++
void erase_demo() {
	string s1, s2, s3;
	s1 = s2 = s3 = "1234567890";
	s2.erase(5);
	s3.erase(5, 3);
	cout << s1 << endl;
	cout << s2 << endl;
	cout << s3 << endl;
}
```

## 2.2 string 内部是什么样的

c语言中，两种字符串的写法：

1. `char str[10] = "abc"` 这个字符串可读写.
2. `char *str = "abc"`，这个字符串只能读，不能写.

两种形式总是以"\0"作为结束标志。
c++ string隐藏了包含字符序列的物理表示，不需要关心数组的维数或者
`\0`方面的问题。

c++ 标准没有严格定义string类的内存布局，各个编译厂商可以提供不同的实现，但是必须保证string的行为是一致的。string内存分配规则，允许但不要求以引用计数(reference counting)的方式实现。

c++中，独立的几个string对象可以占据也可以不占据各自特定的物理存储区，但是，如果采用引用计数避免了保存同一数据的拷贝副本，那么各个独立对象
必须看起来并表现得就像独占存储区一样。
```c++
// #include<bits/stdc++.h>
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1("12345");
    string s2 = s1;
    cout << (s1 == s2) << endl;
    s1[0] = '6';
    cout << "s1 = " << s1 << endl;  // 62345
    cout << "s2 = " << s2 << endl;  // 12345
    cout << (s1 == s2) << endl;

    return 0;
}
```

在 GCC 下的运行结果：

```c++
s1 = 62345
s2 = 12345
0
```
只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为写时复制（copy-on-write）策略。当字符串只是作为值参数（value parameter）或在其他只读情形下使用，这种方法能够节省时间和空间。多线程中不可能使用引用计数的形式来进行实现，否则会引起冲突。

同时， COW(copy-on-write)并没有想象中的那么美好。


# 3. C++引用
c/c++ 禁止在函数调用时直接传递数组的内容，而是强制传递数组的指针。

对于结构体和对象，既可以传递指针也可以传递内容。为了提高效率，一般建议传递指针。

## 3.1 与指针的区别
1. 引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。
2. 引用初始化后不能被改变，指针可以改变所指的对象。
3. 不存在指向空值的引用，但是存在指向空值的指针。

从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。

而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。引用的主要功能是传递函数的参数和返回值。

指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为 引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；

## 3.2 注意点

同时，需要注意的是，引用不能指向临时数据。

其实 C++ 代码中的大部分内容都是放在内存中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、new或malloc()分配的内存等，这些内容都可以用&来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的临时数据，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了寄存器中，就没法用&获取它们的地址了，也就没法用指针指向它们了。



下面的代码演示了表达式所产生的临时结果：
这些表达式的结果都会被放到寄存器中，尝试用&获取它们的地址都是错误的。

```c++
int n = 100, m = 200;
int *p1 = &(m + n);    //m + n 的结果为 300
int *p2 = &(n + 100);  //n + 100 的结果为 200
bool *p4 = &(m < n);   //m < n 的结果为 false
#include <iostream>
using namespace std;

int main() {
    int n = 100, m = 200;
    int *p1 = &(m);
    return 0;
}
```

## 3.3 绑定临时变量
c++ 引用不能绑定临时变量，但是将常引用绑定到临时数据时，编译器采取了一种妥协机制：编译器会为临时数据创建一个新的、无名的临时变量，并将临时数据放入该临时变量中，然后再将引用绑定到该临时变量。注意，临时变量也是变量，所有的变量都会被分配内存。

为什么编译器为常引用创建临时变量是合理的，而为普通引用创建临时变量就不合理呢？

1. 将引用绑定到一份数据后，就可以通过引用对这份数据进行操作了，包括读取和写入（修改）；尤其是写入操作，会改变数据的值。而临时数据往往无法寻址，是不能写入的，即使为临时数据创建了一个临时变量，那么修改的也仅仅是临时变量里面的数据，不会影响原来的数据，这样就使得引用所绑定到的数据和原来的数据不能同步更新，最终产生了两份不同的数据，失去了引用的意义。

2. const 引用和普通引用不一样，我们只能通过 const 引用读取数据的值，而不能修改它的值，所以不用考虑同步更新的问题，也不会产生两份不同的数据，为 const 引用创建临时变量反而会使得引用更加灵活和通用。

## 3.4 const引用和类型转换

参考至： http://www.cdsy.xyz/computer/programme/vc/20210105/cd16098262047569.html

编译器禁止指针指向不同类型的数据。
```c++
int n = 100;
int *p1 = &n;  //正确
float *p2 = &n;  //错误
char c = '@';
char *p3 = &c;  //正确
int *p4 = &c;  //错误
```

虽然 int 和 float 类型都占用 4 个字节的内存，但是程序对它们的处理方式却大相径庭：

对于 int，程序把最高 1 位作为符号位，把剩下的 31 位作为数值位；
对于 float，程序把最高 1 位作为符号位，把最低的 23 位作为尾数位，把中间的 8 位作为指数位。

「类型严格一致」是为了防止发生让人匪夷所思的操作，但是这条规则仅仅适用于普通引用，当对引用添加 const 限定后，情况就又发生了变化，编译器允许引用绑定到类型不一致的数据。

```c++
int n = 100;
int &r1 = n;  //正确
const float &r2 = n;  //正确
char c = '@';
char &r3 = c;  //正确
const int &r4 = c;  //正确 
```

临时变量的类型和引用的类型是一样的，在将数据赋值给临时变量时会发生自动类型转换。
```c++
float f = 12.45;
const int &r = f;
printf("%d", r);
```
但是，当引用的类型和数据的类型不遵守「数据类型的自动转换」规则，那么编译器将报错，绑定失败。

### 3.3.1 形参使用const修饰

同时，引用类型的形参，如果在函数中不发生改变，尽量使用const修饰。

```c++
#include <cstdio>
using namespace std;
double volume(const double &len, const double &width, const double &hei){
    return len*width*2 + len*hei*2 + width*hei*2;
}
int main(){
    int a = 12, b = 3, c = 20;
    double v1 = volume(a, b, c);
    double v2 = volume(10, 20, 30);
    double v3 = volume(89.4, 32.7, 19);
    double v4 = volume(a+12.5, b+23.4, 16.78);
    double v5 = volume(a+b, a+c, b+c);
    printf("%lf, %lf, %lf, %lf, %lf\n", v1, v2, v3, v4, v5);
    return 0;
}
```
概括起来说，将引用类型的形参添加 const 限制的理由有三个：

1. 使用 const 可以避免无意中修改数据的编程错误。
2. 使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；
3. 使用 const 引用能够让函数正确生成并使用临时变量。

# 4. C++继承和派生

public、protected、private 修饰类的成员，protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用。

1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。

也就是说，继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。

2.）不管继承方式如何，基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。

3.）如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。

4.) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

<font color = "red">我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。</font>


# 5. 指针

## 5.1 数组到底在什么时候会转换为指针

数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转为指向数据集合的指针（地址），而不是表示数据集合本身。

数据集合包含多个数据，直接使用一个集合没有任何意义，C语言中规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof或&的操作数时，它才表示整个数组本身，在其他表达式中，数组名会被转换为指向第0个元素的指针（地址）。

**数组下标[]**
C语言中规定数组下标和指针的偏移量相同，数组下标的引用总是可以写成“一个指向数组起始地址的指针加上偏移量”。假设现在有一个数组a和指针变量p，它们的定义形式为：
```c++
int a = {1, 2, 3, 4, 5}, *p, i = 2;
```
其实对于数组的引用`a[i]`会被i版一起改写成`*(a + i)`，C语言标准也要求编译器必须具备这种行为。

下标操作符 [ ]是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为 T *，所产生的结果的类型就是 T。

使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组 a 中每个元素都是 `int` 类型，长度为 4 个字节，那么`a[i+1]`和 `a[i]`在内存中的距离是 4（而不是 1）。

这意味着下面这三种表示形式是一样的：

```c++
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
```

