<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>love</title>
      <link href="2021/03/30/love/"/>
      <url>2021/03/30/love/</url>
      
        <content type="html"><![CDATA[<h1 id="小陈和我的生活记录"><a href="#小陈和我的生活记录" class="headerlink" title="小陈和我的生活记录"></a>小陈和我的生活记录</h1><h2 id="1-吃过的好吃的"><a href="#1-吃过的好吃的" class="headerlink" title="1. 吃过的好吃的"></a>1. 吃过的好吃的</h2><ol><li>三不牛腩</li><li>枣木烤鸭</li><li>胡嗲单车烧烤（超好吃）</li><li>花道寿司（日料）</li><li>XX牛杂粉</li><li>酱大骨（吃坏了肚子，湖南大学天马公寓那个地方，千万不要去）</li><li></li></ol><h2 id="2-去过的地方"><a href="#2-去过的地方" class="headerlink" title="2.去过的地方"></a>2.去过的地方</h2><ol><li>长沙海底世界</li><li>长沙五一广场</li><li>岳麓山</li></ol>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Network Interview</title>
      <link href="2021/03/24/interview-1/"/>
      <url>2021/03/24/interview-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-TIME-WAIT过多"><a href="#1-TIME-WAIT过多" class="headerlink" title="1. TIME_WAIT过多"></a>1. TIME_WAIT过多</h2><h3 id="1-1原因"><a href="#1-1原因" class="headerlink" title="1.1原因"></a>1.1原因</h3><p>首先，产生<code>TIME_WIAT</code>是主动关闭链接的一方（课本上以客户端讲解）。</p><p>其次，产生过多<code>TIME_WAIT</code>最典型的是通信双方使用短链接。</p><p>服务器上有过多<code>TIME_WIAT</code>说明服务器主动关闭服务链接。如果通信都是用短链接，某个端口有上万个链接，那么服务器关闭端口会产生至少上万个<code>TIME_WAIT</code>记录。</p><p>客户端<code>TIME_WAIT</code>状态，在高并发场景下，如果有大量的短链接，客户端所在的操作系统的socket端口和文件描述符被用尽。</p><h3 id="1-2-time-wait过多解决方法"><a href="#1-2-time-wait过多解决方法" class="headerlink" title="1.2 time_wait过多解决方法"></a>1.2 time_wait过多解决方法</h3><pre class="line-numbers language-none"><code class="language-none">netstat -an | awk '/^tcp/ {++State[$NF]}END{for(key in State)print key "\t" State[key]}'LAST_ACK 14SYN_RECV 348ESTABLISHED 70FIN_WAIT1 229FIN_WAIT2 30CLOSING 33TIME_WAIT 18122<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令解释：</p><pre class="line-numbers language-none"><code class="language-none">先来看看netstat：netstat -nActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 123.123.123.123:80 234.234.234.234:12345 TIME_WAIT你实际执行这条命令的时候，可能会得到成千上万条类似上面的记录，不过我们就拿其中的一条就足够了。再来看看awk：/^tcp/滤出tcp开头的记录，屏蔽udp, socket等无关记录。state[]相当于定义了一个名叫state的数组NF表示记录的字段数，如上所示的记录，NF等于6$NF表示某个字段的值，如上所示的记录，$NF也就是$6，表示第6个字段的值，也就是TIME_WAITstate[$NF]表示数组元素的值，如上所示的记录，就是state[TIME_WAIT]状态的连接数++state[$NF]表示把某个数加一，如上所示的记录，就是把state[TIME_WAIT]状态的连接数加一END表示在最后阶段要执行的命令for(key in state)遍历数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理TIMEWAIT：</p><p>编辑内核文件/etc/sysctl.conf，加入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后执行 /sbin/sysctl -p 让参数生效.</p><pre class="line-numbers language-none"><code class="language-none">/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>简单来说，就是打开系统的TIMEWAIT重用和快速回收。</p><p>如果以上配置调优后性能还不理想，可继续修改一下配置：</p><pre class="line-numbers language-none"><code class="language-none">vi /etc/sysctl.confnet.ipv4.tcp_keepalive_time = 1200 #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。net.ipv4.ip_local_port_range = 1024 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。net.ipv4.tcp_max_syn_backlog = 8192 #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。net.ipv4.tcp_max_tw_buckets = 5000 #表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview</title>
      <link href="2021/03/24/interview/"/>
      <url>2021/03/24/interview/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在线教育项目实战</title>
      <link href="2021/03/23/project/"/>
      <url>2021/03/23/project/</url>
      
        <content type="html"><![CDATA[<h1 id="在线教育平台"><a href="#在线教育平台" class="headerlink" title="在线教育平台"></a>在线教育平台</h1><h2 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h2><p>本平台商业模式是B2B2C模式。</p><p>拥有系统后台（管理员使用）、系统前台（普通用户使用）。</p><table><thead><tr><th align="center">后台（7大模块）</th><th align="center">前台</th></tr></thead><tbody><tr><td align="center">讲师管理模块</td><td align="center">首页数据显示</td></tr><tr><td align="center">课程分类管理模块</td><td align="center">讲师列表和详情</td></tr><tr><td align="center">课程管理模块（1）视频</td><td align="center">课程列表和课程详情（1）视频的在线播放</td></tr><tr><td align="center">统计分析模块</td><td align="center">登录和注册</td></tr><tr><td align="center">订单管理</td><td align="center">微信扫码登录</td></tr><tr><td align="center">banner管理（幻灯片切换）</td><td align="center">微信扫码支付</td></tr><tr><td align="center">权限管理</td><td align="center"></td></tr></tbody></table><h3 id="1-1-使用技术"><a href="#1-1-使用技术" class="headerlink" title="1.1 使用技术"></a>1.1 使用技术</h3><p>项目使用 前后端分离开发</p><p><img src="/2021/03/23/project/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB.PNG"></p><table><thead><tr><th>后端</th><th>前端</th></tr></thead><tbody><tr><td>springboot</td><td>vue</td></tr><tr><td>springcloud</td><td>element-ui</td></tr><tr><td>MybatisPlus</td><td>axios</td></tr><tr><td>spring security</td><td>node.js</td></tr><tr><td>redis</td><td></td></tr><tr><td>maven</td><td></td></tr><tr><td>easyExcel</td><td></td></tr><tr><td>jwt</td><td></td></tr><tr><td>OAuth2</td><td></td></tr></tbody></table><p>其他技术：阿里云oss、阿里云视频点播服务、阿里云短信服务、微信支付和登录、docker、git、jenkins</p><h2 id="2-MybatisPlus"><a href="#2-MybatisPlus" class="headerlink" title="2.MybatisPlus"></a>2.MybatisPlus</h2><p>官网：<a href="http://mp.baomidou.com/">http://mp.baomidou.com/</a></p><p>参考教程：<a href="http://mp.baomidou.com/guide/">http://mp.baomidou.com/guide/</a></p><p>MP是一个MyBatis的增强工具，在Mybatis的基础上只做增强不做改变，为简化开发、提高效率而生。</p><h3 id="2-1-开发步骤"><a href="#2-1-开发步骤" class="headerlink" title="2.1 开发步骤"></a>2.1 开发步骤</h3><h4 id="2-1-1-创建数据库"><a href="#2-1-1-创建数据库" class="headerlink" title="2.1.1 创建数据库"></a>2.1.1 创建数据库</h4><p>创建数据库表，添加数据，用于mp操作。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE `mybatis_plus`;CREATE TABLE `user`(`id` BIGINT(20) NOT NULL COMMENT '主键id',`name` VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名',`age` INT(11) NULL DEFAULT NULL COMMENT '年龄',`email` VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱',PRIMARY KEY (id));INSERT INTO `user` (id,`name`,age,email) VALUES (1, 'Jone',18,'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-创建springboot工程"><a href="#2-1-2-创建springboot工程" class="headerlink" title="2.1.2 创建springboot工程"></a>2.1.2 创建springboot工程</h4><p>主要就是操作idea，springboot版本使用2.2.1.RELEASE</p><h4 id="2-1-3-引入依赖"><a href="#2-1-3-引入依赖" class="headerlink" title="2.1.3 引入依赖"></a>2.1.3 引入依赖</h4><p>springboot和mp的依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.0.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.0.23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.18.18<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-4-配置application-properties"><a href="#2-1-4-配置application-properties" class="headerlink" title="2.1.4 配置application.properties"></a>2.1.4 配置application.properties</h4><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #如果是mysql 8+ 需要加cj和下面的时区spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>另一种配置文件是yml，也可以。</p><h4 id="2-1-5-写代码"><a href="#2-1-5-写代码" class="headerlink" title="2.1.5 写代码"></a>2.1.5 写代码</h4><ul><li>实体类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动类</li></ul><p>启动类加mapperscan，自动扫描对应的mapper</p><h4 id="2-1-6-性能分析插件"><a href="#2-1-6-性能分析插件" class="headerlink" title="2.1.6 性能分析插件"></a>2.1.6 性能分析插件</h4><p>性能分析拦截器：</p><ol><li>在配置类中加上性能分析插件：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"dev"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//有三种环境：dev : 开发环境，test : 测试环境， prod : 生产环境</span><span class="token keyword">public</span> <span class="token class-name">PerformanceInterceptor</span> <span class="token function">performanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">PerformanceInterceptor</span> performanceInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setMaxTime</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ms,超过此处设置的ms则sql不执行</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setFormat</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> performanceInterceptor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Springboot中设置dev环境</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">spring.profiles.active=dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-搭建项目"><a href="#3-搭建项目" class="headerlink" title="3. 搭建项目"></a>3. 搭建项目</h2><h3 id="3-1模块说明"><a href="#3-1模块说明" class="headerlink" title="3.1模块说明"></a>3.1模块说明</h3><p><strong>guli-parent：在线教学根目录（父工程），管理四个子模块：</strong></p><p>  <strong>canal-client</strong>：canal数据库表同步模块（统计同步数据）**</p><p>  <strong>common</strong>：公共模块父节点**</p><p>​    common-util：工具类模块，所有模块都可以依赖于它</p><p>​    service-base：service服务的base包，包含service服务的公共配置类，所有service模块依赖于它</p><p>​    spring-security：认证与授权模块，需要认证授权的service服务依赖于它</p><p>  <strong>infrastructure</strong>：基础服务模块父节点**</p><p>​    api-gateway：api网关服务</p><p>  <strong>service</strong>：api接口服务父节点**</p><blockquote><blockquote><blockquote><p>service-acl：用户权限管理api接口服务（用户管理、角色管理和权限管理等）</p></blockquote></blockquote><blockquote><blockquote><p>service-cms：cms api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-edu：教学相关api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-msm：短信api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-order：订单相关api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-oss：阿里云oss api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-statistics：统计报表api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-ucenter：会员api接口服务</p></blockquote></blockquote><blockquote><blockquote><p>service-vod：视频点播api接口服务</p></blockquote></blockquote></blockquote><h3 id="3-2-父工程中添加依赖"><a href="#3-2-父工程中添加依赖" class="headerlink" title="3.2 父工程中添加依赖"></a>3.2 父工程中添加依赖</h3><p>在<artifactid>节点后面添加pom类型</artifactid></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>guli-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加properties确定依赖版本</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">&gt;</span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>guli.version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>guli.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mybatis-plus.version</span><span class="token punctuation">&gt;</span></span>3.0.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mybatis-plus.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>velocity.version</span><span class="token punctuation">&gt;</span></span>2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>velocity.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>swagger.version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>swagger.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun.oss.version</span><span class="token punctuation">&gt;</span></span>2.8.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun.oss.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jodatime.version</span><span class="token punctuation">&gt;</span></span>2.10.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jodatime.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>poi.version</span><span class="token punctuation">&gt;</span></span>3.17<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>poi.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-fileupload.version</span><span class="token punctuation">&gt;</span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-fileupload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-io.version</span><span class="token punctuation">&gt;</span></span>2.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-io.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>httpclient.version</span><span class="token punctuation">&gt;</span></span>4.5.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>httpclient.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jwt.version</span><span class="token punctuation">&gt;</span></span>0.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jwt.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-sdk-core.version</span><span class="token punctuation">&gt;</span></span>4.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-sdk-core.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-sdk-oss.version</span><span class="token punctuation">&gt;</span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-sdk-oss.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-sdk-vod.version</span><span class="token punctuation">&gt;</span></span>2.15.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-sdk-vod.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-java-vod-upload.version</span><span class="token punctuation">&gt;</span></span>1.4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-java-vod-upload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aliyun-sdk-vod-upload.version</span><span class="token punctuation">&gt;</span></span>1.4.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aliyun-sdk-vod-upload.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fastjson.version</span><span class="token punctuation">&gt;</span></span>1.2.28<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fastjson.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>gson.version</span><span class="token punctuation">&gt;</span></span>2.8.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>gson.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>json.version</span><span class="token punctuation">&gt;</span></span>20170516<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>json.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>commons-dbutils.version</span><span class="token punctuation">&gt;</span></span>1.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>commons-dbutils.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>canal.client.version</span><span class="token punctuation">&gt;</span></span>1.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>canal.client.version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>docker.image.prefix</span><span class="token punctuation">&gt;</span></span>zx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>docker.image.prefix</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cloud-alibaba.version</span><span class="token punctuation">&gt;</span></span>0.2.2.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cloud-alibaba.version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置<code>dependencyManagement</code></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--Spring Cloud--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>Hoxton.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${cloud-alibaba.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--mybatis-plus 持久层--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${mybatis-plus.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>velocity-engine-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${velocity.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--swagger--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--swagger ui--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${swagger.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--aliyunOSS--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun.oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun.oss.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--日期时间工具--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>joda-time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>joda-time<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jodatime.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--xls--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${poi.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--xlsx--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${poi.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--文件上传--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-fileupload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--commons-io--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-io.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--httpclient--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.httpcomponents<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${httpclient.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.google.code.gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${gson.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- JWT --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.jsonwebtoken<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jjwt<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${jwt.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--aliyun--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-sdk-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-sdk-core.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun.oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-oss<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-sdk-oss.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-sdk-vod<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-sdk-vod.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-java-vod-upload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-java-vod-upload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>aliyun-sdk-vod-upload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${aliyun-sdk-vod-upload.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${fastjson.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${json.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-dbutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-dbutils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${commons-dbutils.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.otter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>canal.client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${canal.client.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-子模块service"><a href="#3-3-子模块service" class="headerlink" title="3.3 子模块service"></a>3.3 子模块service</h3><ol><li>添加模块类型是pom</li></ol><p>artifactId节点后面添加pom类型</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>添加依赖</li></ol><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--hystrix依赖，主要是用  @HystrixCommand --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--服务注册--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--服务调用--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--mybatis-plus--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--mysql--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.velocity<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>velocity-engine-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--swagger--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--xls--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.poi<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>poi-ooxml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-fileupload<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--httpclient--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.httpcomponents<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--commons-io--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-io<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--gson--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.google.code.gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>gson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4开发讲师管理模块"><a href="#3-4开发讲师管理模块" class="headerlink" title="3.4开发讲师管理模块"></a>3.4开发讲师管理模块</h3><ol><li><p>创建application.properties文件</p></li><li><p>编写controller、 service 、 mapper 内容</p></li></ol><p>mp提供了代码生成器，生成相关代码</p><p><strong>resources目录下创建文件 application.properties</strong></p><pre class="line-numbers language-none"><code class="language-none"># 服务端口server.port=8001# 服务名spring.application.name=service-edu# 环境设置：dev、test、prodspring.profiles.active=dev# mysql数据库连接spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=root#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>或者在resources目录下创建文件 application.yml</strong></p> <pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token comment"># 服务端口</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8001</span><span class="token comment"># 服务名</span><span class="token attr-name">spring.application.name</span><span class="token punctuation">=</span><span class="token attr-value">service-edu</span><span class="token comment"># 环境设置：dev、test、prod</span><span class="token attr-name">spring.profiles.active</span><span class="token punctuation">=</span><span class="token attr-value">dev</span><span class="token comment"># mysql数据库连接</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.cj.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">000</span><span class="token comment">#返回json的全局时间格式</span><span class="token attr-name">spring.jackson.date-format</span><span class="token punctuation">=</span><span class="token attr-value">yyyy-MM-dd HH:mm:ss</span><span class="token attr-name">spring.jackson.time-zone</span><span class="token punctuation">=</span><span class="token attr-value">GMT+8</span><span class="token comment">#mybatis日志</span><span class="token attr-name">mybatis-plus.configuration.log-impl</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.ibatis.logging.stdout.StdOutImpl</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#### application.yml</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> service<span class="token punctuation">-</span>edu<span class="token key atrule">profiles</span><span class="token punctuation">:</span>    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev<span class="token comment">####  application-dev.yml</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8001</span><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">configuration</span><span class="token punctuation">:</span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl<span class="token key atrule">mapper-locations</span><span class="token punctuation">:</span> classpath<span class="token punctuation">:</span>com/atguigu/service/<span class="token important">*/mapper/*.xml</span><span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token key atrule">logic-delete-value</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token key atrule">logic-not-delete-value</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> com.zaxxer.hikari.HikariDataSource<span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver<span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/guli<span class="token punctuation">?</span>serverTimezone=GMT%2B8<span class="token key atrule">username</span><span class="token punctuation">:</span> root<span class="token key atrule">password</span><span class="token punctuation">:</span> root<span class="token key atrule">hikari</span><span class="token punctuation">:</span>      <span class="token key atrule">connection-test-query</span><span class="token punctuation">:</span> SELECT 1<span class="token key atrule">connection-timeout</span><span class="token punctuation">:</span> <span class="token number">60000</span><span class="token key atrule">idle-timeout</span><span class="token punctuation">:</span> <span class="token number">500000</span><span class="token key atrule">max-lifetime</span><span class="token punctuation">:</span> <span class="token number">540000</span><span class="token key atrule">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token number">12</span><span class="token key atrule">minimum-idle</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token key atrule">pool-name</span><span class="token punctuation">:</span> GuliHikariPool<span class="token key atrule">jackson</span><span class="token punctuation">:</span>    <span class="token key atrule">date-format</span><span class="token punctuation">:</span> yyyy<span class="token punctuation">-</span>MM<span class="token punctuation">-</span>dd HH<span class="token punctuation">:</span>mm<span class="token punctuation">:</span>ss<span class="token key atrule">time-zone</span><span class="token punctuation">:</span> GMT+8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-1-创建MP代码生成器"><a href="#3-4-1-创建MP代码生成器" class="headerlink" title="3.4.1 创建MP代码生成器"></a>3.4.1 创建MP代码生成器</h4><p>在test/java目录下创建包<code>com.atguigu.eduservice</code>，创建代码生成器：<code>CodeGenerator.java</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> getCode <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">main1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1、创建代码生成器</span>        <span class="token class-name">AutoGenerator</span> mpg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2、全局配置</span>        <span class="token class-name">GlobalConfig</span> gc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GlobalConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> projectPath <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"user.dir"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>projectPath<span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOutputDir</span><span class="token punctuation">(</span>projectPath <span class="token operator">+</span> <span class="token string">"/src/main/java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setAuthor</span><span class="token punctuation">(</span><span class="token string">"atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        gc<span class="token punctuation">.</span><span class="token function">setOpen</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成后是否打开资源管理器</span>        gc<span class="token punctuation">.</span><span class="token function">setFileOverride</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//重新生成时文件是否覆盖</span>        <span class="token comment">/*         * mp生成service层代码，默认接口名称第一个字母有 I         * UcenterService         * */</span>        gc<span class="token punctuation">.</span><span class="token function">setServiceName</span><span class="token punctuation">(</span><span class="token string">"%sService"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//去掉Service接口的首字母I</span>        gc<span class="token punctuation">.</span><span class="token function">setIdType</span><span class="token punctuation">(</span><span class="token class-name">IdType</span><span class="token punctuation">.</span>ID_WORKER<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主键策略</span>        gc<span class="token punctuation">.</span><span class="token function">setDateType</span><span class="token punctuation">(</span><span class="token class-name">DateType</span><span class="token punctuation">.</span>ONLY_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义生成的实体类中日期类型</span>        gc<span class="token punctuation">.</span><span class="token function">setSwagger2</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启Swagger2模式</span>        mpg<span class="token punctuation">.</span><span class="token function">setGlobalConfig</span><span class="token punctuation">(</span>gc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 3、数据源配置</span>        <span class="token class-name">DataSourceConfig</span> dsc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataSourceConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUrl</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/guli?serverTimezone=GMT%2B8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDriverName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.cj.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setUsername</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dsc<span class="token punctuation">.</span><span class="token function">setDbType</span><span class="token punctuation">(</span><span class="token class-name">DbType</span><span class="token punctuation">.</span>MYSQL<span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setDataSource</span><span class="token punctuation">(</span>dsc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 4、包配置</span>        <span class="token class-name">PackageConfig</span> pc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PackageConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setModuleName</span><span class="token punctuation">(</span><span class="token string">"serviceedu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//模块名</span>        pc<span class="token punctuation">.</span><span class="token function">setParent</span><span class="token punctuation">(</span><span class="token string">"com.atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setController</span><span class="token punctuation">(</span><span class="token string">"controller"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token string">"entity"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setService</span><span class="token punctuation">(</span><span class="token string">"service"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pc<span class="token punctuation">.</span><span class="token function">setMapper</span><span class="token punctuation">(</span><span class="token string">"mapper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mpg<span class="token punctuation">.</span><span class="token function">setPackageInfo</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 5、策略配置</span>        <span class="token class-name">StrategyConfig</span> strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StrategyConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setInclude</span><span class="token punctuation">(</span><span class="token string">"edu_teacher"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strategy<span class="token punctuation">.</span><span class="token function">setNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数据库表映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setTablePrefix</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span><span class="token function">getModuleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//生成实体时去掉表前缀</span>        strategy<span class="token punctuation">.</span><span class="token function">setColumnNaming</span><span class="token punctuation">(</span><span class="token class-name">NamingStrategy</span><span class="token punctuation">.</span>underline_to_camel<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数据库表字段映射到实体的命名策略</span>        strategy<span class="token punctuation">.</span><span class="token function">setEntityLombokModel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lombok 模型 @Accessors(chain = true) setter链式操作</span>        strategy<span class="token punctuation">.</span><span class="token function">setRestControllerStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//restful api风格控制器</span>        strategy<span class="token punctuation">.</span><span class="token function">setControllerMappingHyphenStyle</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//url中驼峰转连字符</span>        mpg<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 6、执行</span>        mpg<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-2-编写后台管理api接口"><a href="#3-4-2-编写后台管理api接口" class="headerlink" title="3.4.2 编写后台管理api接口"></a>3.4.2 编写后台管理api接口</h4><p><strong>1、编写controller代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">TeacherService</span> teacherService<span class="token punctuation">;</span><span class="token annotation punctuation">@GetMapping</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 创建SpringBoot配置类</strong></p><p>在edu包下创建config包，创建MyBatisPlusConfig.java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>config</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableTransactionManagement</span><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.atguigu.eduservice.mapper"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisPlusConfig</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、配置SQL执行性能分析插件</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * SQL 执行性能分析插件     * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长     */</span><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Profile</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"dev"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 设置 dev test 环境开启</span><span class="token keyword">public</span> <span class="token class-name">PerformanceInterceptor</span> <span class="token function">performanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">PerformanceInterceptor</span> performanceInterceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PerformanceInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setMaxTime</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ms，超过此处设置的ms则sql不执行</span>    performanceInterceptor<span class="token punctuation">.</span><span class="token function">setFormat</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> performanceInterceptor<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-3-创建SpringBoot启动类"><a href="#3-4-3-创建SpringBoot启动类" class="headerlink" title="3.4.3 创建SpringBoot启动类**"></a>3.4.3 创建SpringBoot启动类**</h4><p>创建启动类 EduApplication.java，注意启动类的创建位置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EduApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">EduApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4-4-运行启动类"><a href="#3-4-4-运行启动类" class="headerlink" title="3.4.4 运行启动类"></a>3.4.4 运行启动类</h4><p>访问<a href="http://localhost:8001/eduservice/teacher">http://localhost:8001/eduservice/teacher</a></p><p>得到json数据</p><h4 id="3-4-5-统一返回的json时间格式"><a href="#3-4-5-统一返回的json时间格式" class="headerlink" title="3.4.5 统一返回的json时间格式"></a>3.4.5 统一返回的json时间格式</h4><p>默认情况下json时间格式带有时区，并且是世界标准时间，和我们的时间差了八个小时</p><p>在application.properties中设置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">#返回json的全局时间格式spring.jackson.date-format=yyyy-MM-dd HH:mm:ssspring.jackson.time-zone=GMT+8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-5-讲师逻辑删除"><a href="#3-5-讲师逻辑删除" class="headerlink" title="3.5 讲师逻辑删除"></a>3.5 讲师逻辑删除</h3><h4 id="3-5-1-EduTeacherController添加删除方法"><a href="#3-5-1-EduTeacherController添加删除方法" class="headerlink" title="3.5.1 EduTeacherController添加删除方法"></a>3.5.1 EduTeacherController添加删除方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-2-配置逻辑删除插件"><a href="#3-5-2-配置逻辑删除插件" class="headerlink" title="3.5.2 配置逻辑删除插件"></a>3.5.2 配置逻辑删除插件</h4><pre class="line-numbers language-none"><code class="language-none">MyBatisPlusConfig中配置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**      * 逻辑删除插件      */</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">ISqlInjector</span> <span class="token function">sqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogicSqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-Swagger2介绍"><a href="#3-6-Swagger2介绍" class="headerlink" title="3.6 Swagger2介绍"></a>3.6 Swagger2介绍</h3><p>前后端分离开发模式中，api文档是最好的沟通方式。</p><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p><p>及时性 (接口变更后，能够及时准确地通知相关前后端开发人员)规范性 (并且保证接口的规范性，如接口的地址，请求方式，参数及响应格式和错误信息)一致性 (接口信息一致，不会出现因开发人员拿到的文档版本不一致，而出现分歧)可测性 (直接在接口文档上进行测试，以方便理解业务)</p><h4 id="3-6-1-配置Swagger2"><a href="#3-6-1-配置Swagger2" class="headerlink" title="3.6.1 配置Swagger2"></a>3.6.1 配置Swagger2</h4><p><strong>1、创建common模块</strong></p><p><strong>在guli-parent下创建模块common</strong></p><p>配置：</p><p><code>groupId：com.atguigu</code></p><p><code>artifactId：common</code></p><p><img src="/2021/03/23/project/9a40d77c-6b22-4f24-a288-c76d1082f98d.png" alt="img"></p><p><strong>2、在common中引入相关依赖</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--mybatis-plus--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--lombok用来简化实体类：需要安装lombok插件--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!--swagger--&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.springfox<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>springfox-swagger-ui<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- redis --&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- spring2.X集成redis所需common-pool2       &lt;dependency&gt;           &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;           &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;           &lt;version&gt;2.6.0&lt;/version&gt;       &lt;/dependency&gt;--&gt;</span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.在模块service-base中，创建swagger的配置类</strong></p><p>创建包<code>com.atguigu.servicebase.config</code>，创建类<code>SwaggerConfig</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableSwagger2</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwaggerConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">Docket</span> <span class="token function">webApiConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Docket</span><span class="token punctuation">(</span><span class="token class-name">DocumentationType</span><span class="token punctuation">.</span>SWAGGER_2<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">groupName</span><span class="token punctuation">(</span><span class="token string">"webApi"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">apiInfo</span><span class="token punctuation">(</span><span class="token function">webApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">Predicates</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">regex</span><span class="token punctuation">(</span><span class="token string">"/admin/.*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">paths</span><span class="token punctuation">(</span><span class="token class-name">Predicates</span><span class="token punctuation">.</span><span class="token function">not</span><span class="token punctuation">(</span><span class="token class-name">PathSelectors</span><span class="token punctuation">.</span><span class="token function">regex</span><span class="token punctuation">(</span><span class="token string">"/error.*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">ApiInfo</span> <span class="token function">webApiInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ApiInfoBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">"网站-课程中心API文档"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">description</span><span class="token punctuation">(</span><span class="token string">"本文档描述了课程中心微服务接口定义"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token string">"1.0"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">contact</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Contact</span><span class="token punctuation">(</span><span class="token string">"Helen"</span><span class="token punctuation">,</span> <span class="token string">"http://atguigu.com"</span><span class="token punctuation">,</span> <span class="token string">"55317332@qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4、在模块service模块中引入service-base</strong></p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>service-base<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>5、在service-edu启动类上添加注解，进行测试</strong></p><p><img src="/2021/03/23/project/ef45a37b-8f5b-480e-9d85-e25bf5bdd3ce.png" alt="img"></p><h4 id="3-6-2-API模型"><a href="#3-6-2-API模型" class="headerlink" title="3.6.2 API模型"></a>3.6.2 API模型</h4><p>可以添加一些自定义设置，例如：</p><p>定义样例数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"创建时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 8:00:00"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> gmtCreate<span class="token punctuation">;</span><span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"更新时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 8:00:00"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT_UPDATE<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> gmtModified<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/23/project/9c17851c-8e7e-4161-968c-18b36faf148a.png" alt="img"></p><h4 id="3-6-3-定义接口说明和参数说明"><a href="#3-6-3-定义接口说明和参数说明" class="headerlink" title="3.6.3 定义接口说明和参数说明"></a>3.6.3 定义接口说明和参数说明</h4><p>定义在类上：@Api</p><p>定义在方法上：@ApiOperation</p><p>定义在参数上：@ApiParam</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Api</span><span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"讲师管理"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/admin/edu/teacher"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherAdminController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">TeacherService</span> teacherService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"所有讲师列表"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID删除讲师"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeById</span><span class="token punctuation">(</span>            <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>            <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-统一返回数据格式"><a href="#3-7-统一返回数据格式" class="headerlink" title="3.7 统一返回数据格式"></a>3.7 统一返回数据格式</h3><p>项目中我们会将响应封装成<code>json</code>返回，一般我们会将所有接口的数据格式统一， 使前端(iOS Android, Web)对数据的操作更一致、轻松。</p><p>一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容</p><p>例如，我们的系统要求返回的基本数据格式如下：</p><p><strong>列表：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"items"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"刘德华"</span><span class="token punctuation">,</span>        <span class="token property">"intro"</span><span class="token operator">:</span> <span class="token string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分页：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"total"</span><span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">,</span>    <span class="token property">"rows"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"刘德华"</span><span class="token punctuation">,</span>        <span class="token property">"intro"</span><span class="token operator">:</span> <span class="token string">"毕业于师范大学数学系，热爱教育事业，执教数学思维6年有余"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>没有返回数据：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20000</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"成功"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>失败：</strong></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>  <span class="token property">"code"</span><span class="token operator">:</span> <span class="token number">20001</span><span class="token punctuation">,</span>  <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"失败"</span><span class="token punctuation">,</span>  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，我们定义统一结果</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"success"</span><span class="token operator">:</span> 布尔<span class="token punctuation">,</span> <span class="token comment">//响应是否成功</span>  <span class="token property">"code"</span><span class="token operator">:</span> 数字<span class="token punctuation">,</span> <span class="token comment">//响应码</span>  <span class="token property">"message"</span><span class="token operator">:</span> 字符串<span class="token punctuation">,</span> <span class="token comment">//返回消息</span>  <span class="token property">"data"</span><span class="token operator">:</span> HashMap <span class="token comment">//返回数据，放在键值对中</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-7-2-创建统一结果返回类"><a href="#3-7-2-创建统一结果返回类" class="headerlink" title="3.7.2 创建统一结果返回类"></a>3.7.2 创建统一结果返回类</h4><p><strong>1、在common模块下创建子模块common-utils</strong></p><p><img src="/2021/03/23/project/3f2fb002-8f7c-47aa-aaf0-71da156e1b20.png" alt="img"></p><p><strong>2、创建接口定义返回码</strong></p><p><strong>创建包com.atguigu.commonutils，创建接口 ResultCode.java</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>commonutils</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ResultCode</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> SUCCESS <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> ERROR <span class="token operator">=</span> <span class="token number">20001</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3、创建结果类</strong></p><p><strong>创建类 R.java</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">R</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"是否成功"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Boolean</span> success<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回码"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回消息"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"返回数据"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">R</span> <span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">R</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span><span class="token class-name">ResultCode</span><span class="token punctuation">.</span>ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>        r<span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span><span class="token string">"失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">success</span><span class="token punctuation">(</span><span class="token class-name">Boolean</span> success<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSuccess</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setMessage</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">code</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> code<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>二、统一返回结果使用</p><p>1、在service模块中添加依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.atguigu<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>common_utils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、修改Controller中的返回结果</p><p>列表</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"所有讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> teacherService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"items"</span><span class="token punctuation">,</span> list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID删除讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">removeById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacherService<span class="token punctuation">.</span><span class="token function">removeById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-8-分页"><a href="#3-8-分页" class="headerlink" title="3.8 分页"></a>3.8 分页</h3><h4 id="3-8-1-MyBatisPlusConfig中配置分页插件"><a href="#3-8-1-MyBatisPlusConfig中配置分页插件" class="headerlink" title="3.8.1 MyBatisPlusConfig中配置分页插件"></a>3.8.1 MyBatisPlusConfig中配置分页插件</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 分页插件 */</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">PaginationInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-8-2-分页Controller方法"><a href="#3-8-2-分页Controller方法" class="headerlink" title="3.8.2 分页Controller方法"></a>3.8.2 分页Controller方法</h4><p><code>TeacherAdminController</code>中添加分页方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"分页讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{page}/{limit}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">pageList</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"page"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"当前页码"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> page<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"每页记录数"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> limit<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">page</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> records <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"total"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"rows"</span><span class="token punctuation">,</span> records<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、Swagger中测试</p><h3 id="3-9-条件查询"><a href="#3-9-条件查询" class="headerlink" title="3.9 条件查询"></a>3.9 条件查询</h3><p>根据讲师名称name，讲师头衔level、讲师入驻时间gmt_create（时间段）查询</p><h4 id="3-9-1-创建查询对象"><a href="#3-9-1-创建查询对象" class="headerlink" title="3.9.1 创建查询对象"></a>3.9.1 创建查询对象</h4><p>创建<code>com.guli.edu.query</code>包，创建<code>TeacherQuery.java</code>查询对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>query</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ApiModel</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"Teacher查询对象"</span><span class="token punctuation">,</span> description <span class="token operator">=</span> <span class="token string">"讲师查询对象封装"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherQuery</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"教师名称,模糊查询"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"头衔 1高级讲师 2首席讲师"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> level<span class="token punctuation">;</span>        <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询开始时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-01-01 10:10:10"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> begin<span class="token punctuation">;</span><span class="token comment">//注意，这里使用的是String类型，前端传过来的数据无需进行类型转换</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"查询结束时间"</span><span class="token punctuation">,</span> example <span class="token operator">=</span> <span class="token string">"2019-12-01 10:10:10"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> end<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-2-service"><a href="#3-9-2-service" class="headerlink" title="3.9.2 service"></a>3.9.2 service</h4><p>接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>service</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TeacherService</span> <span class="token keyword">extends</span> <span class="token class-name">IService</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam<span class="token punctuation">,</span> <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>guli<span class="token punctuation">.</span>edu<span class="token punctuation">.</span>service<span class="token punctuation">.</span>impl</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TeacherServiceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">ServiceImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TeacherMapper</span><span class="token punctuation">,</span> <span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">TeacherService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam<span class="token punctuation">,</span> <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> queryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queryWrapper<span class="token punctuation">.</span><span class="token function">orderByAsc</span><span class="token punctuation">(</span><span class="token string">"sort"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>teacherQuery <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            baseMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Integer</span> level <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> begin <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getBegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> end <span class="token operator">=</span> teacherQuery<span class="token punctuation">.</span><span class="token function">getEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"level"</span><span class="token punctuation">,</span> level<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>begin<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">ge</span><span class="token punctuation">(</span><span class="token string">"gmt_create"</span><span class="token punctuation">,</span> begin<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queryWrapper<span class="token punctuation">.</span><span class="token function">le</span><span class="token punctuation">(</span><span class="token string">"gmt_create"</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        baseMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> queryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-3-controller"><a href="#3-9-3-controller" class="headerlink" title="3.9.3 controller"></a>3.9.3 controller</h4><p>TeacherAdminController中修改 pageList方法：</p><p>增加参数TeacherQuery teacherQuery，非必选</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"分页讲师列表"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{page}/{limit}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">pageQuery</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"page"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"当前页码"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> page<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"limit"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"每页记录数"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Long</span> limit<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacherQuery"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"查询对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token class-name">TeacherQuery</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> pageParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">pageQuery</span><span class="token punctuation">(</span>pageParam<span class="token punctuation">,</span> teacherQuery<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Teacher</span><span class="token punctuation">&gt;</span></span> records <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> total <span class="token operator">=</span> pageParam<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span>  <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"total"</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"rows"</span><span class="token punctuation">,</span> records<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-9-4-Swagger中测试"><a href="#3-9-4-Swagger中测试" class="headerlink" title="3.9.4 Swagger中测试"></a>3.9.4 Swagger中测试</h4><p>一、自动填充封装</p><p>1、在service-base模块中添加</p><p><strong>创建包handler，创建自动填充类 MyMetaObjectHandler</strong> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtCreate"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtModified"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"gmtModified"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、在实体类添加自动填充注解</p><p><img src="/2021/03/23/project/91054b5b-c478-4ba3-86f5-95f465210b39.png" alt="img"></p><p><strong>二、controller方法定义</strong></p><p>1、新增 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"新增讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">save</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacher"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacherService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>teacher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、根据id查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID查询讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">getById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">Teacher</span> teacher <span class="token operator">=</span> teacherService<span class="token punctuation">.</span><span class="token function">getById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token string">"item"</span><span class="token punctuation">,</span> teacher<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、根据id修改 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"根据ID修改讲师"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"{id}"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">updateById</span><span class="token punctuation">(</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师ID"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> id<span class="token punctuation">,</span>    <span class="token annotation punctuation">@ApiParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"teacher"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"讲师对象"</span><span class="token punctuation">,</span> required <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@RequestBody</span> <span class="token class-name">Teacher</span> teacher<span class="token punctuation">)</span><span class="token punctuation">{</span>    teacher<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    teacherService<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>teacher<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="一、什么是统一异常处理"><a href="#一、什么是统一异常处理" class="headerlink" title="一、什么是统一异常处理"></a>一、什么是统一异常处理</h1><h2 id="1、制造异常"><a href="#1、制造异常" class="headerlink" title="1、制造异常"></a>1、制造异常</h2><p>除以0</p><pre class="line-numbers language-none"><code class="language-none">int a = 10/0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2、什么是统一异常处理"><a href="#2、什么是统一异常处理" class="headerlink" title="2、什么是统一异常处理"></a><img src="/2021/03/23/project/42cfc6ab-afaf-4516-8b67-d1e198277567.png" alt="img">2、什么是统一异常处理</h2><p>我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要统一异常处理</p><h1 id="二、统一异常处理"><a href="#二、统一异常处理" class="headerlink" title="二、统一异常处理"></a>二、统一异常处理</h1><h2 id="1、创建统一异常处理器"><a href="#1、创建统一异常处理器" class="headerlink" title="1、创建统一异常处理器"></a>1、创建统一异常处理器</h2><p>在service-base中创建统一异常处理类GlobalExceptionHandler.java：</p><pre class="line-numbers language-none"><code class="language-none">/** * 统一异常处理类 */@ControllerAdvicepublic class GlobalExceptionHandler {    @ExceptionHandler(Exception.class)    @ResponseBody    public R error(Exception e){        e.printStackTrace();        return R.error();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h2><p>返回统一错误结果</p><p><img src="/2021/03/23/project/c54eac64-d736-4dc4-9923-fb85f87d31a2.png" alt="img"></p><p>处理特定异常</p><p>1、添加异常处理方法 </p><p>GlobalExceptionHandler.java中添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span><span class="token string">"执行了自定义异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、测试</p><p><img src="/2021/03/23/project/2b02cb8f-53fd-4847-a5ad-10e134c44f28.png" alt="img"></p><p><strong>四、自定义异常</strong></p><p>1、创建自定义异常类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuliException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ApiModelProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"状态码"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> code<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、业务中需要的位置抛出GuliException</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">GuliException</span><span class="token punctuation">(</span><span class="token number">20001</span><span class="token punctuation">,</span><span class="token string">"出现自定义异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、添加异常处理方法</p><p>GlobalExceptionHandler.java中添加</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">GuliException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token class-name">R</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token class-name">GuliException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token class-name">R</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">message</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4、测试 </p><p><img src="/2021/03/23/project/f3c5a449-4984-4d35-9f25-35d43197a3e8.png" alt="img"></p><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><h3 id="1-主键的生成策略"><a href="#1-主键的生成策略" class="headerlink" title="1.主键的生成策略"></a>1.主键的生成策略</h3><ol><li>自动增长 </li></ol><p>在MYSQL中是AUTO_INCREMENT。在分表中，比如将用户数据放入3张表中，下一张表需要得到上一张表的最后一个值加1才能自动增长。</p><ol start="2"><li>UUID </li></ol><p>每次生成随机唯一的一个值。但是排序不方便，不好索引。</p><ol start="3"><li>Redis生成ID。</li><li>mp中自带策略</li></ol><p>使用snowflake算法生成。19位id。10bit作为机器的ID（5bit是数据中心，5bit是机器ID），12bit作为毫秒内的流水号，最后还有符号位，永远是0。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type<span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>IdType</code>的类型<code>AUTO</code>——自动增长、<code>ID_WORKER</code>——生成19位值，数字类型使用这种类型，比如long、<code>ID_WORKER_STR</code>——生成19位值，字符串类型使用这种类型，比如String、<code>INPUT——设置id值</code>、<code>NONE：输入</code>、<code>UUID</code>——随机唯一值。</p><h3 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2.自动填充"></a>2.自动填充</h3><p>不需要set到对象里面的值，使用mq方式实现数据添加。</p><ol><li>在实体类自动填充属性上添加注解：</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill<span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>fill <span class="token operator">=</span> <span class="token class-name">FieldFill</span><span class="token punctuation">.</span>INSERT_UPDATE<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Date</span> updateTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>自定义实现类，实现接口<code>MetaObjectHandler</code>和接口的方法</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMetaObjectHandler</span> <span class="token keyword">implements</span> <span class="token class-name">MetaObjectHandler</span> <span class="token punctuation">{</span>    <span class="token comment">//使用mq实现添加操作，这个方法执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insertFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"createTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用mq实现修改操作，这个方法执行</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateFill</span><span class="token punctuation">(</span><span class="token class-name">MetaObject</span> metaObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setFieldValByName</span><span class="token punctuation">(</span><span class="token string">"updateTime"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> metaObject<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h3><p>解决丢失更新问题（多个人同时修改同一条记录，最后提交的把之前提交的数据覆盖）。</p><p>乐观锁的实现方式：</p><ol><li>取出记录时，获取当前的version。</li><li>更新时，带上这个version。</li><li>执行更新时，<code>set version = newVersion where version = oldVersion</code></li><li>如果version不对，就更新失败。</li></ol><p>代码中的实现：</p><ol><li>表中加字段version</li></ol><ol start="2"><li>类中加属性version，并且添加<code>@Version</code>注解</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Version</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> version<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>配置乐观锁插件</li></ol><h3 id="4-分页查询"><a href="#4-分页查询" class="headerlink" title="4.分页查询"></a>4.分页查询</h3><ol><li>配置分页插件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//分页插件</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">PaginationInterceptor</span> <span class="token function">paginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PaginationInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>编写分页代码</li></ol><p>直接new page对象，传入两个参数。调入mp方法实现分页查询。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//第一个参数 当前页 第二个 每页显示记录数</span>    <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//调用mp分页查询过程中，底层封装把分页所有数据封装到page对象里面。</span>    userMaper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通过page对象获取所有数据</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>page<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-逻辑删除"><a href="#5-逻辑删除" class="headerlink" title="5. 逻辑删除"></a>5. 逻辑删除</h3><p>数据库表中加上一列<code>deleted</code></p><ul><li>物理删除：数据真的不在了，在硬件上删除。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> userMaper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//物理删除</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeleteBatchIds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> userMaper<span class="token punctuation">.</span><span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//批量删除</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>逻辑删除：逻辑上删除，但数据实际还存在。</li></ul><ol><li>表中添加逻辑删除字段，对应实体类添加属性。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableLogic</span><span class="token keyword">private</span> <span class="token class-name">Integer</span> deleted<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>配置逻辑插件</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">ISqlInjector</span> <span class="token function">sqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LogicSqlInjector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>再调用删除语句，就会将deleted字段置为1。（假装删除）</li></ol><p>其底层的sql语句是<code>UPDATE user SET deleted=1 WHERE id=? AND deleted=0 </code></p>]]></content>
      
      
      <categories>
          
          <category> project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL</title>
      <link href="2021/03/15/database/"/>
      <url>2021/03/15/database/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h2><p>数据、数据库、数据库管理系统和数据库系统是4个基本概念。</p><ol><li>数据（data）</li></ol><p>数据是数据库种存储的基本对象。（数字、字符、音视频等等）</p><p><font color="green">描述事物的符号记录称为数据。</font></p><ol start="2"><li>数据库（Data Base,DB)</li></ol><p>数据库是存放数据的仓库。<font color="green">数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享</font></p><ol start="3"><li>数据库管理系统</li></ol><p>它有以下功能：</p><p>1）数据定义功能。</p><p>2）数据组织、存储和管理</p><p>3）数据操纵功能</p><p>4）数据库的事务管理和运行管理</p><p>5）数据库的建立和维护功能</p><p>6）其他功能</p><ol start="4"><li>数据库系统</li></ol><p>数据库系统是由数据库、数据库管理系统、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统。</p><h3 id="1-两类数据模型"><a href="#1-两类数据模型" class="headerlink" title="1. 两类数据模型"></a>1. 两类数据模型</h3><p>第一类是概念模型，第二类是逻辑模型和物理模型。</p><p><img src="/2021/03/15/database/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B.PNG"></p><ul><li><strong>概念模型</strong></li></ul><p>也叫信息模型,是现实世界到机器世界的一个中间层次。</p><p>信息世界中基本概念：</p><p>1） 实体。 客观存在并可相互区别的事物称为实体。</p><p>2） 属性。 实体所具有的某一特性称为属性。</p><p>3） 码。 唯一标识实体的属性集成为码。</p><p>4）实体性。 用实体名及其属性名集合来抽象和刻画同类实体，称为实体性。</p><p>5） 实体集。 同一类型实体的集合称为实体集。</p><p>6） 联系。 实体之间的联系通常是指不同实体集之间的联系。</p><p>实体之间的联系有一对一、一对多和多对多等多种类型。</p><p>概念模型的一种表示方法：实体-联系方法，该方法使用<strong>ER图</strong>，E-R方法也称为E-R模型。</p><ul><li><strong>数据模型</strong></li></ul><p>通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p><p>1） 数据结构。描述数据库的组成对象以及对象之间的联系。</p><p>2） 数据操作。对数据库中的各种对象的实例允许执行的操作的集合，包括操作及有关的操作规则。</p><p>3）数据的完整性约束。</p><p>常用的数据模型：</p><p>1） 层次模型 （树）</p><ul><li><p>有且只有一个结点没有双亲结点，这个结点是根节点。</p></li><li><p>根以外的其他结点没有双亲结点。</p></li></ul><p>2）网状模型</p><ul><li>允许一个以上的结点无双亲。</li><li>一个结点可以有多于一个的双亲。</li></ul><p><img src="/2021/03/15/database/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B.PNG"></p><ul><li>关系模型</li></ul><p><img src="/2021/03/15/database/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B.PNG"></p><p>关系：一个关系对应通常说的一张表。</p><p>元组：表中的一行。</p><p>属性：表中的一列。</p><p>码：也称为码键。表中的某个属性组，它可以唯一确定一个元组。</p><p>域：域是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。</p><p>分量：元组中的一个属性值。</p><p>关系模式：对关系的描述，一般表示为：关系名（属性1，属性2，…，属性n）</p><p>关系模型要求关系必须是规范化的，<font color="green">关系的每一个分量必须是一个不可分的数据项</font>。</p><p><img src="/2021/03/15/database/%E8%A1%A8%E4%B8%AD%E6%9C%89%E8%A1%A8.PNG"></p><h3 id="2-数据库系统的结构"><a href="#2-数据库系统的结构" class="headerlink" title="2.数据库系统的结构"></a>2.数据库系统的结构</h3><p>在数据模型中有“型(type)”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。模式是数据库中全体数据的逻辑结构和特征的描述，它仅仅涉及型的描述，不涉及具体的值。</p><ul><li>数据库系统的三级模式结构</li></ul><p>外模式、模式和内模式三级构成。</p><p><img src="/2021/03/15/database/%E4%B8%89%E7%BA%A7%E6%A8%A1%E5%BC%8F.PNG"></p><ol><li>模式</li></ol><p>模式也成为逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。一个数据库只有一个模式。数据库模式以某一种数据模型为基础，同意综合地考虑了所有用户的需求。</p><ol start="2"><li>外模式</li></ol><p>外模式也称为子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p><p>外模式是模式的子集。</p><ol start="3"><li>内模式</li></ol><p>内模式也称为存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p><p> <font color="green">外模式/模式映像</font></p><p>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。每一个外模式，都有一个外模式/模式映像，它定义了外模式和模式之间的对应关系。这些映像定义通常包含各自外模式的描述。</p><p><font color="green">模式/内模式映像</font></p><p>模式内模式映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系。</p><h2 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h2><h3 id="1-关系数据结构及其形式化定义"><a href="#1-关系数据结构及其形式化定义" class="headerlink" title="1.关系数据结构及其形式化定义"></a>1.关系数据结构及其形式化定义</h3><p>关系模型是建立在集合代数的基础上的。</p><p>笛卡尔积：</p><p><img src="/2021/03/15/database/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF.PNG"></p><ul><li><font color="red" size="5">关系</font></li></ul><p>$D_1 \times D_2 \times …. \times D_n$ 的子集叫做在域$D_1, D_2, …,D_n$上的关系。表示为$R(D_1,D_2,…,D_n)$</p><p>这里的R表示关系的名字，n是关系的目或度（degree)。</p><p>n = 1，表示是单元关系。</p><p>n = 2，表示是二元关系。</p><p><font color="green">若关系中某一个属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong></font></p><p>若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。</p><ul><li><font color="red" size="5">关系模式</font> </li></ul><p>关系数据库中，关系模式是型，关系是值。关系模式是对关系的描述。</p><p>关系模式可以形式化地表示为$R(U,D,DOM,F)$，其中R为关系名，U为组成该关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</p><p>关系数据库：所有关系的集合。</p><p>关系操作：查询和插入、删除、修改。</p><p>查询操作可以分为选择、投影、连接、除、并、差、交、笛卡尔积等。其中选择、投影、并、差、笛卡尔积是5中基本操作。操作的对象和结果都是集合。非关系数据模型的数据操作方式则为一次一记录的方式。</p><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><h2 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h2><h3 id="1、Select"><a href="#1、Select" class="headerlink" title="1、Select"></a>1、<code>Select</code></h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">Select 查询列表 from 表名;SELECT last_name,email,salary from employees; #查询多个字段SELECT 100*98;#查询表达式SELECT VERSION();#查询函数SELECT DISTINCT department_id FROM employees;#去重复SELECT 100+90;SELECT '123'+90;#看3点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>查询列表可以是字段、常量值、函数和表达式。</p></li><li><p>查询的结果是一个虚拟的表格。</p></li><li><p><code>+</code>的作用：</p><p>a. 两个操作数都为数值型，则做加法运算。</p><p>b.其中一方为字符型，试图将字符型数值转换为数值型。如果转换成功，则继续做加法运算。如果失败，则字符型转换为0</p><p>c. 只要其中一方为<code>null</code>，则结果肯定为<code>null</code>。</p></li><li><p><code>CONCAT</code> 连接</p></li></ol><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CONCAT('a','b','c') As 结果;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h3><ol><li>字符函数</li></ol><p><code>length</code> </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT LENGTH('john');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>concat</code> 拼接字符串</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CONCAT(last_name,'_',first_name) 姓名 FROM employees;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>upper</code> <code>lower</code></p><pre class="line-numbers language-none"><code class="language-none">SELECT UPPER('john');SELECT LOWER('joHn');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>substr</code> <code>substring</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT SUBSTR('李莫愁爱上了陆展元',6) out_put;// 陆展元SELECT SUBSTR("李莫愁爱上了陆展元"，1，3) output //李莫愁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>instr</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT INSTR('杨不悔爱上了殷六侠','殷六侠') AS out_put; 返回子串第一次出现的索引，如果找不到返回0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>trim</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT TRIM('      张翠山    ') AS out_put;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>lpad</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT LPAD('殷素素',10,'*') AS out_put;//左侧填充<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>rpad</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT RPAD('殷素素',10,'*') AS out_put;//右侧填充<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>replace</code></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT REPLACE ('张无忌爱上了周芷若周芷若爱上了张无忌','周芷若'，'赵敏') AS out_put;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>数学函数</li></ol><p><code>round</code> 四舍五入</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT ROUND(1.65);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>ceil</code> 向上取整</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT CEIL(1.00); # 返回该参数的最小整数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>floor</code> 向下取整</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT FLOOR(-9.99)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>truncate</code> 截断</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT TRUNCATE(1.6999,1);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>mod</code></p><pre class="line-numbers language-none"><code class="language-none">SELECT MOD(-10,3);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>日期函数</li><li>其他函数</li><li>流程控制函数</li></ol><h4 id="Union-联合查询"><a href="#Union-联合查询" class="headerlink" title="Union 联合查询"></a>Union 联合查询</h4><p>多张表合并成一个结果。（要查询的结果来自于多个表，且多个表没有直接的关系，但查询的信息一般是一致的）。</p><h1 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h1><p><img src="/2021/03/15/database/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.PNG"></p><p><img src="/2021/03/15/database/limit%E5%85%AC%E5%BC%8F.PNG"></p><h3 id="Explain-SQL-语句优化"><a href="#Explain-SQL-语句优化" class="headerlink" title="Explain + SQL 语句优化"></a>Explain + SQL 语句优化</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><img src="/2021/03/15/database/explainID.PNG"></p><h4 id="TYPE"><a href="#TYPE" class="headerlink" title="TYPE"></a>TYPE</h4><p><img src="/2021/03/15/database/explainTYPE.PNG"></p><h3 id="2-六大约束"><a href="#2-六大约束" class="headerlink" title="2.六大约束"></a>2.六大约束</h3><h4 id="2-1-事务"><a href="#2-1-事务" class="headerlink" title="2.1 事务"></a>2.1 事务</h4><p>一条或多条sql语句组成的一个执行单位。</p><p>设置回滚点</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">savepoint 回滚点名rollback to 回滚点名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>并发事务</p><p>多个事务 同时操作  同一个数据库的相同数据时。</p><p>并发问题都有哪些：</p><p>脏读：一个事务读取了其他事务还没有提交的数据</p><p>不可重复读：一个事务多次读取，结果不一样。</p><p>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据。</p><p>通过设置隔离级别来解决并发问题。</p><p><img src="/2021/03/15/database/%E7%BA%A6%E6%9D%9F.PNG"></p><p>tips: </p><ul><li>创建表时添加</li><li>修改表时添加</li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE TEST{字段名 字段类型 列级约束表级约束}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-约束分类"><a href="#2-1-约束分类" class="headerlink" title="2.1 约束分类"></a>2.1 约束分类</h4><p>NOT NULL 非空，该字段</p><p>UNIQUE 唯一，该字段的值不可重复</p><p>DEFAULT 默认，该字段的值不用手动插入有默认值。</p><p>CHECK 检查，mysql不支持。</p><p>PRIMARY KEY</p><p>FOREIGN KEY</p><p>主键和唯一的区别：</p><p>主键不允许为空，唯一允许为空</p><p>一个表至多一个主键，唯一可以多个。</p><p>相同点：都具有唯一性。</p><ul><li><p>列级约束</p><p>六大约束都支持，但外键约束咩有效果。 不可以起约束名字。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT PRIMARY KEY,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    majorId INT FOREIGN KEY REFERENCE major(id)}CREATE TABLE major{    id INT PRIMARY KEY,                 }                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>表级约束</p><p>除了非空、默认，其他都支持。 可以起约束名字，但对主键无效。</p></li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    majorId INT,    CONSTRAINT pk PRIMARY KEY(id),    CONSTRAINT ue UNIQUE(seat),    CONSTRAINT fp_stuinfo_major FOREIGN KEY(majorID) REFERENCE major(id)                     }CREATE TABLE major{    id INT PRIMARY KEY,                 }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通用写法：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE stuinfo{id INT PRIMARY KEY,stuName VARCHAR(20) NOT NULL,gender CHAR(1) CHECK(gender = '男' OR gender = '女',seat INT UNIQUE,    age INT DEFAULT 18,    CONSTRAINT fp_stuinfo_major FOREIGN KEY(majorID) REFERENCE major(id) ## 只写外键                         }CREATE TABLE major{    id INT PRIMARY KEY,                 }  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-主键和唯一键区别"><a href="#2-2-主键和唯一键区别" class="headerlink" title="2.2 主键和唯一键区别"></a>2.2 主键和唯一键区别</h4><table><thead><tr><th>name</th><th>唯一性</th><th>允许空</th><th>一个表中多少个</th><th>允许组合</th></tr></thead><tbody><tr><td>主键</td><td>是</td><td>不允许</td><td>最多一个</td><td>允许</td></tr><tr><td>唯一键</td><td>是</td><td>允许</td><td>可以多个unique</td><td>允许</td></tr></tbody></table><p>唯一键<code>null</code>只能有一个</p><h3 id="2-3-外键的特点"><a href="#2-3-外键的特点" class="headerlink" title="2.3 外键的特点"></a>2.3 外键的特点</h3><ol><li>要求从表设置外键关系。</li><li>从表外键列类型和主表类型一致或兼容，名称无所谓。</li><li>主表的关联列必须是key（一般是主键或唯一）</li><li>插入数据先插入主表再从表，删除顺序相反。</li></ol><h4 id="2-4-修改表添加约束"><a href="#2-4-修改表添加约束" class="headerlink" title="2.4 修改表添加约束"></a>2.4 修改表添加约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE stuInfo MODIFY COLUMN stuname VARCHAR(20) NOT NULL # 非空约束# 列级约束ALTER TABLE stuInfo MODIFY COLUMN id INT PRIMARY KEY;# 表级约束ALTER TABLE stuInfo ADD PRIMARY KEY(id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-修改表时删除约束"><a href="#2-5-修改表时删除约束" class="headerlink" title="2.5 修改表时删除约束"></a>2.5 修改表时删除约束</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 删除唯一键ALTER TABLE stuInfo DROP INDEX seat;# 删除主键ALTER TABLE stuInfo DROP PRIMARY KEY;# 删除外键ALTER TABLE stuInfo DROP FOREIGN KEY majorid;# 或者可以直接更改原来的形式 not null ---&gt; nullALTER TABLE stuInfo MODIFY stuname VARCHAR(20) NULL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-标识列"><a href="#3-标识列" class="headerlink" title="3. 标识列"></a>3. 标识列</h3><ul><li>自增长列，系统提供默认的序列值（1开始）</li><li>一个表只能有一个标识列</li><li>只能是数值型 （INT FLOAT DOUBLE)</li><li>mysql 可以设置步长</li></ul><h4 id="3-1-创建表时"><a href="#3-1-创建表时" class="headerlink" title="3.1 创建表时"></a>3.1 创建表时</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CRATE TABLE test{id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20)}set auto_increment_increment=3 #步长每次加3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-修改表时"><a href="#3-2-修改表时" class="headerlink" title="3.2 修改表时"></a>3.2 修改表时</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE tab_identity MODIFY COLUMN id PRIMARY KEY AUTO_INCREMENT;# 删除自增ALTER TABLE tab_identity MODIFY COLUMN id PRIMARY KEY;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-隔离级别"><a href="#3-3-隔离级别" class="headerlink" title="3.3 隔离级别"></a>3.3 隔离级别</h3><p>4种事务隔离级别。</p><p>MYSQL四种都支持，默认REPEATEBLE READ。 </p><p>READ UNCOMMITTED</p><p>READ COMMITED 避免脏读</p><p>REPEATABLE READ 脏读和不可重复读都避免</p><p>SERIALIZABLE 串行化，效率十分低下。</p><h3 id="4-视图"><a href="#4-视图" class="headerlink" title="4. 视图"></a>4. 视图</h3><h4 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h4><p>概念：虚拟表，和普通表一样使用。通过表动态生成的数据。<font color="red">只保存sql逻辑。</font></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE VIEW name AS...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>多个地方用到同样的查询结果，或sql语句较为复杂。</p><h4 id="4-2-视图修改"><a href="#4-2-视图修改" class="headerlink" title="4.2 视图修改"></a>4.2 视图修改</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create or replace veiw 视图名  #方式一as 查询语句alter view 视图名as 查询语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-视图删除"><a href="#4-3-视图删除" class="headerlink" title="4.3 视图删除"></a>4.3 视图删除</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP VIEW 视图名，视图名...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-4-显示视图"><a href="#4-4-显示视图" class="headerlink" title="4.4 显示视图"></a>4.4 显示视图</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show create view 视图名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="4-5-视图更新"><a href="#4-5-视图更新" class="headerlink" title="4.5 视图更新"></a>4.5 视图更新</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">INSERT INTO 视图名 VALUES(‘zhangfei’,'1940')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有一些语句是不能更新的，具备以下特点的是不能更新的</p><p>1:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT 语句中包含子查询JOINGROUP BYJOIN（查询时使用到了JOIN）from 一个不能更新的视图WHERE 子句的子查询引用了from子句中的表DISTINCTunion union all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-6-delete-和-truncate-在事务使用时的区别"><a href="#4-6-delete-和-truncate-在事务使用时的区别" class="headerlink" title="4.6 delete 和 truncate 在事务使用时的区别"></a>4.6 delete 和 truncate 在事务使用时的区别</h4><p><code>trancate</code>不支持回滚</p><p>delete每次删除一行。</p><p>trancate table一次性删除所有数据且不记录日志保存，执行速度快。</p><p>执行速度上：drop &gt; trancate &gt; delete</p><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><h4 id="5-1-系统变量"><a href="#5-1-系统变量" class="headerlink" title="5.1 系统变量"></a>5.1 系统变量</h4><p>变量有系统提供，不是用户定义，属于服务器层面。</p><ol><li>查看所有的系统变量。</li></ol><p><code>SHOW GLOBAL | 【SESSION】 VARIABLES</code></p><ol start="2"><li>查看满足条件的部分系统变量</li></ol><p><code>SHOW GLOBAL | 【SESSION】 variables like '%char%'</code></p><ol start="3"><li><p>查看指定的某个系统变量的值。</p><p><code>select @@global | 【session】.系统变量名</code></p></li><li><p>为某个系统变量赋值</p></li></ol><p><code>set @@global | session.系统变量名 = 值</code></p><h4 id="5-2-自定义变量"><a href="#5-2-自定义变量" class="headerlink" title="5.2 自定义变量"></a>5.2 自定义变量</h4><p>用户自定义的，不是由系统提供的。</p><p>声明 赋值 使用</p><ol><li>用户变量</li></ol><p>作用域：针对当前会话连接有效，同于会话变量的作用域。</p><p><code>SET @用户变量名=值</code> 或</p><p><code>set @用户变量名:=值；</code>或</p><p><code>select @用户变量名:=值</code></p><ol start="2"><li>局部变量</li></ol><p>a 声明</p><p><code>declare 变量名 类型</code></p><p><code>declare 变量名 类型 default  值</code></p><p>b 赋值</p><p>通过SET 或 SELECT</p><p><code>SET @局部变量名=值</code> 或</p><p><code>set @局部变量名:=值；</code>或</p><p><code>select @局部变量名:=值</code></p><p>c 使用</p><p><code>select 局部变量名</code></p><h4 id="5-3-存储过程和函数"><a href="#5-3-存储过程和函数" class="headerlink" title="5.3 存储过程和函数"></a>5.3 存储过程和函数</h4><p>类似于java中的方法。</p><ol><li><p>提高代码的重用性。</p></li><li><p>简化操作。</p></li><li><p>减少了编译次数，减少了和数据库的连接次数。</p></li></ol><ul><li><p>概念：一组预先编译好的SQL语句的集合，理解成批处理语句。</p></li><li><p>创建</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create procedure 存储过程名(参数列表)BEGIN存储过程体（一组合法的SQL语句）END<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ol><li><p>参数列表包括三部分</p><p>参数模式 参数名 参数类型</p><p>举例：</p><p>IN stuname VARCHAR(20)</p><p>参数模式：</p><p>IN ：该参数可以作为输入，该参数需要调用方法传入值</p><p>OUT:该参数可以作为输出，也就是该参数可以作为返回值</p><p>INOUT:该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值又可以返回值。</p></li><li><p>如果存储过程体仅仅只有一句话，BEGIN END可以省略</p></li></ol></li><li><p>调用</p></li></ul><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CALL 存储过程名(实参列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DELIMITER $CREATE PROCEDURE myp1(IN beautyName VARCHAR(20), IN newName VARCHAR(20), OUT boyName VARCHAR(20),OUT userCP INT) # 还有一个INOUTBEGININSERT INTO admin(username, 'password') values('','')END $CALL myp1('柳岩')$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-4-存储过程的删除和查看"><a href="#5-4-存储过程的删除和查看" class="headerlink" title="5.4 存储过程的删除和查看"></a>5.4 存储过程的删除和查看</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP PROCEDURE P1;SHOW CREATE PROCEDURE P1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><ul><li>概念</li></ul><p>适合做处理数据返回一个结果。（增删改是适合存储过程）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE FUNCTION 函数名（参数列表）RETURNS 返回类型begin函数体end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-1-调用语法"><a href="#6-1-调用语法" class="headerlink" title="6.1 调用语法"></a>6.1 调用语法</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select 函数名(参数列表)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">返回公司的员工个数CREATE FUNCTION myf1() RETURNS INTBEGINDECLARE c INT DEFAULT 0;SELECT COUNT(*)FROM employees;RETURN c;END $SELECT myf1() $DROP FUNCTION P1;SHOW CREATE FUNCTION P1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-分支结构"><a href="#7-分支结构" class="headerlink" title="7. 分支结构"></a>7. 分支结构</h2><h3 id="7-2-case"><a href="#7-2-case" class="headerlink" title="7.2 case"></a>7.2 case</h3><p>情况一：（作为独立语句才可返回语句，并且只能放在BEGIN END中）</p><p> case 变量|表达式|字段</p><p>when 要判断的值 THEN 返回的值或语句1；</p><p>…</p><p>else 要返回的值或语句</p><p>END CASE;</p><p>情况二：</p><p> case 变量|表达式|字段</p><p>when 要判断的值 THEN 返回的值或语句；</p><p>…</p><p>else 要返回的值</p><p>END CASE;</p><h3 id="7-3-IF结构"><a href="#7-3-IF结构" class="headerlink" title="7.3 IF结构"></a>7.3 IF结构</h3><p>实现多重分支。</p><h2 id="8-循环结构"><a href="#8-循环结构" class="headerlink" title="8. 循环结构"></a>8. 循环结构</h2><h3 id="8-1-WHILE"><a href="#8-1-WHILE" class="headerlink" title="8.1 WHILE"></a>8.1 WHILE</h3><p>while 循环条件 do</p><p>循环体</p><p>end while;</p><h3 id="8-2-loop"><a href="#8-2-loop" class="headerlink" title="8.2 loop"></a>8.2 loop</h3><p>loop</p><p>循环体；//要搭配leave。</p><p>end loop;</p><h3 id="8-3-repeat"><a href="#8-3-repeat" class="headerlink" title="8.3 repeat"></a>8.3 repeat</h3><p>类似于do while</p><p>repeat</p><p>循环体</p><p>until 结束循环条件</p><p>end repeat。</p><h2 id="1-MYSQL-架构"><a href="#1-MYSQL-架构" class="headerlink" title="1. MYSQL 架构"></a>1. MYSQL 架构</h2><p><img src="/2021/03/15/database/sqlstructure.PNG"></p><ol><li>连接层</li><li>服务层</li><li>引擎层</li><li>存储层</li></ol><h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE [UNIQUE] INDEX indexname ON mytable(columnname(length));#或ALTER mytable ADD [UNIQUE] INDEX [indexname] ON (columnname(length))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-1-删除索引"><a href="#1-1-删除索引" class="headerlink" title="1.1 删除索引"></a>1.1 删除索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">DROP INDEX [indexname] ON mytable;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-2-查看索引"><a href="#1-2-查看索引" class="headerlink" title="1.2 查看索引"></a>1.2 查看索引</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SHOW INDEX FROM tablename;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="1-3-建立索引条件"><a href="#1-3-建立索引条件" class="headerlink" title="1.3 建立索引条件"></a>1.3 建立索引条件</h3><p><img src="/2021/03/15/database/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6.PNG"></p><h3 id="1-4-不建立索引条件"><a href="#1-4-不建立索引条件" class="headerlink" title="1.4 不建立索引条件"></a>1.4 不建立索引条件</h3><ol><li>表的记录太少</li><li>经常增删改的表</li><li>某个列包含很多重复的数据，建立索引没有太大的实际效果。</li></ol><h3 id="1-5-索引失效场景"><a href="#1-5-索引失效场景" class="headerlink" title="1.5 索引失效场景"></a>1.5 索引失效场景</h3><ol><li>组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；</li><li>like未使用最左前缀，where A like ‘%China’；</li><li>搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；</li><li>or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）</li><li>如果列类型是字符串，要使用引号。例如where A=’China’，否则索引失效（会进行类型转换）；</li><li>在索引列上的操作，函数（upper()等）、or、！=(&lt;&gt;)、not in等；</li></ol><p><img src="/2021/03/15/database/%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.PNG"></p><h3 id="1-6-性能下降"><a href="#1-6-性能下降" class="headerlink" title="1.6 性能下降"></a>1.6 性能下降</h3><ol><li>查询语句写的烂</li><li>索引失效</li><li>关联查询太多join</li><li>服务器调优及各个参数的设置。</li></ol><h2 id="2-7种JOIN"><a href="#2-7种JOIN" class="headerlink" title="2. 7种JOIN"></a>2. 7种JOIN</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">SELECT DISTINCT &lt;select_list&gt;FROM&lt; left_table&gt; &lt;join_type &gt;JOIN &lt; right_table&gt; ON &lt;join_condition&gt;where&lt; where_condition &gt;GROUP BY&lt; group_by_list &gt;HAVING&lt; having_condition &gt;ORDER BY&lt; order_by_condition &gt;LIMIT &lt; limit_number &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/database/%E6%9C%BA%E8%AF%BB%E9%A1%BA%E5%BA%8F.PNG"></p><p><img src="/2021/03/15/database/JOIN7%E7%A7%8D.PNG"></p><h3 id="7-1-SQL-优化器"><a href="#7-1-SQL-优化器" class="headerlink" title="7.1 SQL 优化器"></a>7.1 SQL 优化器</h3><ul><li>概念</li></ul><p>它按照自己搜集的统计信息给出它认为最优的执行计划。</p><h3 id="7-2-EXPLAIN"><a href="#7-2-EXPLAIN" class="headerlink" title="7.2 EXPLAIN"></a>7.2 EXPLAIN</h3><ol><li>慢查询的开启并捕获。</li><li>explain + 慢SQL分析</li><li>show profile查询SQL在Mysql服务器里面的执行细节和生命周期情况。</li><li>SQL数据库服务器的参数调优。</li></ol><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>Extra</th></tr></thead><tbody><tr><td>select查询的序列号，包含的一组数字，表示查询中执行select子句或操作表的顺序。</td><td>SIMPLE、PRIMARY、SUBQUERY、DERIVED、UNION、UNION RESULT 查询的类型，普通查询、联合查询、子查询等复杂查询</td><td>衍生 = derived (给这个表重新起了一个名字)</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id相同，执行顺序由上到下</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id 不相同，id的序号会递增，id值越大优先级越高，越先被执行。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>id 相同不同，同时存在</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>id 表的读取顺序</li></ul><ul><li><p>select_type 数据读取操作的操作类型</p><ul><li><p>简单的select查询，查询中不包含子查询或者UNION</p></li><li><p>PRIMARY 鸡蛋壳，最后加载的那个</p></li><li><p>SUBQUERY 括号里的子查询</p></li><li><p>DERIVED 临时表，把结果放在临时表里的。FROM 列表包含子查询表记derived。</p></li><li><p>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION。若UNION出现在FROM的子查询中，外层SELECT被标记为DERIVED。</p></li><li><p>UNION RESULT 从union表中获取union结果。</p></li></ul></li><li><p>type 访问类型</p><ul><li><p> |ALL|index|range|ref|eq_ref|const| system|null|</p></li><li><p> 从最好到最差依次如下： system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p></li><li><p> 只要达到range级别，就够好了。</p></li><li><p> system 表只有一行记录（等于系统表）。这是类型的特例，平时不会出现，这个也可以忽略不计。</p></li><li><p> const 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于<code>where</code>中，MYSQL就只能将该查询转换为一个常量。</p></li><li><p> eq_ref 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</p></li><li><p> ref 非唯一性索引扫描，返回匹配某个单独值得所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行。它可能会找到多个符合条件的行，所以它属于查找和扫描的混合体。</p></li><li><p> range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。 where 里面用了between啥的</p></li><li><p> index 只遍历索引树。 select id from table1.</p></li><li><p> ALL 全表扫描。</p></li></ul></li></ul><ul><li>pobbible_keys</li></ul><p>显示可能应用在这张表中的索引，一个或多个。</p><p>查询涉及到的字段上若存在索引，则该索引被列出，但不一定被查询实际使用。</p><ul><li>key</li></ul><p>实际用到的索引。如果为NULL ，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中。</p><ul><li>key_len</li></ul><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好。ken_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索得出的。</p><ul><li>ref</li></ul><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p><ul><li>rows （每张表有多少行被查询优化器查询）</li></ul><p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数。</p><ul><li>Extra</li></ul><p>包含不适合在其他列中显示但十分重要的信息。</p><p>​    * Using filesort </p><p>​    文件内排序。说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MYSQL中无法利用索引完成的排序称之为“文件内排序”。（复合索引，排序没有用建立索引时的顺序）</p><p>​    * using temporary</p><p>使用了临时表保存中间结果。MYSQL在对查询结果排序时使用临时表。常见于排序order by 和 分布查询 group by。group by 语句一般会产生临时表。</p><p>​    * using Index</p><p>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！！！（覆盖索引指的就是现在索引里面已经覆盖了你要查的东西了，你不用再读取数据文件了。）</p><p>如果同时出现using where， 表明索引被用来执行索引键值的查找。</p><p>如果没有出现using where， 表明索引被用来读取数据而非执行查找动作。</p><ul><li><p>using where </p><p>使用where过滤</p></li><li><p>using join buffer 使用连接缓冲</p></li><li><p>impossible where where子句总是false，不能用来获取元素</p></li><li><p>select tables optimized away 没有groupby字句的情况下，基于索引优化MIN/MAX操作或者对于myisam存储引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成阶段即完成优化。</p></li><li><p>distinct 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。</p></li></ul><ol><li>表的读取顺序</li></ol><ol start="2"><li>数据读取操作的操作类型</li></ol><ol start="3"><li>哪些索引可以使用</li></ol><ol start="4"><li>哪些索引被实际使用</li></ol><ol start="5"><li>表之间的引用</li></ol><ol start="6"><li>每张表有多少行被优化器查询</li></ol><h3 id="7-3-小表驱动大表"><a href="#7-3-小表驱动大表" class="headerlink" title="7.3 小表驱动大表"></a>7.3 小表驱动大表</h3><p>当B表的数据集必须小于A表数据集时，用in优于exists。</p><p>exists子查询只返回<code>true</code>或<code>false</code>。</p><h3 id="7-4-ORDER-BY-使用index排序"><a href="#7-4-ORDER-BY-使用index排序" class="headerlink" title="7.4 ORDER BY  使用index排序"></a>7.4 ORDER BY  使用index排序</h3><ol><li>ORDER BY 语句使用索引最左前列。</li><li>使用where子句与Order BY 子句条件列组合满足索引最左前列。</li></ol><h3 id="7-5-filesort"><a href="#7-5-filesort" class="headerlink" title="7.5 filesort"></a>7.5 filesort</h3><ol><li>双路排序</li></ol><p>MYSQL 4.1之前使用双路排序，意思是两次扫描磁盘，最终得到数据。（从磁盘读取排序字段，在buffer进行排序，再从磁盘读取其他字段）。</p><p>读取行指针和<code>orderby</code>列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中</p><ol start="2"><li>单路排序</li></ol><p>从磁盘读取查询需要的所有列，按照orderby列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免出现了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多空间，因为把每一行都保存在内存。</p><p><font color="red">MYSQL两种排序：文件排序和扫描有序索引排序。</font></p><h3 id="7-6-慢查询日志"><a href="#7-6-慢查询日志" class="headerlink" title="7.6 慢查询日志"></a>7.6 慢查询日志</h3><p>mysql默认没有开启慢查询日志，需要手动设置。如果不是调优，一般不开启。</p><p><code>SHOW VARIABLES LIKE '%slow_query_log%'</code></p><p>由<code>long_query_time</code>控制，默认情况下<code>long_query_time</code>的值为10秒。</p><p><code>mysqldumpslow -s r -t 10 XXX.log</code> 得到返回记录集最多的10个SQL。</p><p>第一步，发现问题</p><p>第二步， 开启慢查询 抓取和截取</p><p>第三步，explain </p><p>第四步， show profile 更改配置</p><h3 id="7-7-Show-Profile"><a href="#7-7-Show-Profile" class="headerlink" title="7.7 Show Profile"></a>7.7 Show Profile</h3><p><code>Show Profile</code>是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。</p><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果。</p><p>使用步骤：</p><ol><li><p><code>Show variables like 'prifiling'</code> 查看是否关闭，准备将其打开</p></li><li><p><code>set profiling=on</code></p></li><li><p>查看结果 <code>show profiles</code></p></li><li><p><code>show profile cpu,block io for query 2;</code> 2表示查询语句的id</p><p>这里语句中只写了cpu和io，还有其他信息，参数有：</p><p><img src="/2021/03/15/database/showprofiles.PNG"></p></li><li></li></ol><p><img src="/2021/03/15/database/showprofilep.PNG"></p><h3 id="7-8-全局查询日志"><a href="#7-8-全局查询日志" class="headerlink" title="7.8 全局查询日志"></a>7.8 全局查询日志</h3><p>不要在生产环境中开启这个功能。测试环境下使用。</p><p><code>set global general_log=1</code></p><p><code>set global log_output='TABLE'</code>此后，所编写的sql语句，将会记录到mysql库里的general_log表里，可以用下面命令查看：</p><p><code>select * from mysql.general_log</code></p><h2 id="3-锁机制"><a href="#3-锁机制" class="headerlink" title="3. 锁机制"></a>3. 锁机制</h2><h3 id="3-1-表锁"><a href="#3-1-表锁" class="headerlink" title="3.1 表锁"></a>3.1 表锁</h3><ul><li><code>show open tables</code></li><li>手动上锁</li></ul><p><code>lock table 表名字 read(write)， 表名字2 read(write)， 其他</code></p><ul><li>释放锁</li></ul><p><code>unlock tables</code></p><p>读锁的使用：</p><p>加了读锁，可以读，但是不能写这个表了，这个数据库中的其他表也不能读了。（读写复制的原因）</p><p>第二个session再来此数据库中的更改其他表也只能阻塞。</p><p>写锁的使用：</p><p>加了写锁，可以更改此表，不能查询其他表。</p><p>第二个session可以查其他表，但是不能查此表。</p><h4 id="3-1-1-MYISAM"><a href="#3-1-1-MYISAM" class="headerlink" title="3.1.1 MYISAM"></a>3.1.1 MYISAM</h4><p>偏读锁。在执行查询语句(select)前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁。</p><ul><li>表级锁有两种模式</li></ul><p>表共享读锁（Table Read Lock)</p><p>表独占写锁（Table Write Lock）</p><table><thead><tr><th align="center">锁类型</th><th align="center">可否兼容</th><th align="center">读锁</th><th align="center">写锁</th></tr></thead><tbody><tr><td align="center">读锁</td><td align="center">是</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">写锁</td><td align="center">是</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><ol><li>对Myisam表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。</li><li>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。</li></ol><h4 id="3-2-1-分析表的锁定"><a href="#3-2-1-分析表的锁定" class="headerlink" title="3.2.1 分析表的锁定"></a>3.2.1 分析表的锁定</h4><p><code>show status like 'talbe%'</code></p><h3 id="3-2-行级锁"><a href="#3-2-行级锁" class="headerlink" title="3.2 行级锁"></a>3.2 行级锁</h3><h1 id="MYSQL-面试题"><a href="#MYSQL-面试题" class="headerlink" title="MYSQL 面试题"></a>MYSQL 面试题</h1><h3 id="0-SQL-语句主要可以划分为以下-3-个类别。-DDL-DML-DCL"><a href="#0-SQL-语句主要可以划分为以下-3-个类别。-DDL-DML-DCL" class="headerlink" title="0. SQL 语句主要可以划分为以下 3 个类别。 DDL DML DCL"></a>0. <strong>SQL 语句主要可以划分为以下 3 个类别。</strong> DDL DML DCL</h3><p><strong>DDL（Data Definition Languages）语句：</strong>数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。</p><p><strong>DML（Data Manipulation Language）语句：</strong>数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）</p><p><strong>DCL（Data Control Language）语句：</strong>数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。</p><h3 id="1-数据库三大范式是什么"><a href="#1-数据库三大范式是什么" class="headerlink" title="1. 数据库三大范式是什么"></a>1. 数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，消除非主键堆码的部分函数依赖。（比如通过码，必须可以确定表中的其他所有属性。如果还有其他属性无法推测，则不符合第二范式）</p><p><img src="/2021/03/15/database/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E5%AE%9E%E4%BE%8B.PNG"></p><p>图中通过id 和姓名组成了码，可以推断系名和系主任，但是课名无法推测，所以不是第二范式。</p><p><img src="/2021/03/15/database/%E4%BA%8C%E8%8C%83%E5%BC%8F%E9%97%AE%E9%A2%98.PNG"></p><p>插入异常：往这张表新插入一个系id空的，插不进去。</p><p>删除异常：删除id系也删除了。</p><p>第三范式：在第二范式的基础上，消除传递函数依赖。非主键列只依赖于主键，不依赖于其他非主键。 </p><p><img src="/2021/03/15/database/%E4%B8%89%E8%8C%83%E5%BC%8F%E5%AE%9E%E4%BE%8B.PNG"></p><p>系主任依赖于系名，系名又依赖于id，系主任又依赖于id（传递了）。</p><p>还有BCNF范式 4范式 5范式，这几个很少说了</p><h3 id="2-数据库的权限表"><a href="#2-数据库的权限表" class="headerlink" title="2. 数据库的权限表"></a>2. 数据库的权限表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在<code>mysql</code>数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h3 id="3-innodb-myisam"><a href="#3-innodb-myisam" class="headerlink" title="3. innodb myisam"></a>3. innodb myisam</h3><p>   1.支持事务与不支持。</p><ol start="2"><li>支持外键与否。</li><li>聚集索引和非聚集索引。</li><li>innodb表级查询，不保存具体行数。myisam用一个变量保存了整个表的行数。（查行数。其他innodb快）</li><li>Innodb支持表锁和行锁，myisam只有表锁。且Innobdb支持全文检索。</li></ol><p>叶子结点保存完整的数据。 </p><p>非聚集 索引和数据分开存储。叶子节点只保存</p><h3 id="1-为什么设计索引"><a href="#1-为什么设计索引" class="headerlink" title="1. 为什么设计索引"></a>1. 为什么设计索引</h3><p>索引可以加快数据访问，快速定位数据。举个例子：我们平时写代码，一个数组存了很多数据。我们不就是通过那个指针直接访问那个数据吗？</p><p>MYSQL 使用B+数和哈希（单值索引）。</p><h3 id="2-为什么设计成B-树"><a href="#2-为什么设计成B-树" class="headerlink" title="2. 为什么设计成B+树"></a>2. 为什么设计成B+树</h3><p>哈希会碰撞和冲突。因为要查询，这种方式需要把所有数据全部放到内存里，耗费内存空间。</p><p>实际工程中大部分是范围查询。</p><p>二叉树和红黑树太深了（只存储一个值），io次数过多影响读取效率。</p><p>B树每个节点m个子树 （m - 1）个结点。</p><h3 id="4-面试中常问的存储引擎"><a href="#4-面试中常问的存储引擎" class="headerlink" title="4. 面试中常问的存储引擎"></a>4. 面试中常问的存储引擎</h3><p>MEMORY 使用哈希存储。（还有 InnoDB 和 MyIsam）。</p><p>存储引擎的区别就i是不同的数据存储方式。比如MyISAM是数据索引分开放，InnoDB是索引数据一起放。（聚簇索引和非聚簇索引）</p><h3 id="5-局部性原理"><a href="#5-局部性原理" class="headerlink" title="5. 局部性原理"></a>5. 局部性原理</h3><ol><li>时间局部性 放过的数据在最近很大可能还会被访问</li><li>空间局部性 访问过的位置的附近很大可能会被访问</li></ol><h3 id="6-InnoDB-每次规定，预读4-4K-16K-的数据"><a href="#6-InnoDB-每次规定，预读4-4K-16K-的数据" class="headerlink" title="6. InnoDB 每次规定，预读4*4K = 16K 的数据"></a>6. InnoDB 每次规定，预读4*4K = 16K 的数据</h3><h3 id="7-B-树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。"><a href="#7-B-树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。" class="headerlink" title="7. B+树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。"></a>7. B+树的高度取决于你的索引是用什么类型存储的，一般使用int类型建立索引。（数值越小越好）。</h3><h3 id="8-B-树两种查找运算"><a href="#8-B-树两种查找运算" class="headerlink" title="8. B+树两种查找运算"></a>8. B+树两种查找运算</h3><ol><li>主键的范围查找和分页查找。</li><li>根节点开始，进行随机查找。</li></ol><p>InnoDB叶子节点中存储记录，如果没有主键，那么选择唯一键。如果没有唯一键，那么会生成一个6字节的row_id来作为主键。</p><p>如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做回表。</p><h3 id="9-为什么推荐主键自增"><a href="#9-为什么推荐主键自增" class="headerlink" title="9. 为什么推荐主键自增"></a>9. 为什么推荐主键自增</h3><p>分布式，不建议。</p><p>单机，建议自增。（跟业务场景相关）。如果是乱序插入，插到中间（B+树开始分裂），分裂完了还得合并，还影响到了索引列。</p><h3 id="10-回表-索引覆盖-索引下推-最左匹配"><a href="#10-回表-索引覆盖-索引下推-最左匹配" class="headerlink" title="10. 回表 索引覆盖 索引下推 最左匹配"></a>10. 回表 索引覆盖 索引下推 最左匹配</h3><p>如果创建索引的键是其他字段，那么叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做回表。（使用了辅助索引）</p><p>直接从索引全部命中数据——索引覆盖。</p><p>组合索引中，先从左侧的顺序匹配。</p><p>比如(select * from table where name = ? and age = ? )没有索引下推时，MYSQL会先从存储引擎中拉取数据（根据name筛选的数据），再从musql server 根据age进行数据的筛选。</p><p>有索引下推时，拉取数据直接根据name，age获取数据，不需要server做任何的数据筛选。（缺点：需要在磁盘上多做数据筛选）。</p><p>（举例：索引下推是先把所有字段拿出来再做关联，原来是先把表所有内容拿出来，查询字段）。</p><h3 id="11-优化器两种方式"><a href="#11-优化器两种方式" class="headerlink" title="11. 优化器两种方式"></a>11. 优化器两种方式</h3><ol><li><p>CBO 基于成本优化。（大部分采用）</p></li><li><p>RBO 基于规则优化</p></li></ol><h3 id="12-MRR"><a href="#12-MRR" class="headerlink" title="12. MRR"></a>12. MRR</h3><p>mult_range read。索引排序好了，加了一个排序的环节。把随机磁盘读取转化为顺序磁盘读，提高了索引查询的性能。</p><h3 id="13-FIC"><a href="#13-FIC" class="headerlink" title="13. FIC"></a>13. FIC</h3><p>fast index create。只作用于辅助索引，对于主键的创建和删除同样需要重建一张表。</p><p>插入和删除数据，先创建临时表，将数据导入到临时表中。把原始表删除。修改临时表的名字替换原始表。</p><p>有了FIC，给当前表添加一个Share锁，不会有创建临时文件的资源消耗，还是在源文件做。但是此时如果有人发起DML操作，很明显数据会不一致，所以添加share锁。</p><h3 id="14-索引分类"><a href="#14-索引分类" class="headerlink" title="14. 索引分类"></a>14. 索引分类</h3><p>主键索引 唯一索引 普通索引 组合索引 全文索引</p><h3 id="15-索引的匹配方式"><a href="#15-索引的匹配方式" class="headerlink" title="15. 索引的匹配方式"></a>15. 索引的匹配方式</h3><ol><li><p>全值匹配 </p><p>和索引中所有的列进行匹配。</p></li><li><p>匹配最左前缀</p></li></ol><ol start="3"><li>匹配列前缀</li></ol><p>匹配其中一部分，列前缀。比如 like%。</p><ol start="4"><li>匹配范围值</li></ol><ol start="5"><li>精确匹配某一列并范围匹配另外一列</li></ol><ol start="6"><li>只访问索引的查询</li></ol><h3 id="16-哈希索引"><a href="#16-哈希索引" class="headerlink" title="16. 哈希索引"></a>16. 哈希索引</h3><p>精确匹配。只有memory存储引擎显示支持哈希索引。</p><p>限制：</p><ol><li>只包含哈希值和行指针，不存储字段值。</li><li>无法排序。不是按照索引顺序存储的。</li><li>哈希使用索引列的全部内容查找，不支持列部分匹配。</li><li>支持等值比较查询，也不支持任何范围查询。</li><li>访问哈希索引速度快，当出现哈希冲突时，必须遍历链表中所所有行指针直到找到符合条件的行。</li><li>哈希冲突比较多的话，维护的代价很高。</li></ol><p>CRC32 循环冗余加密规则。</p><h3 id="17-索引优化"><a href="#17-索引优化" class="headerlink" title="17. 索引优化"></a>17. 索引优化</h3><ol><li>使用索引列查询不要使用表达式，把计算逻辑放在业务层。否则就不走索引了。</li><li>尽量使用主键查询，不会触发回表查询。自然主键和代理主键（跟业务无关性）。</li><li>前缀索引。比如字符串的前7个字符。</li><li>使用索引扫描来排序。 防止出现 using filesort。</li><li>union all，in，or都能够使用索引，但是推荐使用in。如果是单列索引，or会使用索引。如果是组合索引：如果全部是组合索引，使用表中全部列所对应的索引，如果部分列是组合索引，不会走索引。</li><li>范围列可以用到索引。&lt; &lt;= &gt; &gt;= between。如果某索引使用到了范围，那么其后面的索引列不会再走索引。</li><li>强制类型转换会触发全表扫描。</li><li>更新频繁的索引不适合建立索引。typeloglog，distinct value。</li><li>创建索引的列，不允许为null，可能会得到不符合预期的结果。</li><li>进行表连接时，最好不要超过三个表，因为join字段数据类型必须一致。</li><li>能使用limit的时候尽量使用limit。limit主要目的时限制输出。</li><li>单表索引控制在5个以内（现在没有太多的限制）。</li><li>单索引字段数不允许超过5个（组合索引）。</li><li>创建索引应该避免以下错误观念（1.索引越多越好2. 过早优化，不了解系统的情况下进行优化）。</li></ol><p>————————</p><p>监控SQL、数据库连接不要过多、数据库设计之初、索引、SQL语句的优化、设置MYSQL参数、分布式集群如何设计。</p><h3 id="18-索引监控"><a href="#18-索引监控" class="headerlink" title="18.索引监控"></a>18.索引监控</h3><p><img src="/2021/03/15/database/%E7%B4%A2%E5%BC%95%E7%9B%91%E6%8E%A7.PNG"></p><h3 id="19-Count-1-COUNT"><a href="#19-Count-1-COUNT" class="headerlink" title="19. Count(1) COUNT(*)"></a>19. Count(1) COUNT(*)</h3><p><strong>count详解：</strong></p><p><code>count(1)</code>跟<code>count(主键)</code>一样，只扫描主键。</p><p><code>count(*)</code>跟<code>count(非主键)</code>：</p><p>　　count(*)将返回表格中所有存在的行的总数包括值为null的行，然而count(列名)将返回表格中除去null以外的所有行的总数(有默认值的列也会被计入）.<br>　　distinct 列名,得到的结果将是除去值为null和重复数据后的结果</p><p>1.优先考虑count(*)，因为数据库做了特别的优化处理。</p><p>有主键或联合主键的情况下，count(*)略比count(1)快一些。<br>没有主键的情况下count(1)比count(*)快一些。<br>如果表只有一个字段，则count(*)是最快的。<br>2.使用count()聚合函数后，最好不要跟where age = 1；这样的条件，会导致不走索引，降低查询效率。除非该字段已经建立了索引。使用count()聚合函数后，若有where条件，且where条件的字段未建立索引，则查询不会走索引，直接扫描了全表。<br>3.count(字段),非主键字段，这样的使用方式最好不要出现。因为它不会走索引.</p><h3 id="20-主从复制"><a href="#20-主从复制" class="headerlink" title="20. 主从复制"></a>20. 主从复制</h3><p>客户发请求给代理，代理给每个分库读或者写。要保证每个分库数据一致，binlog进行主从复制。master  和 slave 库，客户端操作master进行DML操作，</p><h3 id="21-读写分离"><a href="#21-读写分离" class="headerlink" title="21 读写分离"></a>21 读写分离</h3><p>客户发请求给代理，代理给每个分库读或者写。要保证每个分库数据一致，binlog进行主从复制。master  和 slave 库，客户端操作master，</p><h3 id="22-分库分表"><a href="#22-分库分表" class="headerlink" title="22. 分库分表"></a>22. 分库分表</h3><h3 id="23-MVCC"><a href="#23-MVCC" class="headerlink" title="23 MVCC"></a>23 MVCC</h3><h3 id="24-锁"><a href="#24-锁" class="headerlink" title="24. 锁"></a>24. 锁</h3><p>表锁、行锁、页锁。</p><p>表锁（偏向MYISAM引擎。</p><h3 id="25-日志系统"><a href="#25-日志系统" class="headerlink" title="25. 日志系统"></a>25. 日志系统</h3><p><code>binlog</code> ——》 MYSQL服务的   <code>undo log</code> 和  <code>redo log</code> ——》innodb存储引擎的</p><h3 id="26-MYSQL-结构"><a href="#26-MYSQL-结构" class="headerlink" title="26. MYSQL 结构"></a>26. MYSQL 结构</h3><p><img src="/2021/03/15/database/MYSQL%E7%BB%93%E6%9E%84.PNG"></p>]]></content>
      
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="2021/03/15/java/"/>
      <url>2021/03/15/java/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-常问知识点"><a href="#JAVA-常问知识点" class="headerlink" title="JAVA 常问知识点"></a>JAVA 常问知识点</h1><h3 id="求时间复杂度"><a href="#求时间复杂度" class="headerlink" title=" 求时间复杂度 "></a><font color="green"> 求时间复杂度 </font></h3><ol><li>递归树法</li></ol><p>$T(n) = 2 * T(\frac{n}{2}) + n $</p><p><img src="/2021/03/15/java/%E9%80%92%E5%BD%92%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.PNG"></p><p><img src="/2021/03/15/java/%E9%80%92%E5%BD%92%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A61.PNG"></p><ol start="2"><li>主定理分析法</li></ol><p>$T(n) = a * T(\frac{n}{b}) + f(n)$</p><p><img src="/2021/03/15/java/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90.PNG"></p><p><img src="/2021/03/15/java/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%901.PNG"></p><blockquote><h3 id="java-compator"><a href="#java-compator" class="headerlink" title="java compator"></a><font color="green">java compator</font></h3></blockquote><ul><li>保持这个顺序就返回-1 (&gt; 还是 &lt;)</li><li>交换顺序就返回1</li><li>什么都不做就返回0；所以 升序的话 如果1&lt;2,返回-1,保持顺序[1,2],如果3&gt;2,返回-1,交换顺序[2,3]</li></ul><pre class="line-numbers language-none"><code class="language-none">if (a &gt; b) return -1; 保持a&gt; b的顺序if (a &gt; b) return 1; 交换ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="gt-面向对象和面向过程的区别"><a href="#gt-面向对象和面向过程的区别" class="headerlink" title="&nbsp;> 面向对象和面向过程的区别"></a><font color="green">&nbsp;&gt; 面向对象和面向过程的区别</font></h3><ul><li>面向过程 ： 面向过程性能很好。类调用时需要实例化，开销大消耗资源。但是面向过程没有面向对象易于维护、复扩展。</li><li>面向对象：易维护、复用、扩展。因为面向对象有封装、继承、多态的特性，低耦合系统。</li></ul><h3 id="gt-对象加载的5个步骤"><a href="#gt-对象加载的5个步骤" class="headerlink" title="> 对象加载的5个步骤"></a><font color="green">&gt; 对象加载的5个步骤</font></h3><ol><li><strong>类加载检查</strong>。当使用new 生成一个对象时，会首先去检查常量池中有没有对这个对象的引用。如果没有，再检查这个对象是否已经<font color="purple">加载、解析、初始化</font>过，如果没有，会进行类加载。</li><li><strong>分配内存</strong>。在JAVA堆中为对象分配内存。内存分配机制有两种，第一种是<strong>指针碰撞</strong>，第二种是<strong>空闲列表</strong>。分配方式由JAVA堆是否规整决定，JAVA堆是否规整又由所采用的垃圾回收器是否有压缩整理功能决定。</li><li><strong>初始化零值</strong>。为内存中已经分配的对象数据初始化零值，这样对象可以不赋初始值直接使用。</li><li><strong>分配对象头</strong>。对象头包括类元数据、对象的哈希码以及对象的GC分代年龄等。</li><li><strong>init初始化</strong>。按照程序员的意愿对类中的数据进行初始化。</li></ol><blockquote><p><font color="green">对象的内存布局</font></p></blockquote><ol><li><strong>对象头</strong>。包括对象的哈希码、GC分代年龄等。</li><li><strong>实例数据</strong>。程序中所定义的各种字段内容。</li><li><strong>对齐填充</strong>。由于对象占位必须是8字节的整数倍，所以当对象实例部分空间未占满时（对象头本身是8字节的1倍或2倍），会对剩余空间进行填充。</li></ol><h3 id="gt-句柄和直接引用"><a href="#gt-句柄和直接引用" class="headerlink" title="> 句柄和直接引用"></a><font color="green">&gt; 句柄和直接引用</font></h3><ol><li><strong>句柄</strong>。指针的指针。JAVA堆中分配句柄池，存储实例对象的地址。</li></ol><p><img src="/2021/03/15/java/%E5%8F%A5%E6%9F%84.png" alt="句柄"></p><p><strong>优点</strong>：一个对象被多个变量引用，那么只需要更改句柄池一个。当对象地址改变时，只需改变句柄池内容即可。</p><p><strong>缺点</strong>：速度慢。</p><ol start="2"><li><strong>直接指针</strong>。指针，直接保存对象地址。速度快，省去了句柄池还得再次寻找地址。</li></ol><p><strong>优点</strong>：速度快。</p><p><strong>缺点</strong>：对象被移动时，所有指向该对象的reference都需要被改变，耗时。</p><h3 id="gt-迭代器Iterator"><a href="#gt-迭代器Iterator" class="headerlink" title=">迭代器Iterator"></a>&gt;<font color="green">迭代器Iterator</font></h3><p>迭代器是一种模式，可以使得序列类型的结构数据的遍历行为与被遍历的对象分离。无需关心对象底层的实现，只要拿到这个对象，就可以使用迭代器遍历这个对象的内部。</p><ul><li>Iterable 实现这个接口的集合对象支持迭代。实现Iterable后可以配合foreach使用。</li><li>Iterator 迭代器，提供迭代机制的对象。</li></ul><p>Iterator三个方法经常使用<code>hasnext()</code> <code>next()</code> <code>remove()</code>。其中<code>remove()</code>的使用需要先调用<code>next()</code>。</p><p>迭代出的对象也是引用的拷贝，结果还是引用。可以根据迭代出的元素直接修改对象。</p><p>Iterator的remove方法可以保证不跑出ModificationException异常即<code>Fail-fast</code>机制。</p><ul><li>for 和 Iterator的区别</li></ul><ol><li>ArrayList对随机访问快速，而for循环中的<code>get()</code>方法采用的是随机访问的方法，因此在ArrayList里，for循环较快。</li><li>LinkedList顺序访问较快，Iterator中的<code>next()</code>方法使用顺序访问，因此在LinkedList里，使用iterator更快。</li><li>for循环适合快速指定元素拿取数据。Iterator适合链式结构。</li></ol><h3 id="gt-双亲委派机制"><a href="#gt-双亲委派机制" class="headerlink" title="> 双亲委派机制"></a>&gt; <font color="green">双亲委派机制</font></h3><p>当要加载某个类时，需要把任务委托给上级类加载器，递归询问是否已经加载此类，如果没有，自己才会加载。</p><p><img src="/2021/03/15/java/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" alt="句柄"></p><ol><li>启动类加载器（BootstrapClassLoader）<code>C++</code> 编写</li></ol><p>加载<code>java</code>核心库 <code>java.*</code>,构造<code>ExtClassLoader</code>和<code>AppClassLoader</code>。涉及到虚拟机本地实现细节，开发者无法获取到启动类加载器的引用，不允许直接通过引用进行操作。</p><ol start="2"><li>标准扩展类加载器（ExtClassLoader）<code>java</code> 编写</li></ol><p>加载扩展库如<code>classpath</code>中的<code>jre</code> ，<code>javax.*</code>或者<br><code>java.ext.dir</code> 指定位置中的类，开发者可使用标准扩展类加载器。</p><ol start="3"><li>系统类加载器 （AppClassLoader）<code>java</code> 编写</li></ol><p>加载程序所在的目录，如<code>user.dir</code>所在的位置的<code>class</code>。</p><ol start="4"><li>用户自定义类加载器（CustomClassLoader）<code>java</code> 编写</li></ol><p>用户自定义的类加载器,可加载指定路径的<code>class</code>文件</p><p>作用：</p><p>1.防止重复加载同一个类。</p><p>2.防止代码被篡改。（只能有一个被加载的类，已经加载的类不能被篡改）。</p><h3 id="gt-volatile关键字"><a href="#gt-volatile关键字" class="headerlink" title="> volatile关键字"></a><font color="green">&gt; volatile关键字</font></h3><p>1.保持可见性。</p><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。（强制重读）</p><p>可见性不能保证线程安全。线程安全的三个条件：原子性、可见性、禁止重排序。三者的解释可参考<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p><p>2.禁止指令重排序。</p><pre class="line-numbers language-none"><code class="language-none">x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果语句3是带有volatile关键字的，位于语句3前面的语句不能重排序至其后面，语句3后面的语句不能重排序到3前面。语句3前面的语句可以随便重排序，只要自己不要越过语句3就行。</p><p><strong>经典问题</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> inc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>                       test<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       inc<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果小于10000。原因：</p><p>假如某个时刻变量inc的值为10，</p><p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，线程2对变量进行自增操作，然后线程1被阻塞了；</p><p>　　由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><pre class="line-numbers language-none"><code class="language-none">i++操作可以被拆分为三步：     1，线程读取i的值     2、i进行自增计算     3、刷新回i的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　然后线程1接着进行加1操作，注意此时在线程1的工作内存中inc的值更新为11（volatile强制重读），但是线程1之前卡在了自增计算（非原子性操作，操作的还是10自增）所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存（11替换强制更新的11），最后写入主存。</p><p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1，结果都为11。</p><ul><li><strong>单例模式中的volatile</strong> 双检锁机制</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DoubleCheckedLocking</span> <span class="token punctuation">{</span> <span class="token comment">// 1</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> instance<span class="token punctuation">;</span> <span class="token comment">// 2</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Instance</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 3</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 4:第一次检查</span><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">DoubleCheckedLocking</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 5:加锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 6:第二次检查</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 7:问题的根源出在这里</span><span class="token punctuation">}</span> <span class="token comment">// 8</span><span class="token punctuation">}</span> <span class="token comment">// 9</span><span class="token keyword">return</span> instance<span class="token punctuation">;</span> <span class="token comment">// 10</span><span class="token punctuation">}</span> <span class="token comment">// 11</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第7行实际上编译后分为3步：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">// 1：分配对象的内存空间</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token comment">// 2：初始化对象</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>　　<span class="token comment">// 3：设置instance指向刚分配的内存地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译期会做指令重排序，所以会有：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">memory <span class="token operator">=</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token comment">// 1：分配对象的内存空间</span>instance <span class="token operator">=</span> memory<span class="token punctuation">;</span>　　<span class="token comment">// 3：设置instance指向刚分配的内存地址</span><span class="token comment">// 注意，此时对象还没有被初始化！</span><span class="token function">ctorInstance</span><span class="token punctuation">(</span>memory<span class="token punctuation">)</span><span class="token punctuation">;</span>　<span class="token comment">// 2：初始化对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当A线程上面132的顺序分配了对象，但是当A刚刚执行完毕3，B看到了instance已经不为<code>null</code>，B此时调用了空对象，发生<font color="red">错误</font>。</p><h3 id="lt-happens-before原则"><a href="#lt-happens-before原则" class="headerlink" title="< happens-before原则"></a><font color="green">&lt; happens-before原则</font></h3><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h3 id="lt-static-关键字"><a href="#lt-static-关键字" class="headerlink" title="<static 关键字"></a><font color="green">&lt;static 关键字</font></h3><blockquote><p>static 关键字</p></blockquote><p>java中不存在“全局变量”概念，可以用static表示“伪全局”概念。</p><p>被static修饰就是静态变量，所以JVM肯定将其放在单独的常量池里。JVM可以方便访问它们。</p><p>要点：</p><ol><li><p>被 static 修饰的成员变量和成员方法是独立于该类的。</p><p>静态变量和静态方法是随着类加载时被完成初始化的（类加载时已经存在），它在内存中仅有一个，且 JVM 也只会为它分配一次内存，同时类所有的实例都共享静态变量，可以直接通过类名来访问它。</p><p>可如下直接使用：</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ClassName</span><span class="token punctuation">.</span>propertyName<span class="token class-name">ClassName</span><span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span>……<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>它只能调用 static 变量和方法。</li><li>不能以任何形式引用 this、super。</li><li>static 变量在定义时必须要进行初始化，且初始化时间要早于非静态变量。</li></ol><h3 id="lt-final关键字"><a href="#lt-final关键字" class="headerlink" title="<final关键字"></a><font color="green">&lt;final关键字</font></h3><p>某些数据不可更改。final修饰的叫常量。“常量”的使用有以下两个地方：</p><ol><li>编译期常量，永远不可改变。</li><li>运行期初始化时，不可改变。根据对象的不同而表现不同，但同时又不希望它被改变，这个时候我们就可以使用运行期常量。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> final_01 <span class="token operator">=</span> <span class="token string">"demo"</span><span class="token punctuation">;</span><span class="token comment">//编译期常量，必须要进行初始化，且不可更改</span><span class="token keyword">public</span> <span class="token keyword">class</span> test<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> str<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Random</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> final_03 <span class="token operator">=</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//使用随机数来进行初始化,运行期初始化，每次new新的类都会改变内容（random）。</span>    <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>str<span class="token operator">=</span>s<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意点：</p><ol><li>final修饰的方法不能被修改重写，可以被继承。</li><li>final修饰的类不能修改不能继承，最终类。</li><li>匿名内部类中参数必须为final。</li></ol><h3 id="lt-java异常"><a href="#lt-java异常" class="headerlink" title="<java异常"></a><font color="green">&lt;java异常</font></h3><ol><li>异常的体系结构</li></ol><p>什么是异常？</p><p>异常指的就是程序的不正常，简单理解就是程序所发生的错误。</p><ul><li>分类</li></ul><p>a 编译时异常： 编译期间，编译器检测到某段代码可能会发生某些问题，需要程序员提前给代码做出错误的解决方案，否则编译无法通过。</p><p>b 运行时异常 编译正常，运行时出现了错误。</p><ul><li>体系结构</li></ul><p>a throwable</p><p>​    Error:严重错误</p><p>​    Exception:</p><p>​        RuntimeException</p><p>​        IRuntimeException</p><ul><li><p>异常出现的原理</p><p>java对异常的默认处理方式是抛出问题给上一级，如果出现了问题，java会根据问题所描述的异常类创建一个对象，底层通过throw关键字将该对象抛出给上一级。（mehtod -&gt; main -&gt; jvm -&gt; 将异常位置和错误原因打印）</p></li><li><p>异常的处理方式</p><ul><li><p>问题可以自己处理的</p><p>try catch处理方式 (后面的代码还可以继续执行)</p></li><li><p>问题处理不掉的</p><p>throw处理方式。 如果是RuntimeException异常，则方法上面无需throws声明。</p></li></ul></li></ul><p>throws 和 throw throws是仅仅对方法进行声明，告知调用者此方法存在异常。</p><p>throw是抛出。</p><ul><li><p>Spring框架的事务默认是RuntimeException才进行回滚</p><ul><li>解决方案 </li></ul><p>修改Transactional注解中的rollbackFor属性可以指定为exception异常回滚。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>rollbackFor<span class="token operator">=</span><span class="token punctuation">{</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>自己定义异常 （规范的异常类名，找一个类继承exception）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyPersonAgeException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeExceptoin</span><span class="token punctuation">(</span>或 <span class="token class-name">Exception</span><span class="token punctuation">)</span>        记得加入字符串的构造参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="lt-JAVA-集合"><a href="#lt-JAVA-集合" class="headerlink" title="<JAVA 集合"></a><font color="green">&lt;JAVA 集合</font></h3><p><img src="/2021/03/15/java/java%E9%9B%86%E5%90%88%E7%B1%BB.png" alt="句柄"></p><ol><li><strong>Collection</strong></li></ol><p>最基本的集合接口，它不提供直接的实现，JAVA SDK提供的类都是继承自Collection的<strong>子接口</strong>。所有实现Collection的接口类必须实现两类构造函数</p><p>a) 无参构造函数。创建空的Collection。</p><p>b) 有参构造函数，用于创建新的Collection。</p><p>解决ArrayLlist的线程不安全(<code>concurrentModificationException</code>)。</p><ol><li>换成<code>vector</code>。</li><li>换成`Collections.synchronizeList(new ArrayList());</li><li>new copyOnWriteArrayList();写时赋值。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">1.L</span>ista<span class="token punctuation">)</span> <span class="token class-name">ArrayList</span> 初始容量<span class="token number">10</span>。基于数组实现。每次扩容<span class="token number">1.5</span>倍。b<span class="token punctuation">)</span> <span class="token class-name">LinkedList</span>基于双向链表实现，近开头或结尾（靠近索引）遍历链表。c<span class="token punctuation">)</span> <span class="token class-name">Vector</span>与<span class="token class-name">ArrayList</span>一样，不同在于它是线程安全。d<span class="token punctuation">)</span> <span class="token class-name">Stack</span>继承自<span class="token class-name">Vector</span>，后进先出的栈。提供push pop peek empty search。<span class="token number">2.</span>Set与list区别是不包含重复元素。a）<span class="token class-name">EnumSet</span>枚举专用<span class="token class-name">Set</span>，所有元素都是枚举类型。b）<span class="token class-name">HashSet</span>查询速度最快的集合，内部以<span class="token class-name">Hashcode</span>实现，顺序也以哈希码排序。c）<span class="token class-name">TreeSet</span>排序状态的<span class="token class-name">Set</span>，以<span class="token class-name">TreeMap</span>实现，以自然元素顺序或用户自定义`<span class="token class-name">Comparator</span>`排序。<span class="token number">3.</span>Queue（<span class="token number">1</span>）不阻塞的： <span class="token class-name">PriorityQueue</span> 和 <span class="token class-name">ConcurrentLinkedQueue</span>　　<span class="token class-name">PriorityQueue</span> 和 <span class="token class-name">ConcurrentLinkedQueue</span> 类在 <span class="token class-name">Collection</span> <span class="token class-name">Framework</span> 中加入两个具体集合实现。 　　<span class="token class-name">PriorityQueue</span> 类实质上维护了一个有序列表。加入到 <span class="token class-name">Queue</span> 中的元素根据它们的天然排序（通过其 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Comparable</span> 实现）或者根据传递给构造函数的 <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span>Comparator</span> 实现来定位。　　<span class="token class-name">ConcurrentLinkedQueue</span> 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小，<span class="token class-name">ConcurrentLinkedQueue</span> 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列。（<span class="token number">2</span>）阻塞的：　　五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。五个队列所提供的各有不同：　　 <span class="token class-name">ArrayBlockingQueue</span> ：一个由数组支持的有界队列。　　 <span class="token class-name">LinkedBlockingQueue</span> ：一个由链接节点支持的可选有界队列。　　 <span class="token class-name">PriorityBlockingQueue</span> ：一个由优先级堆支持的无界优先级队列。　　 <span class="token class-name">DelayQueue</span> ：一个由优先级堆支持的、基于时间的调度队列。　　 <span class="token class-name">SynchronousQueue</span> ：一个利用 <span class="token class-name">BlockingQueue</span> 接口的简单聚集（rendezvous）机制。      <span class="token number">3.1</span> <span class="token class-name">ArrayDeque</span>    默认<span class="token number">16</span>，最小<span class="token number">8</span>。 object<span class="token punctuation">[</span><span class="token punctuation">]</span>数组存储。    栈操作：push pop peek 队列：offer poll peek    一般操作：add<span class="token comment">//尾 </span>    remove <span class="token comment">//首</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/%E9%98%9F%E5%88%97.png" alt="句柄"></p><ol start="2"><li><strong>Map</strong></li></ol><p>与List和set不同，由一对键值对组成的集合，key到value的映射。</p><p>a) HashMap</p><p><strong>链表+数组</strong>.内部定义hash表数组<code>Entry[] table</code>，元素通过哈希函数的到哈希地址转为数组存放索引，当有冲突同一个索引处保存链表。</p><p><img src="/2021/03/15/java/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="句柄"></p><p><strong>初始大小16</strong>，容量必须为$2^{n}$（<code>h &amp; (length-1)</code>这条规律成立前提长度必须是2的n次方）。JDK1.8 链表升级为<strong>红黑树</strong>结构。当本索引冲突<strong>大于8</strong>链表就转为红黑树，当冲突值小于6再转为普通链表。</p><p>高位右移动是为了扰动，防止哈希冲突</p><p><img src="/2021/03/15/java/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E9%AB%98%E4%BD%8D%E6%89%B0%E5%8A%A8.png" alt="句柄"></p><p>在对数组长度进行按位与运算后得到的结果相同，就发生了冲突。</p><p><code>h &gt;&gt;&gt; 16</code>过扰动计算之后，最终得到的index的值不一样了.</p><p>更多细节参考其他博客，写的比较详细，记住常问的就行。<a href="https://blog.csdn.net/xu_dongdong/article/details/80251936">https://blog.csdn.net/xu_dongdong/article/details/80251936</a> <a href="https://blog.csdn.net/woshimaxiao1/article/details/83661464">https://blog.csdn.net/woshimaxiao1/article/details/83661464</a></p><p>b) HashTable</p><ul><li><p><strong>线程安全</strong>，<code>(hash &amp; 0x7FFFFFFF) % tab.length</code>它是通过这句话直接对hash地址取模，不是像HashMap按位与。0x7FFFFFFF做一次按位与操作，主要是为了保证得到的index的第一位为0，也就是为了得到一个正数。因为有符号数第一位0代表正数，1代表负数。</p></li><li><p><strong>初始大小为11</strong>，之后每次扩充为<strong>原来的2n+1</strong>。HashTable的链表数组的默认大小是一个素数、奇数。之后的每次扩充结果也都是奇数。</p></li><li><p>当哈希表的大小为素数时，简单的取模哈希的结果会更加<strong>均匀</strong>。</p></li><li><p>和HashMap<strong>区别</strong></p></li></ul><p>1、继承的父类不同</p><p>   Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。</p><p>2、线程安全性不同</p><p> 如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。Hashtable 中的方法是Synchronize的，而HashMap中的方法在缺省情况下是非Synchronize的。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步，但使用HashMap时就必须要自己增加同步处理。</p><p>3、只有HashMap可以让你将空值作为一个表的条目的key或value</p><p>c) ConcurrentHashMap</p><ul><li>ConcurrentHashMap的hash实现和HashMap一样，但是<strong>用了不同的哈希算法</strong>（Wang/Jenkins 哈希算法）。</li><li><strong>线程安全</strong> <strong>“分段锁”的概念</strong>，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。</li></ul><p>ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。</p><ul><li>通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，<strong>但是效率提升N倍，默认提升16倍</strong>。</li></ul><p>ConcurrentHashMap原理可参考<a href="https://blog.csdn.net/xuefeng0707/article/details/40834595">https://blog.csdn.net/xuefeng0707/article/details/40834595</a></p><h3 id="gt-hashset-添加元素怎么判断对象是否重复的？"><a href="#gt-hashset-添加元素怎么判断对象是否重复的？" class="headerlink" title="> hashset 添加元素怎么判断对象是否重复的？"></a><font color="green">&gt; hashset 添加元素怎么判断对象是否重复的？</font></h3><p>1.第一，任何类都继承了Object类的hashcode（）方法，如果未重写hashcode，hashset会使用默认hashcode转化对象属性字段为散列码。<br>2.第二，当得到散列码确定插入的位置后，接下来hashset会调用 要添加对象的equals()方法 与已经在该位置上的所有对象进行比较，如果有一个为true，则不插入，如果为false，则插入。<br>注意，是调用的插入对象的equals方法，不是已经在hashset中的对象。</p><h3 id="lt-有没有goto语句"><a href="#lt-有没有goto语句" class="headerlink" title="<有没有goto语句"></a><font color="green">&lt;有没有<code>goto</code>语句</font></h3><p>有，也有<code>const</code>。JAVA只保留但基本不用了。</p><blockquote><p>一个<code>.class</code>文件可不可以有多个类</p></blockquote><p>可以有多个，但是public只有一个。两个以上public就不知道加载哪个类，会报错。</p><h3 id="lt-String-常量池"><a href="#lt-String-常量池" class="headerlink" title="< String 常量池"></a><font color="green">&lt; String 常量池</font></h3><p>字符串常量池底层是用<strong>HashTable</strong>实现的。</p><ol><li>创建对象的两种方式。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token comment">//第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>JDK版本中(1.7后), 字符串常量池被实现在Java堆内存中。</li></ol><pre class="line-numbers language-none"><code class="language-none">String str1 = "abc"; String str2 = "abc"; String str3 = "abc"; String str4 = new String("abc");String str5 = new String("abc");System.out.println(str4==str5);//false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98.png" alt="句柄"></p><ol start="3"><li><p><strong>“双引号””声明字符串的方式</strong>, </p><p>JVM首先会去<strong>字符串池</strong>中查找是否存在”abc”这个对象：</p></li></ol><ul><li>不存在，在字符串池中创建”abc”这个对象，将”abc”这个对象的引用地址返回给字符串常量s1。</li><li>如果存在，直接将池中”abc”这个对象的地址返回，赋给字符串常量。</li></ul><ol start="4"><li><p><strong>new字符串</strong></p><p>JVM首先在字符串池中查找有没有”abc”这个字符串对象：</p></li></ol><ul><li>存在，<strong>直接在堆</strong>中创建一个”abc”字符串对象，然后将堆中的”abc”对象的地址返回赋给引用str4。</li><li>不存在，<strong>字符串池</strong>中创建一个”abc”字符串对象，然后再在<strong>堆</strong>中创建一个”abc”字符串对象，将堆中”abc”字符串对象的地址返回赋给s3引用。</li></ul><ol start="5"><li><strong>intern()</strong> </li></ol><p>调用 intern方法时，查字符串池中：</p><ul><li><p>与此对象字符串<strong>内容相同</strong>，如果池已经包含一个等于此String对象的字符串（用**equals(object)**方法确定），则返回池中的字符串。</p></li><li><p>不相同，将此String对象添加到池中，并返回此String对象在常量池中的引用。 对于任意两个字符串s和t，所有字面值字符串和字符串赋值常量表达式都使用 intern()进行操作。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apend</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> str2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token operator">==</span>str3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s2 <span class="token operator">=</span> s1 <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token class-name">String</span> s3 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> <span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一条语句打印的结果为false，第二条语句打印的结果为true，这说明javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期再去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。由于s2只能在运行期间才能确定，所以s2指向的不是常量池中的“ab”。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 编译期确定 * 对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。 * 所以此时的"a" + s1和"a" + "b"效果是一样的。故结果为true。 */</span><span class="token class-name">String</span> s0 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token keyword">final</span> <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"b"</span><span class="token punctuation">;</span> <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"a"</span> <span class="token operator">+</span> s1<span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s0 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//result = true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>题目中的第一行代码被编译器在编译时优化后，相当于直接定义了一个”abcd”的字符串，所以，上面的代码应该只创建了一个String对象。写如下两行代码，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> s <span class="token operator">=</span><span class="token string">"a"</span> <span class="token operator">+</span> <span class="token string">"b"</span> <span class="token operator">+</span><span class="token string">"c"</span> <span class="token operator">+</span> <span class="token string">"d"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token operator">==</span> <span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最终打印的结果应该为true。</p><h3 id="lt-JVM结构"><a href="#lt-JVM结构" class="headerlink" title="< JVM结构"></a><font color="green">&lt; JVM结构</font></h3><p>HotSpot是使用指针的方式来访问对象：java堆中存放访问类元数据（描述数据的数据，也就是模板）的地址，reference存储的就直接是对象的地址。</p><p><img src="/2021/03/15/java/JVM1.7.png" alt="句柄"></p><p><img src="/2021/03/15/java/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="句柄"></p><pre class="line-numbers language-none"><code class="language-none">程序计数器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>程序计数器 <strong>线程私有</strong></li></ol><ul><li><p>概念：记录当前线程执行的<strong>指令字节码地址</strong>。</p></li><li><p>功能：改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p></li><li><p><strong>唯一一个不会出现 <code>OutOfMemoryError </code>的内存区域</strong>，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">虚拟机栈<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>虚拟机栈 <strong>线程私有</strong></li></ol><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png" alt="句柄"></p><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%882.png" alt="句柄"></p><ul><li><p>栈存储的是对象的引用变量、8种基本类型和实例方法。</p></li><li><p>栈帧理解成java中的方法。stackoverflowerror是个错误。</p></li><li><p>Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。</p></li><li><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p></li><li><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</p><p><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li><li><p>Java方法有两种返回方式：</p></li></ul><ol><li><p>return 语句。</p></li><li><p>抛出异常。</p><p>不管哪种返回方式都会导致栈帧被弹出。</p></li></ol><ul><li><strong>i++ 和 ++i 的区别：</strong><ol><li>i++：从局部变量表取出 i 并压入操作栈(load memory)，然后对局部变量表中的 i 自增 1(add&amp;store memory)，将操作栈栈顶值取出使用，如此线程从操作栈读到的是自增之前的值。</li><li>++i：先对局部变量表的 i 自增 1(load memory&amp;add&amp;store memory)，然后取出并压入操作栈(load memory)，再将操作栈栈顶值取出使用，线程从操作栈读到的是自增之后的值。</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">本地方法栈<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>本地方法栈 <strong>线程私有</strong></li></ol><ul><li><p> <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。（本地方法=android 里面的JNI 用其他语言例如C++)</p></li><li><p> 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p></li><li><p> 也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">java堆<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>堆 线程<strong>共享</strong></li></ol><ul><li><p>存放<strong>对象实例</strong>，几乎所有的对象实例以及<strong>数组</strong>都在这里分配内存。</p></li><li><p>主要记<strong>垃圾回收机制</strong>。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">方法区<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>方法区 线程<strong>共享</strong> JDK1.8替换为元空间</li></ol><ul><li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</li><li>别名叫做 Non-Heap（非堆）。永久代也叫方法区。</li></ul><pre class="line-numbers language-none"><code class="language-none">运行时常量池<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>运行时常量池 线程<strong>共享</strong></li></ol><ul><li><p>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p></li><li><p>运行期间也可能将新的常量放入池中，例如 String 类的 intern() 方法。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">直接内存<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>直接内存 线程<strong>共享</strong></li></ol><ul><li><p>不是 Java 虚拟机规范中定义的内存区域。</p></li><li><p>受到本机总内存（包括 RAM 以及 SWAP 区或者分页文件）大小以及处理器寻址空间的限制。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">元空间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="8"><li>元空间 线程<strong>共享</strong></li></ol><ul><li>使用本地内存（直接内存）来存储类元数据信息并称之为：元空间（Metaspace）</li><li>java8中移除了永久代（就是<strong>方法区</strong>），新增元空间，这两者之间存储的内容（常量池，类信息，还有class的static变量）几乎没怎么变化，而是在内存限制、垃圾回收等机制上改变较大。元空间的出现就是为了解决突出的类和类加载器元数据过多导致的内存溢出问题。</li></ul><ol><li>使用JDK1.7运行Java程序，监控并耗尽默认设定的85MB大小的PermGen（1.7之前是PermGen，1.8改为元空间）内存空间。</li><li>使用JDK1.8运行Java程序，监控新Metaspace内存空间的动态增长和垃圾回收过程。</li><li>使用JDK1.8运行Java程序，模拟耗尽通过“MaxMetaspaceSize”参数设定的128MB大小的Metaspace内存空间。</li></ol><p><img src="/2021/03/15/java/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA3.png" alt="句柄"></p><ol start="9"><li>堆参数调优</li></ol><table><thead><tr><th>-Xms</th><th>设置初始分配大小，默认为物理内存的“1/64”</th></tr></thead><tbody><tr><td>-Xmx</td><td>最大分配内存，默认为物理内存的”1/4”</td></tr><tr><td>-XX:+PrintGCDetails</td><td>输出详细的GC处理日志</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>设置对象在新生代中的存活的次数</td></tr></tbody></table><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token punctuation">{</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Runtime<span class="token punctuation">.</span>GetRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>最好初始内存和最大内存设置成一样的。避免内存忽高忽低。</li></ul><h3 id="lt-垃圾回收机制"><a href="#lt-垃圾回收机制" class="headerlink" title="< 垃圾回收机制"></a><font color="green">&lt; 垃圾回收机制</font></h3><p>GC = YGC = 轻量级GC</p><p>养老区满了 FULL GC = FGC 重量级GC，如果没办法腾空间，则OOM</p><ol><li><strong>判定</strong>哪些对象是垃圾</li></ol><ul><li>引用计数法</li></ul><p>每个对象都分配一个引用计数器，用来存储该对象被引用的个数。当有地方引用它，计数器加1。当个数为0，则可以回收。</p><p>此方法有一个<strong>缺陷</strong>：两个对象互相引用，计数器永远不为0。所以JAVA没采用此方法。</p><ul><li>可达性分析</li></ul><p>把所有引用对象抽象成一棵树，从树<strong>GC Roots</strong>根结点出发，遍历所有树枝。找到的就是可达，判定存活，不能找到的就是可回收对象。</p><p><img src="/2021/03/15/java/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="句柄"></p><ul><li>GC Roots的种类：</li></ul><p>虚拟机栈中引用的对象。</p><p>方法区中静态属性引用的对象。</p><p>方法区中常量引用的对象。</p><p>本地方法栈中JNI引用的对象。</p><p><img src="/2021/03/15/java/gc.PNG"></p><ol start="2"><li><strong>回收垃圾算法</strong> （4个）</li></ol><ul><li>标记-清理</li></ul><p>1）标记，利用可达性分析，找到垃圾对象。</p><p>优点：简单快捷。</p><p>缺点：产生内存碎片。</p><p><img src="/2021/03/15/java/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png" alt="句柄"></p><ul><li>标记-整理</li></ul><p>标记清理会产生内存碎片所以：</p><p>1）可达性分析找到垃圾对象和存活对象。</p><p>2）把所有存活对象堆到同一个地方，没有内存碎片。</p><p>适合存活对象多，垃圾少的情况。</p><p><img src="/2021/03/15/java/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="句柄"></p><ul><li>复制</li></ul><p>将内存划分为大小相等的两块，每次使用其中一块。这一块用完了，将活着的队形复制到另一块，然后把使用过的内存空间一次性清理掉。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="句柄"></p><p>优点：简单快速、不会产生碎片</p><p>缺点：内存利用率很低，只用了一半。</p><ul><li><strong>分代回收算法</strong></li></ul><p>java堆分为刚刚创建的对象、存活了一段时间的对象和永久存在的对象。</p><p>新生代与老年代的比例为1：2。</p><p><img src="/2021/03/15/java/java%E6%96%B0%E7%94%9F%E4%BB%A3.png" alt="句柄"></p><p><strong>设置两个 Survivor 区解决内存碎片化</strong>。Survivor 如果只有一个区域，Minor GC 执行后，Eden 区被清空了，存活的对象放到了 S1（from） 区，而之前 S1 区中的对象，可能也有一些是需要被清除的。这时候我们怎么清除它们？在这种场景下，我们只能标记清除，标记清除最大的问题就是内存碎片。有了s2（to），将之前 Eden 区和 From 区（s1)中的存活对象复制到 To 区域(s2)。第二次 Minor GC 时，From 与 To 职责换一下，这时候会将 Eden 区和 s2 区中的存活对象再复制到 s1 区域，以此反复。</p><p><strong>新生代-复制 回收机制</strong>：</p><p>区域大小比例Eden:s1:s2= 8: 1:1（Hotspot虚拟机这样划分）。新生代每次都有大量对象死亡，只有少量存活。因此采用复制算法，回收时GC把少量存活对象复制过去即可。</p><p><strong>只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</strong></p><p><img src="/2021/03/15/java/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="句柄"></p><p>工作原理：</p><p>1）Eden区域快满了，**触发垃圾回收机制（Young GC)**。此轮存活对象放入From(s1)。</p><p>2）Eden再次满，<strong>触发垃圾回收机制（Young GC)<strong>，回收Eden和From（s1），存活放入To（s2）。此时s1空了，下一次回收时</strong>s1和s2职责对换</strong>，下一次Eden满时将Eden和To（s2）的存活对象放入From（s1）， 如此往复。多次后一些对象在s1和s2之间多次复制，复制次数超过某个阈值<strong>（16）</strong>后，把存活对象复制到Old区域。</p><p>3）当某个s区域不足以存放存活对象，将多余对象放到Old区域。</p><p>4）Old区域满了，<strong>触发垃圾回收机制（Full GC）</strong>，进行整个堆的垃圾回收（老年代也要回收了，用老年代自己的回收算法），跳到1）进行新一轮垃圾回收算法。</p><p><strong>老年代-标记整理 回收机制</strong>：</p><p>老年代存活对象多、垃圾少。老年代仅仅通过少量地移动存活对象就能清理垃圾。</p><p><strong>Full GC</strong> 触发情况：</p><p>　　1）年老代（Tenured）被写满</p><p>　　2）持久代（Perm）被写满 </p><p>　　3）System.gc()被显示调用 </p><p>　　4）上一次GC之后Heap的各域分配策略动态变化</p><ol start="3"><li><strong>垃圾回收器</strong> （hotspot虚拟机）</li></ol><ul><li>吞吐量</li></ul><p>CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。比如说虚拟机总运行了 100 分钟，用户代码时间 99 分钟，垃圾回收 时间 1 分钟，那么吞吐量就是 99%。</p><ul><li>停顿时间</li></ul><p>停顿时间 指垃圾回收器正在运行时，应用程序 的 暂停时间。</p><ul><li>GC的名词</li></ul><p>新生代GC：Minor GC </p><p>老年代GC：Major GC</p><ul><li>并发与并行</li></ul><p>（1）串行（Parallel）</p><p>垃圾回收线程 进行垃圾回收工作，但此时 用户线程 仍然处于 等待状态。</p><p>（2）并发（Concurrent）</p><p>这里的并发指 用户线程 与 垃圾回收线程 交替执行。</p><p>（3）并行（Parallel）</p><p>这里的并行指 用户线程 和多条 垃圾回收线程 分别在不同 CPU 上同时工作。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="句柄"></p><p>回收器种类：</p><p><strong>1）Serial（单线程）</strong></p><p>Serial 回收器是最基本的 新生代垃圾回收器，是单线程的垃圾回收器。采用的是 <strong>复制</strong>算法。垃圾清理时，Serial回收器不存在线程间的切换，因此，在单 CPU的环境下，垃圾清除效率比较高。</p><p><strong>2）Serial Old（单线程）</strong></p><p>Serial Old回收器是 Serial回收器的老生代版本，单线程回收器，使用 <strong>标记-整理算法</strong>。在 JDK1.5 及其以前，它常与Parallel Scavenge回收器配合使用，达到较好的吞吐量，另外它也是 CMS 回收器在Concurrent Mode Failure时的后备方案。</p><p><strong>3）ParNew（多线程）</strong></p><p>ParNew回收器是在Serial回收器的基础上演化而来的，属于Serial回收器的多线程版本，采用<strong>复制</strong>算法。运行在新生代区域。在实现上，两者共用很多代码。在不同运行环境下，根据CPU核数，开启不同的线程数，从而达到最优的垃圾回收效果。</p><p><img src="/2021/03/15/java/parnew%E5%92%8Cserial%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="句柄"></p><p><strong>4）Parallel Scavenge（多线程）</strong></p><p>运行在新生代区域，属于多线程的回收器，采用<strong>复制</strong>算法。与ParNew不同的是，ParNew回收器是通过控制垃圾回收的线程数来进行参数调整，而Parallel Scavenge回收器更关心的是程序运行的吞吐量。即一段时间内用户代码运行时间占总运行时间的百分比。</p><p><strong>5）Parallel Old（多线程）</strong></p><p>Parallel Old回收器是Parallel Scavenge回收器的老生代版本，属于多线程回收器，采用<strong>标记-整理算法</strong>。Parallel Old回收器和Parallel Scavenge回收器同样考虑了吞吐量优先这一指标，非常适合那些注重吞吐量和CPU资源敏感的场合。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6parallelold.png" alt="句柄"></p><p><strong>6）CMS（多线程回收）</strong></p><p>CMS回收器是回收老年代收集器。在最短回收停顿时间为前提的回收器，属于多线程回收器，采用标记-清除算法。</p><p><img src="/2021/03/15/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6CMS.png" alt="句柄"></p><p>初始标记 ：标记GC Roots能直接关联到的对象，需要在safepoint位置暂停所有执行线程。</p><p>并发标记 ：进行GC Roots Tracing，遍历完从root可达的所有对象。该阶段与工作线程并发执行。</p><p>重新标记 ：修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录。需要在safepoint位置暂停所有执行线程。</p><p>并发清理 ：内存回收阶段，将死亡的内存对象占用的空间增加到一个空闲列表(free list),供以后的分配使用。</p><p>重置 ：清理数据结构,为下一个并发收集做准备。</p><p><strong>7）G1回收器</strong></p><p>G1是 JDK 1.7中正式投入使用的用于取代CMS的压缩回收器。<strong>基于标记整理</strong>的垃圾回收器。年轻代分为Eden和Survivor两个区，老年代分为Old和Humongous（大对象，占用的空间超过了分区容量50%）两个区。</p><p>G1首先将堆分为大小相等的 Region，避免全区域的垃圾回收。G1的分区示例如下图所示：</p><p><img src="/2021/03/15/java/G1%E5%9B%9E%E6%94%B6%E5%99%A8.png" alt="句柄"></p><p>G1把堆内存分为大小相等的内存分段，默认情况下会把内存分为2048个内存分段。比如32G堆内存，2048个内存分段每段的大小为16M。这相当于把内存化整为零。内存分段是物理概念，代表实际的物理内存空间。每个内存分段都可以被标记为Eden区，Survivor区，Old区，或者Humongous区。</p><p>G1引进了<strong>RSet的概念</strong>Remembered Set，作用是跟踪指向某个heap区内的对象引用。记录老年代到新生代之间的引用。</p><p>如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，<strong>卡表（Card Table）</strong>。</p><p><img src="/2021/03/15/java/G1RS.png" alt="句柄"></p><p>当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即标记为脏被引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p><p>G1垃圾回收过程主要包括三个：</p><ul><li>年轻代回收（young gc）过程</li><li>老年代并发标记（concurrent marking）过程</li><li>混合回收过程（mixed gc）。</li></ul><p>1）Young GC</p><ul><li>阶段1：根扫描<br>静态和本地对象被扫描</li><li>阶段2：更新RS<br>处理dirty card队列更新RS</li><li>阶段3：处理RS<br>检测从年轻代指向年老代的对象</li><li>阶段4：对象拷贝<br>拷贝存活的对象到survivor/old区域</li><li>阶段5：处理引用队列<br>软引用，弱引用，虚引用处理</li></ul><p>2）并发标记+垃圾回收</p><ul><li>初始标记（initial mark，STW）<br>在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</li><li>根区域扫描（root region scan）<br>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</li><li>并发标记（Concurrent Marking）<br>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断</li><li>最终标记（Remark，STW）<br>该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。</li><li>清除垃圾（Cleanup，STW）<br>在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。</li></ul><p>了解并发标记的<strong>三色标记算法</strong>。</p><p>收集器总结：</p><table><thead><tr><th align="center">收集器</th><th align="center">执行方式</th><th align="center">分代</th><th align="center">算法</th><th align="center">目标</th><th align="center">场景</th></tr></thead><tbody><tr><td align="center">Serial</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">响应速度优先</td><td align="center">单CPU下的客户端模式</td></tr><tr><td align="center">Serial Old</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单CPU下的客户端和CMS后备方案</td></tr><tr><td align="center">ParNew</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">响应速度优先</td><td align="center">多CPU在服务器模式下与CMS配合</td></tr><tr><td align="center">Parallel Scavenge</td><td align="center">并行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">吞吐量优先</td><td align="center">后台计算不需要太多交互任务</td></tr><tr><td align="center">Parallel Old</td><td align="center">并行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">吞吐量优先</td><td align="center">后台计算不需要太多交互任务</td></tr><tr><td align="center">CMS</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在网站或B/S系统服务</td></tr><tr><td align="center">G1</td><td align="center">并发</td><td align="center">两者都有</td><td align="center">标记整理+复制</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，替换CMS</td></tr></tbody></table><ul><li>4.方法区回收条件：</li></ul><p>只有同时满足以下三个条件才会被回收！</p><p>1）所有实例被回收</p><p>2）加载该类的ClassLoader被回收</p><p>3）Class对象无法通过任何途径访问(包括反射)</p><blockquote><p>java switch 作用于哪些类型</p></blockquote><p>char byte short int Charator Byte Short Integer String Enum枚举类型。</p><blockquote><p>short a=a+1; short a+=1;是否报错？</p></blockquote><p>short a =a+1。int转short强制类型编译报错。</p><p>+=是java内置符号，不会报错。</p><h3 id="lt-java-内存模型"><a href="#lt-java-内存模型" class="headerlink" title="< java 内存模型"></a><font color="green">&lt; java 内存模型</font></h3><p><img src="/2021/03/15/java/JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="句柄"></p><p>Java内存模型的主要目标是定义程序中<strong>变量的访问规则</strong>。即在虚拟机中将变量存储到主内存或者将变量从主内存取出这样的底层细节。需要注意的是这里的<strong>变量跟我们写java程序中的变量不是完全等同的</strong>。这里的变量是指实例字段，静态字段，构成数组对象的元素，但是不包括局部变量和方法参数(因为这是线程私有的)。这里可以简单的认为主内存是java虚拟机内存区域中的堆，局部变量和方法参数是在虚拟机栈中定义的。但是在堆中的变量如果在多线程中都使用，就涉及到了堆和不同虚拟机栈中变量的值的一致性问题了。</p><ul><li><p>主内存：java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，可以<strong>简单</strong>认为是堆区（仅仅做解释，实际不是）。不是物理内存，这里指的是虚拟机的主内存，它是虚拟机内存中的一部分。</p></li><li><p>工作内存：java虚拟机中每个线程都有自己的工作内存，该内存是线程私有的为了方便理解，可以认为是虚拟机栈。线程的工作内存保存了线程需要的变量在主内存中的副本。<strong>线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量</strong>。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。</p></li></ul><p>java内存中线程的工作内存和主内存的交互是由java虚拟机定义了如下的8种操作来完成的。</p><ul><li><p><strong>lock(锁定)</strong>:作用于主内存的变量，一个变量在同一时间只能一个线程锁定，该操作表示这条线成独占这个变量</p></li><li><p><strong>unlock(解锁)</strong>:作用于主内存的变量，表示这个变量的状态由处于锁定状态被释放，这样其他线程才能对该变量进行锁定</p></li><li><p><strong>read(读取)</strong>:作用于主内存变量，表示把一个主内存变量的值传输到线程的工作内存，以便随后的load操作使用</p></li><li><p><strong>load(载入)</strong>:作用于线程的工作内存的变量，表示把read操作从主内存中读取的变量的值放到工作内存的变量副本中(副本是相对于主内存的变量而言的)</p></li><li><p><strong>use(使用)</strong>:作用于线程的工作内存中的变量，表示把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时就会执行该操作</p></li><li><p><strong>assign(赋值)</strong>:作用于线程的工作内存的变量，表示把执行引擎返回的结果赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行该操作</p></li><li><p><strong>store(存储)</strong>:作用于线程的工作内存中的变量，把工作内存中的一个变量的值传递给主内存，以便随后的write操作使用</p></li><li><p><strong>write(写入)</strong>:作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中</p></li></ul><p>执行这些操作需要遵循文中一开始记录的<strong>Happens-before</strong>原则。</p><h3 id="lt-引用类型"><a href="#lt-引用类型" class="headerlink" title="< 引用类型"></a><font color="green">&lt; 引用类型</font></h3><p>JAVA <strong>4种</strong>引用类型。</p><ol><li>强引用</li></ol><p>java默认的声明就是强引用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只要obj还指向Object对象，Object对象就不会被回收</span>obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token comment">//手动置null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只要强引用存在，垃圾回收就不会回收它。除非你手动置为空，或者对象的生存周期结束（局部对象，函数调用完毕）。</p><ol start="2"><li>软引用</li></ol><p>JAVA 1.2之后，用<code>java.lang.ref.SoftReference</code>表示软引用。</p><p>当内存不够用时，才会回收软引用对象。如果回收后内存还不够用，才会OOM（Out Of  Memory)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> rev <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 还没有被回收器回收，直接获取</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 由于内存吃紧，所以对软引用的对象回收了</span>sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 重新构建</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果设置JVM内存只有<strong>2M</strong>，下面这个代码每次分配1M的内存，看看什么结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestOOM</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">testSoftReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testSoftReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主动通知垃圾回收</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SoftReference</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/03/15/java/OOM%E6%B5%8B%E8%AF%95.png" alt="句柄"></p><p>调用了很多次，只有一个对象时存在的，其他都是<code>null</code>被回收了。</p><ol start="3"><li>弱引用</li></ol><p>比软引用还弱。<strong>无论内存是否足够，只要JVM开始进行垃圾回收，那些被弱引用关联的对象都要回收。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testWeakReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//主动通知垃圾回收</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">WeakReference</span><span class="token punctuation">)</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是限定内存2M，每次byte数组使用1M，让其内存不够用，看结果：</p><p><img src="/2021/03/15/java/%E5%BC%B1%E5%BC%95%E7%94%A8.png" alt="句柄"></p><p>所有对象都回收了。</p><ol start="4"><li>虚引用</li></ol><p><code>PhantomReference</code>表示虚引用，它是最弱的引用。<strong>对象仅有虚引用，和没有引用一样，随时可能被回收</strong>。<strong>必须要和<code>ReferenceQueue</code>引用队列一起使用。</strong></p><p>看它的<code>PhantomReference</code>类的源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">/**     * Returns this reference object's referent.  Because the referent of a     * phantom reference is always inaccessible, this method always returns     * &lt;code&gt;null&lt;/code&gt;.     *     * @return  &lt;code&gt;null&lt;/code&gt;     */</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">PhantomReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> referent<span class="token punctuation">,</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>它的get永远返回<code>null</code>。无法通过虚引用引用对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span> refQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>refQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这没法引用对象，有<strong>他妈的</strong>啥用呢？</p><p><strong>可以用来跟踪对象呗。</strong>它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。</p><p>与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。</p><p>有个例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> TEST_DATA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> QUEUE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">TestClass</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token string">"Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 该线程不断读取这个虚引用，并不断往列表里插入数据，以促使系统早点进行GC</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                TEST_DATA<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 这个线程不断读取引用队列，当弱引用指向的对象被回收时，该引用就会被加入到引用队列中</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TestClass</span><span class="token punctuation">&gt;</span></span> poll <span class="token operator">=</span> QUEUE<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>poll <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--- 虚引用对象被jvm回收了 ---- "</span> <span class="token operator">+</span> poll<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--- 回收对象 ---- "</span> <span class="token operator">+</span> poll<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">TestClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"TestClass - "</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序输出：</p><p><img src="/2021/03/15/java/%E8%99%9A%E5%BC%95%E7%94%A8%E8%B7%9F%E8%B8%AA%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E7%8A%B6%E6%80%81.png" alt="句柄"></p><h3 id="lt-内存泄漏"><a href="#lt-内存泄漏" class="headerlink" title="< 内存泄漏"></a><font color="green">&lt; 内存泄漏</font></h3><p>JAVA GC回收本质上还是判断一个对象是否被引用的方式。如果，<strong>JVM误以为此对象还在引用中，无法回收，造成内存泄漏。</strong></p><p>8种常见情况：</p><p>1）<strong>static字段太多</strong></p><p>原因：静态字段拥有和整个应用程序一样的生命周期。<strong>想一想单例模式的static，对象如果太大就gg了</strong></p><p>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式。</p><p>2）<strong>未关闭资源</strong></p><p>原因：每次使用JAVA IO流等创建读取流时，JVM都会为这些资源分配内存。</p><p>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块。</p><p>3）<strong>hashcode()和不正确的equals()</strong></p><p>原因：在HashMap和HashSet这种集合中，equal()和hashCode()来比较对象，如果重写不合理，将会成为潜在的内存泄露问题。</p><p>比如：当一个对象被存储进HashSet集合中，不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同，始终让GC以为对象有引用，无法回收。</p><p>解决办法：用最佳的方式重写equals()和hashCode。</p><ol start="4"><li><strong>引用外部类的内部类</strong></li></ol><p>原因： <strong>非静态内部类</strong>的初始化，需要外部类实例才能使用；默认情况下，每个非静态内部类有对外部类的引用，引用了这个内部类，那么外部类对象超出范围后，它也不会被垃圾收集。</p><p>解决办法：如果内部类不需要访问包含的类成员，考虑转换为静态类。</p><p>5）<strong>finalize()方法造成的内存泄露</strong></p><p>原因：重写finalize()方法时，该类的对象不会立即被垃圾收集器收集，如果finalize()方法的代码有问题，那么会潜在的引发OOM；</p><p>解决办法：避免重写finalize()。</p><p>6）<strong>ThreadLocal</strong></p><p>使用ThreadLocal时，每个线程只要处于存活状态就可保留对ThreadLocal变量的调用。使用不当，就会引起内存泄露。</p><p>一旦线程不在存在，ThreadLocals就应该被垃圾收集，而现在线程的创建都是使用线程池，线程池有线程重用的功能，因此线程就不会被垃圾回收器回收。所以使用到ThreadLocals来保留线程池中线程的变量副本时，ThreadLocals没有显示的删除时，就会一直保留在内存中，不会被垃圾回收。</p><p>解决办法：不在使用ThreadLocal时，调用remove()方法，该方法删除了此变量的当前线程值。不要使用ThreadLocal.set(null)，它只是查找与当前线程关联的Map并将键值对设置为当前线程为null。</p><p>7）<strong>常量字符串</strong></p><p>原因：读取一个很大的String对象，并调用了intern(），它将放到字符串池中，只要应用程序运行，该字符串就会保留，这就会占用内存，可能造成OOM。</p><p>解决办法：增加PermGen的大小，-XX:MaxPermSize=512m（1.7前）；升级Java版本，JDK1.7后字符串池转移到了堆中。</p><h3 id="lt-Fail-Fast机制"><a href="#lt-Fail-Fast机制" class="headerlink" title="< Fail-Fast机制"></a><font color="green">&lt; Fail-Fast机制</font></h3><p>HashMap 中有这种描述：</p><p>注意，迭代器的<strong>快速失败</strong>行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><p>“快速失败”也就是 fail-fast，它是 Java 集合的一种<strong>错误检测机制。</strong></p><p>当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。</p><ul><li>产生原因</li></ul><p> fail-fast 产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 <code>ConcurrentModificationException</code> 异常信息，从而产生 fail-fast。</p><p>你可以自己翻翻看<code>ArrayList</code>的源代码，发现有如下判断：</p><p><code>modCount != expectedModCount</code> ，就会抛出这个异常。</p><p>下面是<code>ArrayList</code>的迭代器示例代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>            <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">;</span><span class="token comment">//传进来时是外部的modCount，arraylist的实际大小</span>            <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cursor <span class="token operator">!=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/** 省略此处代码 */</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>                    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">/** 省略此处代码 */</span>            <span class="token punctuation">}</span>            <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expectedModCount<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>int expectedModCount = ArrayList.this.modCount;</code>所以调用这个方法后它的值是不可能会修改的，所以会变的就是 <code>modCount</code>。<code>modCount</code> 是在 AbstractList 中定义的，为全局变量，记录集合的实际大小。</p><p><code>ArrayList</code> 中无论<code> add、remove、clear</code> 方法只要是涉及了改变<code>ArrayList</code>元素的个数的方法都会导致 <code>modCount </code>的改变。</p><p>两个线程（线程 A，线程 B），其中线程 A 负责遍历 list、线程B修改 list。线程 A 在遍历 list 过程的某个时候（此时 <code>expectedModCount = modCount=N</code>），线程启动，同时线程B增加一个元素，这是 modCount 的值发生改变（<code>modCount + 1 = N + 1</code>）。线程 A 继续遍历执行 next 方法时，通告 <code>checkForComodification</code> 方法发现 <code>expectedModCount = N </code>，而 <code>modCount = N + 1</code>，两者不等，这时就抛出<code>ConcurrentModificationException</code> 异常，从而产生 fail-fast 机制。</p><h3 id="lt-final关键字修饰一个变量"><a href="#lt-final关键字修饰一个变量" class="headerlink" title="< final关键字修饰一个变量"></a><font color="green">&lt; final关键字修饰一个变量</font></h3><p>final关键字修饰一个变量是引用不能变，还是引用的对象不能变？</p><p><strong>引用不能变，对象内容可以变。</strong></p><h3 id="lt-finally关键字"><a href="#lt-finally关键字" class="headerlink" title="<finally关键字"></a><font color="green">&lt;finally关键字</font></h3><p>final : 修饰类时，不能被继承。</p><p>​            修饰方法时，不能被重写。</p><p>​            修饰变量时，只能赋值一次。</p><p>finally:是try语句中的一个语句体，不能单独使用，用来释放资源。</p><p>finalize:是一个方法，当垃圾回收器确定不存在该对象的更多引用时，由对象的垃圾回收器调用此方法。</p><p>finally是在<code>return</code>语句之后执行。如果catch里面有return语句，此时会先执行return将返回值打包并创建一个返回路径等待，接着往下搜寻有没有finally语句，如果有则需先执行finally语句，再根据创建好的返回路径返回。</p><p><font color="red">匿名内部类参数必须是final的。这是因为实例变量是在堆中的，局部变量在栈中，Lambda表达式会在另一个线程中执行。如果在线程中要访问一个局部变量，可能线程执行时该局部变量被销毁了，而final类型的局部变量在Lamda表达式中其实是一个拷贝。</font></p><h3 id="lt-接口和抽象类"><a href="#lt-接口和抽象类" class="headerlink" title="< 接口和抽象类"></a><font color="green">&lt; 接口和抽象类</font></h3><p>接口是否可继承接口?抽象类是否可实现(implements)接口?抽象类是否可继承具体类(concreteclass)?抽象类中是否可以有静态的main方法？</p><p>接口可以继承接口。抽象类可以实现(implements)接口，抽象类可以继承具体类。抽象类中可以有静态的main方法。</p><p>备注：只要明白了接口和抽象类的本质和作用，这些问题都很好回答，你想想，如果你是java语言的设计者，你是否会提供这样的支持，如果不提供的话，有什么理由吗？如果你没有道理不提供，那答案就是肯定的了。</p><p>只要记住抽象类与普通类的唯一区别就是不能创建实例对象和允许有abstract方法。</p><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是<code>public static final</code>类型，并且默认即为<code>public static final</code>类型。</p><p><font color="red">接口强调特定功能的实现，而抽象类强调所属关系。</font></p><h3 id="lt-8种基本类型的包装类和常量池"><a href="#lt-8种基本类型的包装类和常量池" class="headerlink" title="< 8种基本类型的包装类和常量池"></a><font color="green">&lt; 8种基本类型的包装类和常量池</font></h3><ul><li>Java 基本类型的包装类除了Float和Double，即Byte,Short,Integer,Long,Character；这几种包装类默认创建了数值**[-128，127]<strong>的相应类型的</strong>缓存**数据，但是超出此范围仍然会去创建新的对象。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">33</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出true</span><span class="token class-name">Integer</span> i11 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i22 <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i11 <span class="token operator">==</span> i22<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出false 因为两个对象比较</span><span class="token class-name">Double</span> i3 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span><span class="token class-name">Double</span> i4 <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 输出false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer 源代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/***始终缓存-128到127（包括端点）范围内的值，其他值是创建的对象。*/</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Integer i1=40；Java 在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</p><p>Integer i1 = new Integer(40);这种情况下会创建新的对象。</p><p><strong>JAVA8的ConcurrentHashMap为什么放弃了分段锁？</strong></p><p>原因：通过 JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点： 1、加入多个分段锁浪费内存空间。 2、生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。 3、为了提高 GC 的效率</p><p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？CAS</p><p>首先通过 hash 找到对应链表过后， 查看是否是第一个object， 如果是， 直接用cas原则插入，无需加锁，然后如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。</p><p><a href="https://blog.csdn.net/ddxd0406/article/details/81389583">https://blog.csdn.net/ddxd0406/article/details/81389583</a></p><p><a href="https://www.cnblogs.com/nullzx/p/8647220.html">https://www.cnblogs.com/nullzx/p/8647220.html</a></p><h3 id="lt-静态代码块、构造代码块、构造函数执行顺序"><a href="#lt-静态代码块、构造代码块、构造函数执行顺序" class="headerlink" title="< 静态代码块、构造代码块、构造函数执行顺序"></a><font color="green">&lt; 静态代码块、构造代码块、构造函数执行顺序</font></h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>        <span class="token comment">/**         * 构造代码         */</span>        <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行构造代码块..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 无参构造函数         */</span>        <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行无参构造函数..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">/**         * 有参构造函数         * @param id  id         */</span>        <span class="token keyword">public</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行有参构造函数..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了一个非常简单的类，该类包含无参构造函数、有参构造函数以及构造代码块，同时在上面也提过代码块是没有独立运行的能力，他必须要有一个可以承载的载体，那么编译器会如何来处理构造代码块呢？编译器会将代码块<strong>按照他们的顺序(假如有多个代码块)插入到所有的构造函数的最前端</strong>，这样就能保证不管调用哪个构造函数都会执行所有的构造代码块。</p><p>静态代码块，静态，其作用级别为类，构造代码块、构造函数，构造，其作用级别为对象。</p><p>1、静态代码块，它是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化。</p><p>2、构造代码块，每创建一个对象时就会执行一次，且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境。</p><p>3、构造函数，每创建一个对象时就会执行一次。同时构造函数是给特定对象进行初始化，而构造代码是给所有对象进行初始化，作用区域不同。</p><p>通过上面的分析，他们三者的执行顺序应该为：静态代码块 &gt; 构造代码块 &gt; 构造函数。</p><h3 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a><font color="green">java 反射</font></h3><ul><li>概念</li></ul><p>程序在运行时可以获取某个类的所有信息。</p><ul><li>优点</li></ul><p>静态编译：在编译时确定类型，绑定对象，即通过。</p><p>动态编译：在运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，降低类之间的耦合性。</p><p>（主要是体现了很大的灵活性）</p><ul><li>缺点</li></ul><p>反射是一种解释操作，我们告诉JVM某个类要做什么，这种方式慢于直接执行相同的操作。</p><ul><li>三种创建方式</li></ul><ol><li>Class.forName()</li><li>.class</li><li>.getClass();</li></ol><ul><li>和new的区别</li></ul><ol><li><p>new出来的对象无法访问其私有属性，但反射可以通过设置<code>setAccessible()</code>方法访问私有属性。</p></li><li><p>使用new创建实例必须知道类名，但是反射机制创建对象不知道类名也可。（比如说某个变量var已经定义好了 var.class 你就可以获得其类名是啥了,然后你再调用<code>newInstance()</code>）。</p></li></ol><h3 id="lt-switch语句能否作用在byte上，能否作用在long上，能否作用在String上"><a href="#lt-switch语句能否作用在byte上，能否作用在long上，能否作用在String上" class="headerlink" title="< switch语句能否作用在byte上，能否作用在long上，能否作用在String上?"></a><font color="green">&lt; switch语句能否作用在byte上，能否作用在long上，能否作用在String上?</font></h3><p>在switch（e）中，e只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。</p><p><em>switch语句能否作用在String上说错了，Java1.7之后已经支持这种写法了！</em></p><h3 id="lt-a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#lt-a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="<&nbsp;**a.hashCode() 有什么用？与 a.equals(b) 有什么关系？**"></a><font color="green">&lt;&nbsp;**a.hashCode() 有什么用？与 a.equals(b) 有什么关系？**</font></h3><p>hashCode() 方法对应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><h3 id="java线程池用过没有？"><a href="#java线程池用过没有？" class="headerlink" title=" java线程池用过没有？"></a><font color="green"> java线程池用过没有？</font></h3><blockquote><p>Executors提供了四种方法来创建线程池。</p></blockquote><ol><li>newFixedThreadPool() :创建固定大小的线程池。</li><li>newCachedThreadPool(): 创建无限大小的线程池，线程池中线程数量不固定，可根据需求自动更改。</li><li>newSingleThreadPool() : 创建单个线程池，线程池中只有一个线程。</li><li>newScheduledThreadPool() 创建固定大小的线程池，可以延迟或定时的执行任务。</li></ol><h5 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h5><ol><li>限制线程个数，避免线程过多导致系统运行缓慢或崩溃。</li><li>不需要频繁的创建和销毁，节约资源、响应更快。</li></ol><h3 id="lt-JAVA-并发"><a href="#lt-JAVA-并发" class="headerlink" title="< JAVA 并发"></a><font color="green">&lt; JAVA 并发</font></h3><p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p><p><strong>批处理操作系统</strong></p><p>后来有了<strong>批处理操作系统</strong>,把一系列需要操作的指令写下来，形成一个<strong>清单</strong>，一次性交给计算机。</p><p>批处理操作系统在一定程度上提高了计算机的效率，但是由于<strong>批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行</strong>，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以<strong>批处理操作效率也不高</strong>。</p><p><strong>进程的提出</strong></p><p>批处理操作系统的瓶颈在于内存中只存在一个程序，那么内存中能不能存在多个程序呢？进程应运而生。</p><p>进程就是<strong>应用程序在内存中分配的空间，也就是正在运行的程序</strong>，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态。</p><blockquote><p>程序：用某种编程语言(java、python等)编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，是<strong>一段静态代码</strong>。</p></blockquote><p>此时，CPU采用时间片轮转的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。 </p><blockquote><p>当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。</p></blockquote><p>使用进程+CPU时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，<strong>进程让操作系统的并发成为了可能</strong>。虽然并发从宏观上看有多个任务在执行，但在事实上，对于<strong>单核CPU</strong>来说，任意具体时刻都只有一个任务在占用CPU资源。</p><p><strong>对操作系统的要求进一步提高</strong></p><p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率。</p><blockquote><p>比如杀毒软件在检测用户电脑时，如果在某一项检测中卡住了，那么后面的检测项也会受到影响。或者说当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p></blockquote><p><strong>线程的提出</strong></p><p><strong>让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p><blockquote><p>使用线程之后，事情就变得简单多了。当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又使用清理垃圾功能，那么可以先暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p></blockquote><p>总之，进程和线程的提出极大的提高了操作系统的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p><p><strong>多进程的方式也可以实现并发，为什么要使用多线程？</strong></p><p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p><ul><li>进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li><li>进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</li></ul><p><strong>进程和线程的区别</strong></p><p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是<strong>是否单独占有内存地址空间及其它系统资源（比如I/O）</strong>：</p><ul><li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。 </li><li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。 </li><li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</li></ul><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p><h3 id="lt-上下文切换"><a href="#lt-上下文切换" class="headerlink" title="< 上下文切换"></a><font color="green">&lt; 上下文切换</font></h3><p>上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程）切换到另一个进程（或线程）。上下文是指<strong>某一时间点 CPU 寄存器和程序计数器的内容。</strong></p><blockquote><p>寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。</p><p>程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统。</p><p>举例说明 线程A - B  </p><p>1.先挂起线程A，将其在cpu中的状态保存在内存中。  </p><p>2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程。  </p><p>3.当B执行完，根据程序计数器中指向的位置恢复线程A。</p></blockquote><p>CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。</p><p>但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p><p>上下文切换通常是计算密集型的，意味着此操作会<strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。减少系统中上下文切换次数.</p><h3 id="gt-进程创建的几种方式"><a href="#gt-进程创建的几种方式" class="headerlink" title="&nbsp;>进程创建的几种方式"></a><font color="green">&nbsp;&gt;进程创建的几种方式</font></h3><ol><li>Thread 继承Tread，重写run方法。</li><li>Runnable 接口 重写run方法。</li><li>Callable接口，使用FutureTask类创建线程。</li><li>使用线程池。</li></ol><h3 id="lt-JAVA-线程状态"><a href="#lt-JAVA-线程状态" class="headerlink" title="< JAVA 线程状态"></a><font color="green">&lt; JAVA 线程状态</font></h3><p>java线程有6个状态：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">State</span><span class="token punctuation">{</span>    NEW<span class="token punctuation">,</span>    RUNNABLE<span class="token punctuation">,</span>    BLOCKED<span class="token punctuation">,</span>    WAITING<span class="token punctuation">,</span>    TIMED_WAITING<span class="token punctuation">,</span>    TERMINATED<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>NEW状态</li></ol><p>线程此时尚未启动。（还没有调用<code>start()</code>方法。）</p><p>注意：不可反复调用<code>start()</code>方法，会抛出不合法线程异常。</p><p>一个线程执行完毕（TERMINATED)，这个线程不可再调用start方法（仍然会返回TERMINATED状态）。</p><ol start="2"><li>RUNNABLE</li></ol><p>正在虚拟机种运行。</p><ol start="3"><li>BLOCKED</li></ol><p>等待锁释放。</p><ol start="4"><li>WAITING</li></ol><p>等待状态，处于等待状态的线程变为RUNNABLE状态需要被其他线程唤醒。以下三个方法：</p><ul><li><code>Object.wait()</code>：使得当前线程处于等待状态直到另一个线程唤醒它。</li><li><code>Thread.join()</code>：等待线程执行完毕，底层调用的时Object实例的wait方法。</li><li><code>LockSupport.park()</code>：除非获得调用许可，否则禁用当前线程进行调度。</li></ul><ol start="5"><li>超时等待</li></ol><ul><li><code>Thread.sleep(long millis)</code>：使当前线程睡眠指定时间；</li><li><code>Object.wait(long timeout)</code>：线程休眠指定时间，等待期间可以通过notify()/notifyAll()唤醒；</li><li><code>Thread.join(long millis)</code>：等待当前线程最多执行millis毫秒，如果millis为0，则会一直执行；</li><li><code>LockSupport.parkNanos(long nanos)</code>： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li><li><code>LockSupport.parkUntil(long deadline)</code>：同上，也是禁止线程进行调度指定时间；</li></ul><ol start="6"><li>TERMINATED</li></ol><p>终止状态，此时线程执行完毕。</p><p><img src="/2021/03/15/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png" alt="句柄"></p><h3 id="lt-CAS-与原子操作"><a href="#lt-CAS-与原子操作" class="headerlink" title="< CAS 与原子操作"></a><font color="green">&lt; CAS 与原子操作</font></h3><p>比较与交换（<strong>Compare And Swap</strong>）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量（var）</li><li>E：预期值（expected）</li><li>N：新值（new）</li></ul><p>过程如下：判断V是否等于E，如果等于，则将V的值设置为N。如果不等，则说明已经有其他线程更新了V，则当前线程放弃更新，什么不做。</p><p><strong>预期值E的本质就是指上一次的“旧值”。</strong></p><p>举个例子：</p><ol><li>如果有一个多个线程共享的变量<code>i</code>原本等于5，我现在在线程A中，想把它设置为新的值6;</li><li>我们使用CAS来做这个事情；</li><li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，<code>i</code>的值被设置成了6；</li><li>如果不等于5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为2），那么我就什么也不做，此次CAS失败，<code>i</code>的值仍然为2</li></ol><p><code>i</code>就是V，5就是E，6就是N。</p><p>CAS是一种原子操作，是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性。当多个线程同时使用CAS操作一个变量，只有一个会胜出并更新，但失败的进程不会挂起，仅被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><h4 id="JAVA-实现CAS原理"><a href="#JAVA-实现CAS原理" class="headerlink" title="JAVA 实现CAS原理"></a>JAVA 实现CAS原理</h4><p>使用了Unsafe类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token class-name">Object</span> expected<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">int</span> expected<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span><span class="token keyword">long</span> expected<span class="token punctuation">,</span><span class="token keyword">long</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Unsafe中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p><p>Linux的X86下主要是通过<code>cmpxchgl</code>这个指令在CPU级完成CAS操作的，但在多处理器情况下必须使用<code>lock</code>指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p><p>当然，Unsafe类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的<code>park</code>和<code>unpark</code>， LockSupport类底层就是调用了这两个方法。还有支持反射操作的<code>allocateInstance()</code>方法。</p><h3 id="java-util-concurrent-atomic-原子操作"><a href="#java-util-concurrent-atomic-原子操作" class="headerlink" title="java.util.concurrent.atomic 原子操作"></a>java.util.concurrent.atomic 原子操作</h3><p>JDK提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。在JDK 11中，有如下17个类：</p><p><img src="/2021/03/15/java/%E5%8E%9F%E5%AD%90%E7%B1%BB.jpg" alt="句柄"></p><p>从名字看出大概用途：</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段（属性）</li></ul><h3 id="Synchronized与ReetrantLock锁区别"><a href="#Synchronized与ReetrantLock锁区别" class="headerlink" title="Synchronized与ReetrantLock锁区别"></a><font color="green">Synchronized与ReetrantLock锁区别</font></h3><p>Synchronized 和ReetrantLock都是阻塞式同步。</p><p>其中Synchronized是Java关键字，需要jvm实现。它进入编译，会在同步块前后形成<code>monitorenter</code>和<code>monitorexit</code>两个字节码指令。执行<code>monitorenter</code>指令时，首先要尝试获取对象锁，如果这个对象锁没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1。相应的，在执行monitorexit指令时会将锁计算器减1，当计算器为0时，锁被释放。如果对象所获得失败，就要阻塞。</p><p>ReentrantLock 是juc(java.util.concurrent)包下提供的一套互斥锁，属于API层面。它有以下Synchronized没有的功能：</p><ol><li>等待可中断。持有锁的线程长期不释放时，等待的线程选择放弃等待。</li><li>公平锁。默认构造函数改为true。</li><li>可绑定多个对象。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReetrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Condition</span> contidtion <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Synchronized与锁"><a href="#Synchronized与锁" class="headerlink" title="Synchronized与锁"></a><font color="green">Synchronized与锁</font></h3><p>对外的依赖多少。</p><ol><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ol><p><img src="/2021/03/15/java/%E9%94%81%E5%8D%87%E7%BA%A7.PNG"></p><p>偏向锁CAS机制while 改成if。轻量级锁就是CAS（C++写的），如果竞争激烈，就转换为重量级锁（调用操作系统的阻塞）。</p><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它。</p><p>锁的升级很容易发生，但是锁降级发生的条件比较苛刻，锁降级发生在<code>Stop the world</code>期间，当JVM进入安全点的时候，会检查是否有闲置锁，然后进行降级。</p><ul><li>JAVA对象头</li></ul><p>java对象的锁都是基于对象的。非数组类型，则用2个字宽来存储对象头（64位机子，一个字宽64位）。数组类型用3个字宽来存储对象头。对象头内容如下表：</p><table><thead><tr><th align="center">长度</th><th align="center">内容</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">32/64bit</td><td align="center">Mark Word</td><td align="center">存储对象的hashCode或锁信息等</td></tr><tr><td align="center">32/64bit</td><td align="center">Class Metadata Address</td><td align="center">存储到对象类型数据的指针</td></tr><tr><td align="center">32/64bit</td><td align="center">Array length</td><td align="center">数组的长度（如果是数组）</td></tr></tbody></table><p>我们主要来看看Mark Word的格式：</p><table><thead><tr><th align="center">锁状态</th><th align="center">29 bit 或 61 bit</th><th align="center">1 bit 是否是偏向锁？</th><th align="center">2 bit 锁标志位</th></tr></thead><tbody><tr><td align="center">无锁</td><td align="center"></td><td align="center">0</td><td align="center">01</td></tr><tr><td align="center">偏向锁</td><td align="center">线程ID</td><td align="center">1</td><td align="center">01</td></tr><tr><td align="center">轻量级锁</td><td align="center">指向栈中锁记录的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">00</td></tr><tr><td align="center">重量级锁</td><td align="center">指向互斥量（重量级锁）的指针</td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">10</td></tr><tr><td align="center">GC标记</td><td align="center"></td><td align="center">此时这一位不用于标识偏向锁</td><td align="center">11</td></tr></tbody></table><p>当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的monitor对象的指针。</p><ul><li>偏向锁</li></ul><p>偏向锁偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不需要触发同步。 <strong>偏向锁在资源无竞争的情况下消除了同步语句，连CAS操作都不做，提高了程序的运行性能。</strong></p><p><img src="/2021/03/15/java/%E5%81%8F%E5%90%91%E9%94%81%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="句柄"></p><p>偏向锁使用一种<strong>等待竞争出现才释放锁的机制</strong>。</p><p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p><ol><li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态。</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ol><p><img src="/2021/03/15/java/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80.png" alt="句柄"></p><ul><li>轻量级锁</li></ul><p>多个线程在不同时段获取同一把锁，不存在锁竞争的情况，使用轻量级锁来避免线程的阻塞和唤醒。</p><p>加锁：JVM为每个线程在当前线程的栈帧中创建用于存储锁记录的空间——<code>Displaced Mark Word</code>。如果一个线程获得锁时发现时轻量级锁，会把<code>Mark Word</code>复制到自己的<code>Displaced Marked Word</code>中。</p><p>然后线程尝试用CAS将锁的<code>Mark Word</code>替换为指向锁记录的指针。成功则获得锁，失败则<code>Mark World</code>被替换成了其他线程的锁记录，说明与其他线程存在竞争锁，当前线程就尝试使用<code>自旋</code>来获取锁。</p><p><font color="green">自旋</font></p><p>自旋要消耗CPU，如果一直获不得锁，则一直处于自旋状态。JDK使用<font color="green">自适应自旋</font>，如果线程自旋成功，则下次自旋的次数会更多，如果失败了，则自旋的次数会减少。</p><p>如果一直自旋失败，则这个线程阻塞，同时锁升级为重量级锁。</p><p><font color="green">轻量级锁的释放：</font></p><p>释放锁时，当前线程使用CAS将<code>Dispalced Mark Word</code>的内容复制回锁的<code>Mark Word</code>里面。如果没有发生竞争，则这个复制操作成功。如果因为竞争升级成了重量级锁，那么CAS操作会操作失败，此时释放锁并唤醒被阻塞的线程。</p><p><img src="/2021/03/15/java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="句柄"></p><ul><li>重量级锁</li></ul><p>重量级锁依赖于操作系统的互斥量（mutex)实现，而操作系统线程间状态的转换需要比较长的时间，所以重量级锁的效率很低，但被阻塞的线程不会消耗CPU。</p><p>每一个对象都可以当成一个锁，当多个线程同时请求某一个对象锁时，对象锁设置几种状态用来区分请求的线程：</p><pre class="line-numbers language-none"><code class="language-none">Contention List：所有请求锁的线程将被首先放置到该竞争队列Entry List：Contention List中那些有资格成为候选人的线程被移到Entry ListWait Set：那些调用wait方法被阻塞的线程被放置到Wait SetOnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeckOwner：获得锁的线程称为Owner!Owner：释放锁的线程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果线程获得锁后调用<code>Object.wait</code>方法，则会将线程加入到WaitSet中，当被<code>Object.notify</code>唤醒后，会将线程从WaitSet移动到Contention List或EntryList中去。需要注意的是，当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</p><h3 id="总结锁的升级流程"><a href="#总结锁的升级流程" class="headerlink" title="总结锁的升级流程"></a>总结锁的升级流程</h3><p>每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><p>泛型</p><p><strong>把类型明确的工作推迟到创建对象或调用方法的时候</strong></p><p><font color="red"> 通配符不会用</font></p><h3 id="Servelet没看、HTTP、数据库"><a href="#Servelet没看、HTTP、数据库" class="headerlink" title="Servelet没看、HTTP、数据库"></a><font color="red">Servelet没看、HTTP、数据库</font></h3><h3 id="JAVA-8-新特性"><a href="#JAVA-8-新特性" class="headerlink" title="JAVA 8 新特性"></a>JAVA 8 新特性</h3><p>接口中的<code>default</code>新方法、<code>static</code>可以修饰方法了，并且提供实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Formula</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span> <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token class-name">String</span> hello<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过使用<code>default</code>方法可以在接口中实现具体方法（非抽象方法）<font color="red"> <code>default</code>方法不能被子类重写，只能继承</font>。</p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p><code>1. 中间操作</code>（返回<code>Stream&lt;T&gt;</code>和<code>终端操作</code>（返回定义类型的结果）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">long</span> count <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>可以替代循环的<code>anymatch</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> string <span class="token operator">:</span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>string<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//可以替换为如下：</span><span class="token keyword">boolean</span> isExist <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>过滤，选出想要的元素 <code>Filtering</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"One"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"OneAndOnly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Derek"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Change"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"factory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"justBefore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Italy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Italy"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Thursday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>通过一个函数转换你想得到的结果 <code>Mapping</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> uris <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uris<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C:\\My.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Path</span><span class="token punctuation">&gt;</span></span> stream <span class="token operator">=</span> uris<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>uri <span class="token operator">-&gt;</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>uri<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="5"><li><code>Matching</code></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">boolean</span> isValid <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isValidOne <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">allMatch</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isvalidTwo <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">noneMatch</span><span class="token punctuation">(</span>element <span class="token operator">-</span> <span class="token operator">&gt;</span> element<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"h"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="6"><li><code>Reduction</code> </li></ol><p>Imagine that you have a <em>List<integer></integer></em> and you want to have a sum of all these elements and some initial <em>Integer</em> (in this example 23). So, you can run the following code and result will be 26 (23 + 1 + 1 + 1).</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> reduced <span class="token operator">=</span> integers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="7"><li><code>Collecting</code></li></ol><p>把stream转为Collection或map。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> resultList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>element <span class="token operator">-&gt;</span> element<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/03/15/operate/"/>
      <url>2021/03/15/operate/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-操作系统的概念"><a href="#1-操作系统的概念" class="headerlink" title="1.操作系统的概念"></a>1.操作系统的概念</h2><ol><li>操作系统特征： 并发、 共享 、 虚拟、 异步。</li></ol><p><img src="/2021/03/15/operate/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5-1615794509246.PNG"></p><p>补充：进程是一个程序的执行过程。执行前需要将程序放入内存，才能被CPU处理。</p><p><img src="/2021/03/15/operate/%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88-1615794509247.PNG"></p><h3 id="1-1处理器的两种状态"><a href="#1-1处理器的两种状态" class="headerlink" title="1.1处理器的两种状态"></a>1.1处理器的两种状态</h3><p><img src="/2021/03/15/operate/%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%8A%B6%E6%80%81-1615794509247.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%A4%E7%A7%8D%E7%A8%8B%E5%BA%8F-1615794509247.PNG"></p><h3 id="1-2-大内核微内核"><a href="#1-2-大内核微内核" class="headerlink" title="1.2 大内核微内核"></a>1.2 大内核微内核</h3><p><img src="/2021/03/15/operate/%E5%A4%A7%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B81-1615794509248.PNG"></p><p>微内核：只包含一些必不可少的功能。</p><p>大内核：除了微内核还有其他非必要功能。</p><p><img src="/2021/03/15/operate/%E5%A4%A7%E5%86%85%E6%A0%B8%E5%BE%AE%E5%86%85%E6%A0%B82-1615794509248.PNG"></p><h3 id="1-3-中断和异常"><a href="#1-3-中断和异常" class="headerlink" title="1.3 中断和异常"></a>1.3 中断和异常</h3><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B81-1615794509248.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B82-1615794509248.PNG"></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B83-1615794509248.PNG"></p><p>这些操作执行完成后，操作系统会把CPU的使用权交还给应用进程。</p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B84-1615794509248.PNG"></p><p>进程无法直接中断，所以只能通过系统调用的方式请求输出。</p><p>tips： </p><ul><li>由于操作系统的管理工作需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。</li><li><font color="red">用户态—&gt;核心态是通过中断实现的，并且中断是唯一途径。</font>核心态—&gt;用户态的切换是通过执行特权指令，将程序状态字(PSW)的标志位设置为”用户态”。</li></ul><h4 id="1-3-1中断的分类"><a href="#1-3-1中断的分类" class="headerlink" title="1.3.1中断的分类"></a>1.3.1中断的分类</h4><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB-1615794509248.PNG"></p><p><font color="red">看中断是来自CPU内部还是外部。</font></p><p><img src="/2021/03/15/operate/%E4%B8%AD%E6%96%AD%E7%9A%84%E5%88%86%E7%B1%BB1-1615794509248.PNG"></p><h3 id="1-4-系统调用"><a href="#1-4-系统调用" class="headerlink" title="1.4 系统调用"></a>1.4 系统调用</h3><ul><li>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用来请求操作系统的服务。</li><li>系统调用和库函数有区别。</li></ul><h3 id="1-4-1库函数和系统调用的关系"><a href="#1-4-1库函数和系统调用的关系" class="headerlink" title="1.4.1库函数和系统调用的关系"></a>1.4.1库函数和系统调用的关系</h3><p><img src="/2021/03/15/operate/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1615794509248.PNG"></p><ul><li>传递系统调用参数—&gt;执行陷入指令（用户态）—&gt;执行系统调用相应的服务程序(核心态)—&gt;返回用户程序</li><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态进行。</li><li>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</li><li>凡是与资源有关的操作、会直接影响到其他进程的操作，一定需要操作系统介入，需要系统调用来实现。</li></ul><h2 id="2-进程与线程"><a href="#2-进程与线程" class="headerlink" title="2. 进程与线程"></a>2. 进程与线程</h2><h3 id="2-1-状态转移"><a href="#2-1-状态转移" class="headerlink" title="2.1 状态转移"></a>2.1 状态转移</h3><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81-1615794509248.PNG"></p><ul><li>为了方便对各个进程的管理，操作系统将进车给划分为几种状态，三种基本状态：<ol><li>运行态</li><li>就绪态</li><li>阻塞态</li></ol></li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%811-1615794509248.PNG"></p><h3 id="2-2-进程控制"><a href="#2-2-进程控制" class="headerlink" title="2.2 进程控制"></a>2.2 进程控制</h3><p>对系统中的所有进程进行有效管理。</p><ul><li>使用原语对进程的控制。</li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6-1615794509249.PNG"></p><p>进程控制原语要做三类事情：</p><ul><li>更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB）<ol><li>所有进程控制原语一定都会修改进程状态标志</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>某进程开始运行前必然要回复运行环境</li></ol></li><li>将PCB插入合适队列</li><li>分配/回收资源</li></ul><ol><li>进程创建原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B62-1615794509249.PNG"></p><ol start="2"><li>进程撤销原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2-1615794509249.PNG"></p><ol start="3"><li>进程阻塞和唤醒</li></ol><p>阻塞和唤醒是成对出现的。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B63-1615794509249.PNG"></p><ol start="4"><li>进程的切换原语</li></ol><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B64-1615794509249.PNG"></p><h3 id="2-3-进程通信"><a href="#2-3-进程通信" class="headerlink" title="2.3 进程通信"></a>2.3 进程通信</h3><ul><li>进程之间的信息交换和传递。</li><li>操作系统通信分类</li></ul><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-1615794509249.PNG"></p><ol><li>共享存储</li></ol><p><img src="/2021/03/15/operate/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8-1615794509249.PNG"></p><ol start="2"><li>管道通信</li></ol><p><img src="/2021/03/15/operate/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1-1615794509249.PNG"></p><ol start="3"><li>消息传递</li></ol><p><img src="/2021/03/15/operate/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92-1615794509249.PNG"></p><h3 id="2-4-进程调度"><a href="#2-4-进程调度" class="headerlink" title="2.4 进程调度"></a>2.4 进程调度</h3><p>调度有三个层次：</p><ol><li>高级调度 （调入内存）</li></ol><p><img src="/2021/03/15/operate/%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><ol start="2"><li>中级调度</li></ol><p><img src="/2021/03/15/operate/%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><ul><li>挂起状态的七状态模型</li></ul><p><img src="/2021/03/15/operate/%E6%8C%82%E8%B5%B77%E7%8A%B6%E6%80%81-1615794509249.PNG"></p><ul><li>低级调度（进程调度）</li></ul><p><img src="/2021/03/15/operate/%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6-1615794509249.PNG"></p><h3 id="2-5-进程调度时机和切换过程"><a href="#2-5-进程调度时机和切换过程" class="headerlink" title="2.5 进程调度时机和切换过程"></a>2.5 进程调度时机和切换过程</h3><h4 id="2-5-1-调度算法"><a href="#2-5-1-调度算法" class="headerlink" title="2.5.1 调度算法"></a>2.5.1 调度算法</h4><ol><li>先来先服务（FCFS)</li></ol><ul><li>主要从公平的角度考虑。</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列。</li><li>非抢占式算法。</li></ul><ol start="2"><li>短作业优先（SJF）</li></ol><ul><li>当前到达的运行时间最短的进程。（默认非抢占式）</li><li>抢占式的短作业优先调度算法。</li></ul><p>每当有进程加入就绪队列就需要重新调度。如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则新进程抢占处理机。</p><ol start="3"><li>高响应优先（HRRN)</li></ol><ul><li><p>非抢占式算法</p></li><li><p>每次调度时先计算各个进程的响应比，选择响应比最高的作业/进程为其服务。</p></li><li><p>响应比= （等待时间+要求服务时间）/要求服务时间</p></li></ul><p>tips:这三种算法主要适用于早期的批处理系统。</p><h3 id="2-5-2-新调度算法"><a href="#2-5-2-新调度算法" class="headerlink" title="2.5.2 新调度算法"></a>2.5.2 新调度算法</h3><ol><li>时间片轮转</li></ol><ul><li><p>按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p></li><li><p>分时操作系统</p></li><li><p>如果时间片太大，就会退化为先来先服务算法。</p></li><li><p>时间片太小，进程切换太频繁。</p></li><li><p>切换进程的开销不超过1%才是合适的时间片。</p></li></ul><ol start="2"><li>优先级调度算法</li></ol><ul><li><p>为每一个进程设置优先级，选择优先级最高的进程</p></li><li><p>非抢占式</p></li><li><p>抢占式</p></li></ul><p>当前出现的进程优先级最高，那么优先级高的会抢占处理机。</p><ul><li>操作系统会更偏好I/O型进程</li></ul><ol start="3"><li>多级反馈队列调度算法（折中平衡）</li></ol><ul><li>对其他调度算法的折中权衡</li><li>抢占式算法</li></ul><p><img src="/2021/03/15/operate/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-1615794509250.PNG"></p><ul><li>注意新进程先进入第一级队列。</li><li>优先级高的队列内容会抢占处理机。</li></ul><h3 id="2-6-进程同步和互斥"><a href="#2-6-进程同步和互斥" class="headerlink" title="2.6 进程同步和互斥"></a>2.6 进程同步和互斥</h3><ul><li><p>异步性：各并发执行的进程各自独立、不可预知的速度推进。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5-1615794509250.PNG"></p></li><li><p>进程互斥的四个原则</p></li></ul><p><img src="/2021/03/15/operate/%E4%BA%92%E6%96%A5%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%8E%9F%E5%88%99-1615794509250.PNG"></p><ol start="2"><li><p>软件实现方法</p></li><li><p>单标志法</p></li></ol><p>两个进程在访问完临界区后会把适用临界区的权限转交给另一个进程。每个进程进入临界区的权限只能被另一个进程赋予。</p><ul><li>违背了空闲让进原则</li></ul><ol start="2"><li>双标志先检查</li></ol><p>设置布尔型数组，数组中各个元素来标记各进程想进入临界区的意愿。</p><ul><li>违背忙则等待原则</li></ul><p><img src="/2021/03/15/operate/%E5%8F%8C%E6%A0%87%E5%BF%97%E6%A3%80%E6%9F%A5%E6%B3%95-1615794509250.PNG"></p><ol start="3"><li>双标志后检查</li></ol><p><img src="/2021/03/15/operate/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5-1615794509250.PNG"></p><ul><li>违背了“空闲让进”和“有限等待”</li></ul><ol start="4"><li>Peterson算法</li></ol><ul><li>孔融让梨</li></ul><p><img src="/2021/03/15/operate/peterson%E6%A3%80%E6%9F%A5-1615794509250.PNG"></p><h3 id="2-7-信号量机制"><a href="#2-7-信号量机制" class="headerlink" title="2.7 信号量机制"></a>2.7 信号量机制</h3><ul><li>信号量其实就是一个变量，用来表示系统中某种资源的数量。</li></ul><ol><li>整型信号量</li></ol><ul><li><p>表示系统中某种资源的数量。</p></li><li><p>一直等待</p></li></ul><ol start="2"><li>记录型信号量</li></ol><ul><li>解决忙等问题</li></ul><ul><li>信号量机制在“前操作”之后对相应的同步变量执行V操作。</li><li>在“后操作”之前对相应的同步变量执行P操作。</li></ul><h3 id="2-8-管程"><a href="#2-8-管程" class="headerlink" title="2.8 管程"></a>2.8 管程</h3><p>高级的同步机制。因为PV操作还得程序员自己写很复杂，所以管程相当于把这些操作封装成一个类。</p><p>管程可以直接使用这些定义的函数。</p><p>每次只允许一个进程在管程内执行某个内部过程。 </p><h3 id="2-9-死锁"><a href="#2-9-死锁" class="headerlink" title="2.9 死锁"></a>2.9 死锁</h3><p>进程并发执行，各个进程互相等待对方手里的资源，导致被阻塞都无法向前推进。</p><ul><li>饥饿。由于长期得不到想要的资源，某进程无法向前推进的现象。（操作系统分配资源不合理，比如短进程优先算法）。</li><li>死循环。某进程执行过程中一直跳不出来的现象。</li></ul><ol><li>预防死锁。</li></ol><p>破坏死锁产生的四个必要条件中的一个或几个。</p><ul><li>破坏不可剥夺条件</li></ul><p>a 当某个进程请求新的资源得不到满足时，它必须立即释放所有资源，待以后需要时再重新申请。即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>可能会造成某个进程之前得工作失效。</p><ul><li>请求和保持条件</li></ul><p>解释：进程已经保持了一个资源，但是提出新的资源请求，而该资源又被其他进程所占有，此时请求进程被阻塞，但是又对自己有的资源保持不放。</p><p>a 可以采用静态分配方法，即进程在运行前申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。</p><ul><li>破坏循环等待条件</li></ul><p>a 采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按照编号递增的顺序请求资源。同类资源（即编号相同的资源）一次申请完。（一个进程只有小的资源才能申请大的资源，有大的资源后不会再申请小的资源）。</p><ol start="2"><li>避免死锁。</li></ol><p>用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）。</p><ul><li>银行家算法</li></ul><p>如果分配了资源之后，找不到任何一种安全序列，系统进入了不安全状态。</p><p>a 检查此次申请是否超过了之前声明的最大需求数</p><p>b 检查此时系统剩余的可用资源是否还能满足这次请求</p><p>c 试探分配，更改各数据结构</p><p>d 用安全算法检查此次分配是否会导致系统进入不安全状态</p><ol start="3"><li>死锁的检测和避免。</li></ol><p>允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</p><p><font color="red"> 死锁定理</font>：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁。</p><p>用死锁检测算法简化资源分配图后，还连这边的那些进程就是死锁进程。</p><p>解除死锁的几种方法：</p><ul><li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将它的资源分配给其他死锁进程。但是应该防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能很大。因为有些进程运行了很长时间接近结束。</li><li>进程回退法： 让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统记录进程的历史信息，设置还原点。</li></ul><h3 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h3><h4 id="3-1-地址转换"><a href="#3-1-地址转换" class="headerlink" title="3.1 地址转换"></a>3.1 地址转换</h4><p>三种装入方式：</p><p>a 绝对装入 编译时产生绝对地址 （编译器负责）</p><p>b 可重定位装入 装入时将逻辑地址转换为物理地址（装入器地址）</p><p>c 动态运行时装入 运行时将逻辑地址转换为物理地址，需设置重定位寄存器 （现代操作系统）</p><h4 id="3-2-内存保护"><a href="#3-2-内存保护" class="headerlink" title="3.2 内存保护"></a>3.2 内存保护</h4><p>一个进程只能访问自己的内存空间。</p><p>两种方式：</p><p>a 设置上下限寄存器</p><p>b 利用重定位寄存器、界地址寄存器（限长寄存器）</p><h4 id="4-3-覆盖与交换"><a href="#4-3-覆盖与交换" class="headerlink" title="4.3 覆盖与交换"></a>4.3 覆盖与交换</h4><p>覆盖技术：</p><p><img src="/2021/03/15/operate/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF-1615794509250.PNG"></p><p>交换技术：</p><p>内存紧张，内存中某些进程暂时换出外存。 </p><p>对换区和文件区。</p><h4 id="4-4-连续分配管理方式"><a href="#4-4-连续分配管理方式" class="headerlink" title="4.4 连续分配管理方式"></a>4.4 连续分配管理方式</h4><p>a 固定分区</p><p>b 单一连续分配方式</p><ul><li>分区说明表 </li></ul><p><img src="/2021/03/15/operate/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D-1615794509250.PNG"></p><p>动态分区分配：不会预先划分内存分区，而是在进程装入内存时根据进程的大小动态建立分区。</p><p>使用的数据结构：空闲分区表和空闲分区链。</p><p><font color="red">动态分区分配算法:</font></p><p>概念：在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><ul><li>首次适应算法(First Fit)</li></ul><p>每次都从最低地址开始查找，找到第一个能满足大小的空闲分区。空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。</p><ul><li>最佳适应算法(Best Fit)</li></ul><p>（为分区大小排了序）为各个进程分配的空间必须是连续的一整片区域。因此为了保证“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，优先使用更小的空闲区。</p><ul><li>最坏适应算法(Worst Fit)</li></ul><p>优先使用最大的连续空闲分区。（为了解决最佳适应算法留下太多难以利用的小碎片）。</p><ul><li>邻近适应算法(Next Fit)</li></ul><p>解决首次适应算法中的问题。</p><p>分区以地址递增顺序排列，每次分配内存从上次查找结束的位置开始查找空闲分区链。</p><p><img src="/2021/03/15/operate/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95-1615794509250.PNG"></p><h4 id="4-5非连续分区分配"><a href="#4-5非连续分区分配" class="headerlink" title="4.5非连续分区分配"></a>4.5非连续分区分配</h4><p>页面和页框是一一对应的关系。页号和页内偏移量。</p><p>页号=逻辑地址/页面长度(取除法的整数部分)</p><p>页内偏移量=逻辑地址%页面长度（取除法的余数部分）</p><p><font color="red">地址转换：</font></p><ol><li>算出逻辑地址对应的页号</li><li>该页号对应页面在内存中的起始地址</li><li>算出偏移量</li><li>物理地址=页面始址+页内偏移量</li></ol><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。 页表：页表存储了几个页。每个页叫页表项。</p><p>通常会在系统中设置一个页表寄存器(PTR)，存放<font color="red">页表在内存中的起始地址F和页表长度M</font>。进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放在页表寄存器中。</p><p>每个进程有一个页表，页表项由页号和块号组成。</p><p><img src="/2021/03/15/operate/page-1615794509250.PNG"></p><ul><li></li></ul><p><img src="/2021/03/15/operate/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-1615794509251.PNG"></p><h3 id="4-6-具有快表的地址变换结构"><a href="#4-6-具有快表的地址变换结构" class="headerlink" title="4.6 具有快表的地址变换结构"></a>4.6 具有快表的地址变换结构</h3><ul><li><p>时间局部性</p><p>不久之后某条指令会再次被执行</p></li><li><p>空间局部性</p><p>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能会被访问。（很多数据在内存中都是连续存放的）。</p><p>所以，连续很多次查到的是同一个页表项。</p></li></ul><p>概念： 快表，又称为联想存储器，是一种访问速度比内存快很多的高速缓冲存储器。</p><p><img src="/2021/03/15/operate/%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84-1615794509250.PNG"></p><h3 id="4-7-两级页表"><a href="#4-7-两级页表" class="headerlink" title="4.7 两级页表"></a>4.7 两级页表</h3><ul><li>单级页表问题</li></ul><p>某计算机地址按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小为4KB，页表项长度为4B。</p><p>4KB=$2^{12}$B，因此页内地址要用12位表示，剩余20位表示页号。</p><p>因此，该系统中用户进程最多有$2^{20}$页，一个进程的页表中，最多会有$2^{20}=1M$个页表项，所以一个页表项最大需要$2^{20}*4B=2^{22}B$，共需要$2^{22} / 2^{12} = 2^{10}$个页框存储该页表。</p><ul><li>页表要连续存放，因此当页表很大，需要占用很多连续页框</li><li>没必要让整个页表常驻内存，因为进程在一段时间内只需要访问某几个特定的页面。</li></ul><p>再分配页目录表。</p><ul><li>代价，增加内存访问次数。</li></ul><p><img src="/2021/03/15/operate/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8E%9F%E7%90%86-1615794509251.PNG"></p><h4 id="4-8-基本分段存储管理"><a href="#4-8-基本分段存储管理" class="headerlink" title="4.8 基本分段存储管理"></a>4.8 基本分段存储管理</h4><p>与“分页”最大的区别就是离散分配时所分配地址空间的基本单位不同。 段表寄存器。</p><p>进程的地址空间：按照程序自身的逻辑关系划分为若干段，每个段都有一个段名，每段从0开始编址。</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。</p><p>每个进程建立一张段映射表，简称“段表”。</p><p><img src="/2021/03/15/operate/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-1615794509251.PNG"></p><p>和分页管理的区别：</p><ul><li>分页每个页面长度相同。分段不同</li><li>分页不需要对页内偏移量越界检查，分段必须要。</li></ul><h3 id="4-9-段页式存储管理"><a href="#4-9-段页式存储管理" class="headerlink" title="4.9 段页式存储管理"></a>4.9 段页式存储管理</h3><p><img src="/2021/03/15/operate/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8-1615794509251.PNG"></p><p>一个进程对应一个段表，一个进程可能对应多个页表。</p><p><img src="/2021/03/15/operate/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A81-1615794509251.PNG"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//分段 1 </span><span class="token operator">&lt;</span> <span class="token number">10</span> 给页内偏移量。 <span class="token class-name">A</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5-虚拟内存"><a href="#5-虚拟内存" class="headerlink" title="5. 虚拟内存"></a>5. 虚拟内存</h2><p>虚拟内存的最大容量由计算机的地址结构确定的</p><p>虚拟内存的实际容量 = min(内存和外存容量之和，CPU寻址范围)</p><p>特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调度内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：逻辑上扩充内存容量。看到的容量远远大于实际容量。</li></ul><p>虚拟内存技术需要建立在<font color="red">离散分配</font>的内存管理方式的基础上。</p><h3 id="5-1-请求分页管理方式"><a href="#5-1-请求分页管理方式" class="headerlink" title="5.1 请求分页管理方式"></a>5.1 请求分页管理方式</h3><p><img src="/2021/03/15/operate/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD-1615794509251.PNG"></p><p>与基本分页的区别</p><p><img src="/2021/03/15/operate/%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%8C%BA%E5%88%AB-1615794509251.PNG"></p><p><img src="/2021/03/15/operate/%E6%9F%A5%E6%85%A2%E8%A1%A8%E5%92%8C%E5%BF%AB%E8%A1%A8-1615794509251.PNG"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>页面的换入换出需要磁盘IO，因此次数要尽可能少。</p><ol><li>最佳置换</li></ol><p>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面。根据以后的序列的出现次序定替换哪个算法。</p><ol start="2"><li>先进先出</li></ol><p>每次淘汰的页面是最早进入内存的页面。当为进程分配的物理块数增大时，缺页次数不减反增（belady异常）。</p><ol start="3"><li><p>最近最久未使用 LRU算法 </p></li><li><p>时钟置换算法</p></li></ol><p><img src="/2021/03/15/operate/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-1615794509251.PNG"></p><ol start="5"><li>改进型的时钟置换算法</li></ol><p><img src="/2021/03/15/operate/%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%AE%97%E6%B3%95-1615794509251.PNG"></p><h3 id="5-3-页面分配策略"><a href="#5-3-页面分配策略" class="headerlink" title="5.3 页面分配策略"></a>5.3 页面分配策略</h3><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合。</p><p>驻留集有固定分配和可变分配两种分配方式。区别在运行期间可以适当增加和减少。</p><p>局部置换： 发生缺页时只能选进程自己的物理块进行置换。</p><p>全局置换：将系统保留的空闲物理块分配给缺页进程。</p><p>合起来总共有三种分配策略：</p><ol><li>固定分配局部置换（固定分配没有全局置换）。</li><li>可变分配全局置换。系统有一个空闲物理块队列。</li><li>可变分配局部置换。根据缺页的频率动态地增加和减少进程的物理块。</li></ol><ul><li><p>何时调入页面</p><ol><li><p>预调页策略：根据局部性原理，一次调入若干个相邻页面可能比一次调入一个页面更高效。<font color="red">主要用于进程的首次进入</font></p></li><li><p>请求调页策略：程序在运行期间发现缺页时才将所缺页面调入内存。</p></li></ol></li><li><p>何处调入页面</p><p>外存： 对换区和文件区。</p></li></ul><h2 id="6-文件管理"><a href="#6-文件管理" class="headerlink" title="6. 文件管理"></a>6. 文件管理</h2><ul><li><p>文件如何存储</p></li><li><p>文件内部应该如何组织</p></li><li><p>文件之间应该如何组织</p></li></ul><h3 id="6-1-文件的逻辑结构"><a href="#6-1-文件的逻辑结构" class="headerlink" title="6.1 文件的逻辑结构"></a>6.1 文件的逻辑结构</h3><ul><li><p>无结构文件</p><p>文件内部的数据是一系列二进制文件流或字符流组成。又称为”流式文件“。如windows操作系统的.txt文件。</p></li><li><p>有结构文件</p><ul><li>顺序文件<ul><li>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链实存储。</li></ul></li><li>索引文件</li><li>索引顺序文件</li></ul></li></ul><p>记录式文件，由一组相似的记录组成，比如excel表中的学生信息。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><font color="blue">内存管理</font></h3><p>简述进程切换的流程<br>涉及公司：阿里云实习生</p><p>如果想要从A进程切换到 B 进程，必定要先从用户态切换到内核态，因为这个切换的工作你不能让用户进程去实现，不然当 CPU 在用户进程手上的时候，他可以选择一直执行，不让出 CPU，这肯定是不允许的。所以操作系统需要先挂起正在占用 CPU 的 A 进程，才能切换到 B 进程。</p><p>由于从用户态切换到内核态的时候，CPU 是在用户进程手中，所以这个是通过硬中断来实现的。在从用户态切换到内核态之前需要保存用户进程的上下文，以便下一次执行时可以继续之前的工作。</p><p>这个上下文就是进程执行的环境，包括所有的寄存器变量，进程打开的文件、内存信息等。一个进程的上下文可以分为用户级上下文，寄存器上下文，系统级上下文。用户级上下文存储的是用户进程的内存数据以及堆栈数据等；寄存器上下文是一些通用寄存器；系统级上下文是内核栈、PCB (进程控制块)等。</p><h3 id="进程在地址空间中会划分为哪些区域"><a href="#进程在地址空间中会划分为哪些区域" class="headerlink" title="进程在地址空间中会划分为哪些区域"></a><font color="blue">进程在地址空间中会划分为哪些区域</font></h3><p>涉及公司：阿里云实习生</p><p>这个问题在我之前的工作中其实还是有所涉及的，我来简单讲一下把文件加载到内存中的一个过程，以 Window 平台为例吧，PE 文件我比较熟，在 PE 文件中，有一个叫节的概念，节是PE文件中存放代码和数据的基本单元，用以存储不同类型的数据，比如 data 节、code 节等，一个节的所有原始数据必须加载到连续的内存空间里，这也就造成了在虚拟地址空间中的区块划分。</p><p>在虚拟地址空间中会按照节划分为代码段、数据段、未初始化的数据段以及堆栈这些区块。</p><h3 id="栈与堆有什么区别"><a href="#栈与堆有什么区别" class="headerlink" title="栈与堆有什么区别"></a><font color="blue">栈与堆有什么区别</font></h3><p>涉及公司：阿里云实习生、拼多多实习生</p><p>我们常说堆栈堆栈，其实堆栈是两个不同的概念，最直观的理解，堆是由用户来控制的，我们可以使用 malloc 这种命令来在堆中申请内存，而栈是由操作系统控制的，在栈中存储的是这个进程的局部变量等，比如我们用 malloc 来申请一块内存，内存本身是在堆中开辟的，而指向这块内存的指针存储在栈中。</p><h3 id="操作系统为什么分内核态和用户态，这两者之间如何切换"><a href="#操作系统为什么分内核态和用户态，这两者之间如何切换" class="headerlink" title="操作系统为什么分内核态和用户态，这两者之间如何切换"></a><font color="blue">操作系统为什么分内核态和用户态，这两者之间如何切换</font></h3><p>涉及公司：拼多多实习生</p><p>因为在CPU的指令中，有一些是非常危险的，比如清理内存、设置时钟等，如果所有的程序都能使用，就可能造成系统的崩溃，所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统使用。CPU 的特权级别有四级，从 Ring0 到 Ring3，正常使用时一般只有两级，即用户态的 Ring3 和内核态的 Ring0。Ring3 状态不能访问 Ring0 的地址空间，包括代码和数据。</p><h3 id="用户态切换到内核态的三种方式"><a href="#用户态切换到内核态的三种方式" class="headerlink" title="用户态切换到内核态的三种方式"></a><font color="blue">用户态切换到内核态的三种方式</font></h3><p>系统调用（系统调用是通过软中断实现的）<br>中断（硬）<br>异常</p><h3 id="malloc的实现机制"><a href="#malloc的实现机制" class="headerlink" title="malloc的实现机制"></a><font color="blue">malloc的实现机制</font></h3><p>涉及公司：阿里云实习生</p><p>malloc 本质上是维护了一个内存空闲链表，每次我们调用 malloc 申请空间的时候，链表就会从头开始遍历，来寻找一个合适的空闲内存空间，然后把这个空间给分割开，一步步分配给用户，另一部分继续标注为空闲，而当没有足够大的空闲块时，malloc 就会通过系统调用来申请更多的内存块。而我们调用 free 来释放内存块的时候，该内存块就会回到链表中，并且相邻的内存块会被合并。</p><p>搜索空闲块的算法主要有首次适配、下一次适配、最佳适配，首次适配即第一次找到足够大的内存块就分配，但这样会产生很多的内存碎片，也因此第二次适配被提出来缓解这个问题。另一个极端则是最佳适配，即找到一块刚好大于我们所需内存大小的内存块，这种做法一方面耗时长，另一方面也会产生一些极小的内存碎片。<br>这两种思路可以看出是在性能和空间利用率上寻找一个平衡点，在工程中实际上有很多这种没有完美解决方案，只能寻找平衡的问题。</p><h3 id="虚拟地址怎么映射到物理地址"><a href="#虚拟地址怎么映射到物理地址" class="headerlink" title="虚拟地址怎么映射到物理地址"></a><font color="blue">虚拟地址怎么映射到物理地址</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>虚拟地址的构成为页目录索引 (10位) +页表索引 (10位) +表内偏移 (12位)</p><p>以 win32 系统为例，页目录和页表都为 1024 个，页大小为 4KB，一共是 4G 的虚拟内存空间</p><p>而从虚拟地址映射到物理地址实际上就是通过页目录和页表的索引找到内存页。</p><p>在页表项中有一位标志位，用来标识包含此数据的页是否在物理内存中，如果在的话，就直接做地址映射，否则，抛出缺页中断，操作系统会把次数据页调入内存。</p><h3 id="socket-编程中怎么处理并发请求"><a href="#socket-编程中怎么处理并发请求" class="headerlink" title="socket 编程中怎么处理并发请求"></a><font color="blue">socket 编程中怎么处理并发请求</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>对多线程的处理与单线程不同的位置在于各个不同的进程可能会访问相同的资源，如果是对资源进行修改的话，就需要用到锁</p><h3 id="简述-IO-多路复用"><a href="#简述-IO-多路复用" class="headerlink" title="简述 IO 多路复用"></a><font color="blue">简述 IO 多路复用</font></h3><p>涉及公司：阿里云实习生、腾讯实习生</p><p>Linux的IO访问通常是先将数据拷贝到操作系统的内核缓冲区，然后再从内核缓冲区拷贝到应用程序的地址空间。在这两个阶段中，有不同的 IO 方式，主要分为阻塞 IO、非阻塞 IO、异步 IO 以及 IO 多路复用。</p><p>阻塞 IO 即当数据还未准备好，也就是数据还在操作系统的内核缓存区时，用户进程就会一直阻塞，等待数据从操作系统内核缓冲区拷贝到应用程序的地址空间。阻塞IO在这两个阶段都是阻塞的。</p><p>非阻塞 IO 则是如果数据还没准备好，操作系统会给应用程序返回一个 error，并不阻塞应用程序，而一般应用程序会持续询问内核数据是否准备好，所以从另一个角度来说也是阻塞的。</p><p>而异步 IO 才是真正的不阻塞，当用户程序发起read后，操作系统会立即进行回复，这样用户程序就可以去做其他事情，当数据被拷贝到用户程序的地中空间后，操作系统会给用户程序发一个信号，而用户程序可以采用回调函数的方式对这个信号进行响应。</p><p>IO 多路复用则是允许一个程序同时等待多个文件描述符，当任意一个文件描述符就绪，select 函数就会返回，当然 IO 多路复用在本质上还术语阻塞IO，只不过可以同时进行多个 IO 操作。</p><p>Linux 的 IO 多路复用机制中有 select、poll、epoll 三种，<br>select 和 poll 的时间复杂度都是 O(n),因为他们都是在对IO列表进行轮询，不同点在于 select 能监视的文件描述符有上限，一般为 1024，当然这个是在 Linux 内核中进行的宏定义，是可以修改的，而 poll 是基于链表来存储的，所以没有这个上限。<br>而 epoll 是基于事件驱动的，所以不需要轮询，epoll 会把事件和每一个IO流对应起来。并且 epoll 是通过一块共享内存来实现内核空间和用户空间的通信的，比起 select 和 poll 的大量数据拷贝效率更高。<br>不过 lect 的优点在于兼容不同的操作系统，而 poll 和 epoll 都只能在 linux 上使用。</p><p><font color="blue">简述进程通信的各种方法</font><br>涉及公司：腾讯实习生</p><p>进程间通信的方式通常分为管道、系统 IPC、套接字三种，其中管道有无名管道、命名管道，系统 IPC 有消息队列、信号、共享内存</p><p>无名管道的本质是在内核缓冲区的环形队列，每次读取数据后缓冲区都会移动，并且无名管道只能在有亲缘关系的进程间使用<br>命名管道则以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道<br>消息队列是存放在内核中的消息链表，具有特定的格式，支持多种数据类型，且允许多个进程进行读写<br>信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，并且信号可以在用户空间进程和内核之间直接交互<br>共享内存顾名思义就是两个进行对同一块内存进行读写，是最快的 IPC 形式，但不适合大量的数据传输<br>Socket 是对 TCP/IP 协议族的封装，不仅可以用于本机上的进程间通信，更多的被用于网络通信中<br>进程线程管理<br>进程的互斥与同步<br>在操作系统中，进程是占有资源的最小单位，对于那种只能同时被一个进程持有的资源我们称为临界资源，对于临界资源的访问，必须是互斥的。（对于；临界资源的访问过程分为：进入区、临界区、退出区、剩余区）</p><p>而进程之间访问临界资源时可以构成同步与互斥两种关系，同步即两个进程的资源访问必须是先后关系，比如经典的生产者消费者问题，读者写着问题。而互斥则是两种在进行资源抢到，比如购票问题。</p><p>通常在软件层面可以使用替换算法来实现，即每个进程持有一个标志，每次当使用资源时则将自己的标志与资源的标志互换，如果在互换的过程中发现自己获得的标志是正在使用的状态，则在此循环等待。这种方法的缺点在于每个进程都需要进行循环等待，比较低效。所以一般是通过硬件层面的信号量即PV操作来实现进程的临界资源管理。</p><p>死锁的解决方法<br>涉及公司：阿里云实习生</p><p>死锁的产生是在这样一种环境中：比如我们有两个进程AB，他们都需要资源1和资源2，当进程A持有资源1，进线程B持有资源2的时候，他们都需要对方手上的进程，而一般操作系统又不允许抢占，这个时候就发生了死锁。</p><p>从这个例子中其实可以总结出死锁的几个必要条件：</p><p>1.一个资源只能被一个进程所占有，不能共享<br>2.一个线程请求资源失败时，它会等待而不是释放<br>3.一个线程在释放资源之前其他进程不能抢夺资源<br>4.循环等待<br>从死锁产生的原因未明可以设计一些方法去避免死锁的发生</p><p>1.静态分配资源，一开始就把一个进程所需的全部资源都分配给它，但这样会降低资源的使用效率<br>2.允许抢占，需要设置进程的不同优先级，高优先级的进程可以抢占低优先级的进程的资源<br>3.把资源进行编号，申请资源必须按照资源的编号顺序来申请<br>如果死锁已经发生了，就需要去解开死锁，其本质思想就是分配资源打破循环等待</p><p>1.可以运行抢占，从一个或多个进程中抢出资源来给其他进程<br>2.也可以终止一些进程，来达到释放资源的目的<br>进程调度算法<br>先来先服务调度算法<br>对长作业比较有利，但对短作业不利<br>时间片轮转调度法<br>每个进程只能运行一个时间片<br>时间片的大小对系统性能的影响很大，时间片过大就和先来先服务算法一样，时间片过小会导致进行切换开销大<br>短作业优先调度算法<br>对长作业不利，不能保证紧迫性作业（进程）被及时处理<br>最短剩余时间优先<br>允许抢占，总是选择预期剩余时间最短的进程<br>高响应比优先调度算法<br>R=(w+s)/s （R 为响应比，w 为等待处理的时间，s 为预计的服务时间），选择 R 最大的进行执行<br>优先级调度算法<br>进程优先级可以分为静态优先级和动态优先级<br>多级反馈队列调度算法<br>分为多个队列，每个队列中按时间片轮转调度算法来进行进程调度，每一级的队列时间片大小也不一样，如果进行在第一个队列的时间片内没有完成，就会进入第二个队列，以此类推，只有当第一个队列为空才执行第二个队列的进行<br>短作业有限且长作业不会太长时间不被处理<br>磁盘调度算法<br>先来先服务算法（FCFS）<br>根据进程请求访问磁盘的先后次序进行调度<br>优点是公平、简单<br>缺点是吞吐量低，寻道时间长<br>最短寻道时间优先算法（SSTF）<br>访问与当前磁头所在的磁道距离最近的磁道<br>优点是可以得到比较好的吞吐量<br>缺点是对内外边缘磁道的请求将会被无限延迟<br>扫描算法（SCAN）电梯调度算法<br>优先考虑磁头当前的移动方向，再考虑欲访问的磁道与当前磁道的距离<br>优点是避免了饥饿现象的出现<br>缺点是两侧磁道被访问的频率仍低于中间磁道<br>循环扫描算法（CSCAN）<br>在SCAN算法的基础上，磁头只单向移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道<br>优点是访问请求均匀分布<br>页面调度算法<br>先进先出调度算法（FIFO，First In First Out）<br>最近最少使用算法(LFU, Least Frequently Used)<br>最近最久未使用算法（LRU，Least Recently Used）<br>时钟置换算法——为每一页设置访问位和修改位，将内存中所有页面通过连接指针接成循环队列，当页面被访问时访问位置 1，被修改则修改位置 1，每次淘汰时，从指针当前位置开始循环遍历，第一次寻找访问位和修改位都为0的页面，如果没有则将扫描过的节点访问位为 1 的置为 0，找到第一个访问位为 0 的将其淘汰。这个算法的原则就的在LRU的基础上偏向于淘汰未被修改的页面。<br>最佳置换算法——理想算法，找一个未来最长时间才会被访问的页面进行淘汰。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>UNIX中进程将内存划分为三部分:<code>text segment 文本区</code>、<code>data segment 数据区</code>、<code>stack segment 栈区域</code>（私有变量）。数据向上增长，堆栈向下增长。</p><p><img src="/2021/03/15/operate/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1615794509251.PNG"></p><p><strong>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</strong>，即CPU分配时间的单位 。</p><p>——————————————</p><h1 id="operate2"><a href="#operate2" class="headerlink" title="operate2"></a>operate2</h1><h2 id="操作系统的四大特性"><a href="#操作系统的四大特性" class="headerlink" title="操作系统的四大特性"></a>操作系统的四大特性</h2><ul><li>并发：同一段时间内多个程序执行</li><li>共享：系统中的资源可以被内存中多个并发执行的进线程共同使用</li><li>虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个</li><li>异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进</li></ul><h2 id="操作系统基本功能"><a href="#操作系统基本功能" class="headerlink" title="操作系统基本功能"></a>操作系统基本功能</h2><ul><li><p>进程管理</p><p>：</p><ul><li>进程控制、进程同步、进程通信、死锁处理、处理机调度等</li></ul></li><li><p>内存管理</p><p>：</p><ul><li>内存分配、地址映射、内存保护与共享、虚拟内存等</li></ul></li><li><p>文件管理</p><p>：</p><ul><li>文件存储空间的管理、目录管理、文件读写管理和保护等</li></ul></li><li><p>设备管理</p><p>：</p><ul><li>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等</li></ul></li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul><li>CPU（中央处理器）</li><li>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础</li><li><strong>资源分配的最小单位是进程，而CPU调度的最小单位是时间片</strong></li><li>系统为进程分配资源，不对线程分配资源</li></ul><h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><ul><li>高级调度（作业调度）：<ul><li>多道批处理操作系统中，从输入系统的一批作业中按照预定的调度策略挑选若干作业进入内存，为其分配资源并创建对应的作业用户进程</li><li>作业是任务实体，进程是完成任务的执行实体。<strong>作业的概念多用于批处理操作系统，而进程用于各种多道程序设计系统</strong></li></ul></li><li>中级调度<ul><li>根据内存资源情况决定内存中所能容纳的进程数目，并完成外存和内存中的进程对换工作（挂起）。起到短期均衡系统负载的作用</li></ul></li><li>低级调度（进程调度/线程调度）<ul><li><strong>根据某种原则决定就绪队列中哪个进程/线程获得处理器，并将处理器出让给它使用</strong></li></ul></li></ul><h3 id="Q：某一进程CPU使用率-50-是什么意思？"><a href="#Q：某一进程CPU使用率-50-是什么意思？" class="headerlink" title="Q：某一进程CPU使用率 50% 是什么意思？"></a>Q：某一进程CPU使用率 50% 是什么意思？</h3><ul><li>CPU使用率是来描述CPU的使用情况的，表明了一段时间内CPU被占用的情况。使用率越高，说明你的机器在这个时间上运行了很多程序，反之较少。使用率的高低与你的CPU强弱有直接关系。</li><li>CPU的占用率，一般指的就是对时间片的占用情况，CPU：50% 说明 CPU 有一半的时间在运行，一半的时间在休息（100MS 中50MS被进程占用，50MS处于空闲状态）</li></ul><h3 id="Q：如何让CPU使用率固定在50-【仅限于单核CPU】"><a href="#Q：如何让CPU使用率固定在50-【仅限于单核CPU】" class="headerlink" title="Q：如何让CPU使用率固定在50%【仅限于单核CPU】"></a>Q：如何让CPU使用率固定在50%【仅限于单核CPU】</h3><ul><li><p>CPU的占有率是由进程的忙和空闲来决定的，即 rate=(busy_time)/(busy_time+idle_time);</p></li><li><p>让CPU使用率固定在50%，只要让计算机有一半的时间在运行，一半的时间在休息就可以了。</p></li><li><p>busy可以用循环（这个循环用空循环，以便好控制），idle可以用sleep</p></li><li><p>比如先让任务管理器的cpu使用率始终保持在50%左右，那么在一个主循环中，让空循环和sleep运行同样的一小段时间。sleep的时间好搞，空循环的怎么办呢？可以在运行的时候设定空循环的运行时间</p><p><code>public</code> <code>static</code> <code>void</code> <code>main(String args[]) ``throws</code> <code>InterruptedException{``   ``int</code> <code>busyTime = ``10``;``   ``int</code> <code>idleTime = busyTime;``   ``//设定空循环的运行时间``   ``while``(``true``){``     ``long</code> <code>startTime = System.currentTimeMillis();``     ``//busy loop:``     ``while``((System.currentTimeMillis()-startTime)&lt;=busyTime)``       ``;``     ``Thread.sleep(idleTime);``   ``}`` ``}</code></p></li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器：</p><ul><li>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失</li><li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据不会丢失</li><li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个读写速度比内存更快的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在Cache中没有，CPU会再去读取内存中的数据.</li></ul><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><ul><li><p>操作系统的内存管理主要负责<strong>内存的分配与回收</strong>（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是<strong>将逻辑地址转换成相应的物理地址</strong>等功能也是操作系统内存管理做的事情</p></li><li><p>连续分配管理方式</p><p>：连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如</p><p>块式管理</p><ul><li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片</li></ul></li><li><p>非连续分配管理方式</p><p>：非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中</p><ul><li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。<strong>页式管理通过页表对应逻辑地址和物理地址</strong></li><li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是<strong>段是有实际意义的，每个段定义了一组逻辑信息</strong>，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 <strong>段式管理通过段表对应逻辑地址和物理地址</strong></li><li><strong>段页式管理机制</strong> ：段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是<strong>把主存先分成若干段，每个段又分成若干页</strong>，也就是说<strong>段页式管理机制中段与段之间以及段的内部的都是离散的</strong>。</li></ul></li></ul><h4 id="分页和分段共同点和区别"><a href="#分页和分段共同点和区别" class="headerlink" title="分页和分段共同点和区别"></a>分页和分段共同点和区别</h4><ul><li><p>共同点</p><p>：</p><ol><li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片</li><li><strong>页和段都是离散存储的</strong>，所以两者都是离散分配内存的方式。但是，<strong>每个页和段中的内存是连续的</strong></li></ol></li><li><p>分段和分页的不同</p><p>：</p><ol><li><strong>目的不同</strong>：<strong>分页是由于系统管理的需要</strong>而不是用户的需要，它是信息的物理单位；<strong>分段的目的是为了能更好地满足用户的需要</strong>，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</li><li><strong>大小</strong>不同：<strong>页的大小固定且由系统决定</strong>；而<strong>段的长度却不固定，由其所完成的功能决定</strong>；</li><li>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</li><li><strong>内存碎片</strong>：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</li></ol></li></ul><h4 id="基本分页储存管理方式"><a href="#基本分页储存管理方式" class="headerlink" title="基本分页储存管理方式"></a>基本分页储存管理方式</h4><ul><li>在分页内存管理中，很重要的两点是：<strong>1. 虚拟地址到物理地址的转换要快【快表】；2. 解决虚拟地址空间大，页表也会很大的问题【多级分页】</strong></li><li>因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个<strong>页表来记录逻辑地址和实际存储地址之间的映射关系</strong>，<strong>以实现从页号到物理块号的映射</strong></li><li>由于页表也是存储在内存中的，因此访问分页系统中内存数据需要两次的内存访问【一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据】</li><li><strong>为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制</strong>，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中</li><li><strong>在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间</strong>。为了解决这个问题，可以采用<strong>两级页表或者多级页表的方法</strong></li><li>其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据</li></ul><h4 id="基本分段储存管理方式"><a href="#基本分段储存管理方式" class="headerlink" title="基本分段储存管理方式"></a>基本分段储存管理方式</h4><ul><li>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求【比如数据共享，数据保护，动态链接等】</li><li><strong>分段内存管理当中，地址是二维的，一维是段号，一维是段内地址</strong>；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</li><li>由于分段管理中，<strong>每个段内部是连续内存分配，但是段和段之间是离散分配的</strong>，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是<strong>段表机制</strong>。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。</li><li>访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E8%81%94%E6%83%B3">联想</a>寄存器。</li></ul><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><ul><li><p><strong>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享</strong></p></li><li><p>段页式管理就是将程序分为多个逻辑段，在每个段里面又进行分页，即将分段和分页组合起来使用。</p></li><li><p>为了实现地址变换，系统为每个进程建立一张段表，而每个分段有一张页表（在一个进程中，段表只有一个，而页表可能有多个）</p></li><li><p>在进行地址变换时，<strong>首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址</strong>。如图所示，<strong>进行一次访问实际需要至少三次访问主存</strong>，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p></li><li><p>三次内存访问</p><p>：</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li></ul><h4 id="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"><a href="#Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数" class="headerlink" title="Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数"></a>Q：页式存储，段式存储，段页式存储，引入快表，访问内存次数</h4><ul><li><p>页式存储（2次）</p><ol><li>访问内存中的页表，利用逻辑地址中的页号查找到页帧号，与逻辑地址中的页内偏移拼接形成物理地址；</li><li>得到物理地址后，再一次访问内存，存取指令或者数据。</li></ol></li><li><p><strong>段式存储（2次）</strong>：同页式存储</p></li><li><p>段页式存储（3次）</p><ol><li>访问内存中的段表查到页表的起始地址</li><li>访问内存中的页表找到页帧号，形成物理地址</li><li>得到物理地址后，再一次访问内存，存取指令或者数据</li></ol></li><li><p><strong>多级页表</strong>：若页表划分为N级，则需要访问内存N+1次。若系统有快表，则在快表命中时，只需访问1次内存即可</p></li><li><p>引入快表</p><p>：</p><ul><li>因为把页表放在内存中，至少需要访问两次内存才能存取一条指令或者数据（一次得到物理地址地址，一次存取），比较慢；因此在地址变换机构中增设了一个具有并行查找能力的高速缓冲寄存器—— 快表（全局只有一个，不在内存中！！！），用来存放当前访问的若干页表项（比较小，只能存放部分页表项）</li><li><strong>若快表命中</strong>，则可直接得到页帧号，与页内偏移拼接成物理地址后访问内存，进行指令或者数据的存取。（<strong>只需访问一次内存</strong>）</li><li><strong>若快表不命中</strong>，则需去内存中访问页表，形成物理地址后，再一次访问内存进行指令或者数据的存取。（需要访问两次内存）</li></ul></li></ul><h3 id="物理内存-amp-虚拟内存"><a href="#物理内存-amp-虚拟内存" class="headerlink" title="物理内存 &amp; 虚拟内存"></a>物理内存 &amp; 虚拟内存</h3><ul><li><p><strong>正在运行的一个进程，他所需的内存是有可能大于内存条容量之和</strong>的，比如你的<strong>内存条是256M，你的程序却要创建一个2G的数据区</strong>，那么不是所有数据都能一起加载到内存（物理内存）中，势必有一部分数据要放到其他介质中（比如硬盘），待进程需要访问那部分数据时，在通过调度进入物理内存。所以，虚拟内存是进程运行时所有内存空间的总和，并且可能有一部分不在物理内存中，而物理内存就是我们平时所了解的内存条。有的地方呢，也叫这个虚拟内存为内存交换区。</p></li><li><p><strong>虚拟内存的作用就是，将需要大内存的分块，一块一块的递给物理内存</strong>。换言之，<strong>虚拟内存是通过页面调度实现的</strong></p></li><li><p>虚拟内存的目的是为了</p><p>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</p><p>。</p><ul><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</li><li>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</li><li>当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li></ul></li></ul><h4 id="进程的内存分配-amp-内存访问"><a href="#进程的内存分配-amp-内存访问" class="headerlink" title="进程的内存分配 &amp; 内存访问"></a>进程的内存分配 &amp; 内存访问</h4><ul><li><strong>进程是在虚拟内存中的</strong>，每个进程运行时都会得到4G的虚拟内存，得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换</li><li>进程内存访问<ol><li>每次要访问地址空间上的某一个地址，都需要<strong>把虚拟地址翻译为实际物理内存地址</strong></li><li><strong>所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上</strong></li><li>进程需要知道<strong>哪些地址空间上的数据在物理内存上</strong>，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过<strong>页表</strong>来记录</li><li>页表的每一个表项分两部分，第一部分记录此页是否在物理内存上（页面号），第二部分记录物理内存页的地址（偏移量）</li><li><strong>当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常</strong></li><li><strong>缺页异常</strong>的处理过程，<strong>操作系统立即阻塞该进程，并将硬盘里对应的页换入内存</strong>，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统选择的<strong>页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></strong></li></ol></li></ul><h4 id="虚拟内存置换算法"><a href="#虚拟内存置换算法" class="headerlink" title="虚拟内存置换算法"></a>虚拟内存置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></h4><ul><li><p>最佳(Optimal)置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>一种理论<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>，无法实现，置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。</li></ul></li><li><p>先进先出(FIFO)页面置换<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>每次淘汰最早调入的页面。</li></ul></li><li><p>最近最久未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>LRU</p><p>：</p><ul><li><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</li></ul></li><li><p>时钟<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>clock</p><p>(也被称为是</p><p>最近未使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>NRU</p><p>)：</p><ul><li>页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。</li></ul></li><li><p>改进型Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li>在Clock<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>的基础上添加一个修改位，替换时根据访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。</li></ul></li><li><p>最少使用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>LFU</p><p>：</p><ul><li>设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。</li></ul></li></ul><h3 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态&amp;内核态"></a>用户态&amp;内核态</h3><ul><li><p>用户态：用户态运行的进程可以直接读取用户程序的数据</p></li><li><p>内核态：内核态运行的进程或程序几乎可以访问计算机的任何资源，不受限制</p></li><li><p>两者最重要的差别就在于<strong>特权级的不同</strong>，即权力的不同。<strong>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序</strong>。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态</p></li><li><p>用户态切换到内核态的3种方式</p><p>：</p><ol><li><strong>系统调用</strong>：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现</li><li><strong>异常</strong>：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</li><li><strong>外围设备的中断</strong>：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。（比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。）</li></ol></li></ul><h3 id="系统调度"><a href="#系统调度" class="headerlink" title="系统调度"></a>系统调度</h3><ul><li><p>Q：什么是系统调用</p><p>？</p><ul><li>我们运行的程序基本都是运行在用户态，如果需要调用操作系统提供的系统态级别的子功能，就需要系统调用。也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如<strong>文件管理、进程控制、内存管理</strong>等)，都必须<strong>通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</strong></li></ul></li><li><p>常见的系统调用：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能</li><li>文件管理。完成文件的读、写、创建及删除等功能</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能</li><li>进程通信。完成进程之间的消息传递或信号传递等功能</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能</li></ul></li></ul><h3 id="Q：Debug时看到的是物理内存还是虚拟内存-？"><a href="#Q：Debug时看到的是物理内存还是虚拟内存-？" class="headerlink" title="Q：Debug时看到的是物理内存还是虚拟内存 ？"></a>Q：Debug时看到的是物理内存还是虚拟内存 ？</h3><ul><li>虚拟内存，通常，<strong>在用户模式下，我们用调试器看到的内存地址都是虚拟内存</strong>。</li></ul><h2 id="操作系统是如何实现锁的？"><a href="#操作系统是如何实现锁的？" class="headerlink" title="操作系统是如何实现锁的？"></a>操作系统是如何实现锁的？</h2><ul><li><p>首先要搞清楚一个概念，<strong>在硬件层面，CPU提供了原子操作、关中断、锁内存总线的机制</strong>；<strong>OS基于这几个CPU硬件机制，就能够实现锁</strong>；再<strong>基于锁，就能够实现各种各样的同步机制</strong>（信号量、消息、Barrier等）</p></li><li><p>在多线程编程中，为了保证数据操作的一致性，操作系统引入了锁机制，用于保证临界区代码的安全。通过锁机制，能够保证在多核多线程环境中，在某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。</p></li><li><p><strong>锁机制的一个特点是它的同步原语都是原子操作</strong></p></li><li><p>那么操作系统是如何保证这些同步原语的原子性呢？</p><ul><li>操作系统之所以能构建锁之类的同步原语，是因为硬件已经为我们提供了一些原子操作，例如：</li></ul><ol><li>中断禁止和启用（interrupt enable/disable）</li><li>内存加载和存入（load/store）测试与设置（test and set）指令</li></ol></li><li><p>禁止中断这个操作是一个硬件步骤，中间无法插入别的操作。同样，中断启用，测试与设置均为一个硬件步骤的指令。在这些硬件原子操作之上，我们便可以构建软件原子操作：锁，睡觉与叫醒，信号量等。</p></li></ul><h3 id="操作系统使用锁的原语操作"><a href="#操作系统使用锁的原语操作" class="headerlink" title="操作系统使用锁的原语操作"></a>操作系统使用锁的原语操作</h3><ul><li><p>可以使用<strong>中断禁止，测试与设置</strong>两种<strong>硬件原语来实现软件的锁原语</strong>。这两种方式比较起来，显然<strong>测试与设置</strong>更加简单，也因此使用的<strong>更为普遍</strong>。此外，<strong>test and set还有一个优点，就是可以在多CPU环境下工作，而中断启用和禁止则不能</strong></p></li><li><p>使用中断启用与禁止来实现锁</p><p>：</p><ul><li>要防止一段代码在执行过程中被别的进程插入，就要考虑在一个单处理器上，一个线程在执行途中被切换的途径。我们知道，要切换进程，必须要发生上下文切换，上下文切换只有两种可能：</li></ul><ol><li><strong>一个线程自愿放弃CPU而将控制权交给操作系统调度器</strong>（<strong>通过yield之类的操作系统调用来实现</strong>）；</li><li><strong>一个线程被强制放弃CPU而失去控制权（通过中断来实现）</strong></li></ol><ul><li>原语执行过程中，我们不会自动放弃CPU控制权，因此<strong>要防止进程切换，就要在原语执行过程中不能发生中断。所以采用禁止中断</strong>，且不自动调用让出CPU的系统调用，就可以防止进程切换，将一组操作变为原子操作。</li><li>中断禁止：就是禁止打断，<strong>使用可以将一系列操作变为原子操作</strong></li><li>中断启用：就是从这里开始，可以被打断，允许操作系统进行调度</li><li>缺点：使用中断实现锁，繁忙等待，不可重入</li></ul></li><li><p>使用测试与设置指令来实现锁</p><ul><li>测试与设置（test &amp; set）指令：以不可分割的方式执行如下两个步骤：</li></ul><ol><li>设置操作：将1写入指定内存单元；</li><li>读取操作：返回指定内存单元里原来的值（写入1之前的值）</li></ol><ul><li>缺点：繁忙等待，不可重入</li></ul></li></ul><h3 id="操作系统中的锁机制"><a href="#操作系统中的锁机制" class="headerlink" title="操作系统中的锁机制"></a>操作系统中的锁机制</h3><ul><li><p><strong>互斥锁</strong>：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。只有取得互斥锁的进程才能进入临界区，无论读写，当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p></li><li><p>读写锁</p><p>：rwlock，分为读锁和写锁。读写锁要根据进程进入临界区的具体行为（读，写）来决定锁的占用情况。这样锁的状态就有三种了：读加锁、写加锁、无锁。</p><ol><li>无锁。读/写进程都可以进入；</li><li>读锁。读进程可以进入。写进程不可以进入；</li><li>写锁。读/写进程都不可以进入</li></ol></li><li><p>自旋锁</p><p>：spinlock，自旋锁是指在进程试图取得锁失败的时候选择忙等待而不是阻塞自己。</p><ul><li>选择忙等待的优点在于如果该进程在其自身的CPU时间片内拿到锁（说明锁占用时间都比较短），则相比阻塞少了上下文切换</li><li>注意这里还有一个隐藏条件：<strong>多处理器</strong>。因为单个处理器的情况下，由于当前自旋进程占用着CPU，持有锁的进程只有等待自旋进程耗尽CPU时间才有机会执行，这样CPU就空转了</li></ul></li><li><p>RCU</p><p>：read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，修改完成后，再将老数据update成新的数据。【有点像 copy-on-write】</p><ul><li>使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就<strong>不用考虑死锁问题</strong>了。</li><li>对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。</li><li>在有大量读操作，少量写操作的情况下效率非常高。【读多写少】</li></ul></li></ul><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li>早期计算机各个程序只能串行执行、系统资源利用低。为了解决上述问题，操作系统引入了中断机制，实现了<strong>多道程序的并发执行</strong>，提高了系统资源的利用率。</li><li><strong>中断是多程序并发执行的前提条件</strong></li></ul><ol><li>当一个时间片运行完后，CPU会接收到计时部件（操作系统内核的时钟管理部件）<strong>发出的中断信号，CPU立即进入核心态</strong>，把CPU的使用权限交还给操作系统</li><li>当中断发生后，当前运行的进程暂停运行，操作系统内核对中断进程处理，切换进程（根据进程调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>），在完成切换进程的一系列工作后，操作系统又会将CPU的使用权交还给用户进程</li><li>切换到的进程2拿到CPU执行权就会在用户态下执行</li></ol><ul><li>中断的<strong>本质</strong>：<strong>发生中断就意味着需要操作系统介入</strong>，开展管理工作</li></ul><h3 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h3><ol><li>执行完每个指令后，CPU都要检查当前是否有外部中断信号</li><li><strong>如果检测到外部中断信号，则需要保护被中断进程的CPU环境</strong>（<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E5%A6%82%E7%A8%8B">如程</a>序状态字PSW、<strong>程序计数器、各种通用寄存器</strong>）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复进程的CPU环境并退出中断，返回原进程继续往下执行</li></ol><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><ul><li>中断可以分为：内中断和外中断</li><li>内中断：内中断的信号来源于CPU内部、与当前执行的指令有关。如整数除0</li><li>外中断：外中断的信号来源于CPU外部、与当前执行的指令无关。如用户强制结束一个进程、IO设备完成操作发生的中断信号</li></ul><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><ul><li>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</li><li>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：<ol><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ol></li><li>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：<ul><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回的是，执行产生中断的一条指令，而一般的中断返回的是，执行下一条指令</li></ul></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="Q：操作系统临界资源的访问"><a href="#Q：操作系统临界资源的访问" class="headerlink" title="Q：操作系统临界资源的访问"></a>Q：操作系统临界资源的访问</h3><ul><li><strong>临界资源</strong>：<strong>一段时间内只允许一个线程访问的资源就称为临界资源或独占资源</strong></li><li><strong>临界区</strong>：对临界资源进行访问的那段代码称为临界区，通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</li><li><strong>多线程同步互斥的常见方法</strong>：</li></ul><ol><li><p>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 <strong>Java 中的 synchronized 关键词和各种 Lock 都是这种机制，本质是一个计数器</strong></p></li><li><p>信号量PV(Semphares)</p><p>：它</p><p>允许同一时刻多个线程来访问同一资源</p><p>，但是需要控制同一时刻访问此资源的最大线程数量【用来实现生产者消费者模型】</p><ul><li>信号量的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程，信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。</li><li>注意，<strong>信号量的值仅能由PV操作来改变</strong></li><li>p操作（wait）：申请一个单位资源，进程进入；v操作（signal）：释放一个单位资源，进程出来</li><li>PV操作的含义：<strong>PV操作由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作</strong></li></ul></li><li><p><strong>事件event</strong>：通过通知操作的方式来保持多线程同步，还可以方便实现多线程优先级的比较操作，Wait/Notify</p></li></ol><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li><p><strong>synchronized同步</strong>：本质上就是 “共享内存” 式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</p></li><li><p>while轮询的方式</p><p>：</p><ul><li>在这种方式下，ThreadA 不断地改变条件，ThreadB 不停地通过 while 语句检测这个条件比如说互斥量为0 是否成立 ，从而实现了线程间的通信。但是这种方式会浪费 CPU 资源。</li></ul></li><li><p>wait/notify机制</p><p>：</p><ul><li>当条件未满足时，ThreadA 调用 wait() 放弃 CPU，并进入阻塞状态。（不像 while 轮询那样占用 CPU）</li><li>当条件满足时，ThreadB 调用 notify() 通知线程 A，所谓通知线程 A，就是唤醒线程 A，并让它进入可运行状态</li></ul></li><li><p><strong>管道通信</strong>：java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p></li></ul><h2 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h2><ul><li>进程控制块 (Process Control Block，PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li><p><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态</p></li><li><p>**就绪状态(ready)**：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行</p></li><li><p><strong>运行状态(running)</strong> ：进程正在处理器上上运行（单核 CPU 下任意时刻只有一个进程处于运行状态）</p></li><li><p><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行</p></li><li><p><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行</p></li><li><p><strong>只有就绪态和运行态可以相互转换，其它的都是单向转换</strong>。<strong>就绪状态</strong>的进程通过<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a><strong>从而</strong>获得 CPU 时间，转为运行状态</strong>；而<strong>运行状态</strong>的进程，<strong>在分配给它的 CPU 时间片用完之后就会转为就绪状态</strong>，等待下一次调度。</p></li><li><p><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来</strong>，<strong>但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态</strong></p></li><li><p>挂起</p><p>（换到外存）:</p><ul><li>挂起就绪：是指进程被对换到辅存时的就绪状态，是不能被直接调度的状态，只有当主存中没有活跃就绪态进程，或者是挂起就绪态进程具有更高的优先级，系统将把挂起就绪态进程调回主存并转换为活跃就绪。</li></ul></li></ul><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ol><li><p>临界区：对临界资源进行访问的那段代码称为临界区。</p></li><li><p>同步与互斥：</p><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul></li><li><p>信号量</p><p>：信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li><li>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候<strong>屏蔽中断</strong></li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量</strong>（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li><p>管程</p><p>：管程在功能上和信号量及PV操作类似，属于一种进程同步互斥工具，但是具有与信号量及PV操作不同的属性。</p><p>管程把控制的代码独立出来，封装了同步操作，对进程隐蔽了同步细节</p><p>，简化了同步功能的调用界面。用户编写并发程序如同编写顺序(串行)程序。</p><ul><li>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了<strong>条件变量</strong>以及相关的操作：<strong>wait() 和 signal() 来实现同步操作</strong>。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li></ul></li></ol><h4 id="进程同步和进程通信的区别"><a href="#进程同步和进程通信的区别" class="headerlink" title="进程同步和进程通信的区别"></a>进程同步和进程通信的区别</h4><ul><li>进程同步：控制多个进程按一定顺序执行</li><li>进程通信：进程间传输信息</li><li>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息</li></ul><h3 id="Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？"><a href="#Q：常见的进程间的通信方式（IPC，Inter-Process-Communication）？" class="headerlink" title="Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？"></a>Q：常见的进程间的通信方式（IPC，Inter-Process Communication）？</h3><ul><li><p>管道</p><p>：</p><p>管道可用于具有亲缘关系的父子进程间的通信</p><p>。linux 系统操作执行命令时，将一个程序的输出交给另一个程序进行处理。一个进程往管道输入数据，则会阻塞等待别的进程从管道读取数据。管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。</p><ul><li>它具有以下限制：1. <strong>只支持半双工通信（单向交替传输）</strong>；2. <strong>只能在父子进程或者兄弟进程中使用</strong></li></ul></li><li><p><strong>命名管道（FIFO）</strong>：克服了管道没有名字的限制，<strong>具有管道所具有的功能外，还允许无亲缘关系进程间的通信</strong>，去除了管道只能在父子进程中使用的限制</p></li><li><p><strong>信号（singal）</strong>：<strong>信号是在软件层次上对中断机制的一种模拟</strong>，一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。</p></li><li><p>消息队列</p><p>：消息队列提供了从一个进程向另一个进程发送一个数据块的方法。</p><ul><li><strong>相比于命名管道的优点</strong>：<strong>消息队列可以独立于读写进程存在</strong>，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<strong>避免了 FIFO 的同步阻塞问题</strong>，不需要进程自己提供同步方法；读进程可以<strong>根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li><li><strong>缺点</strong>：使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间</li></ul></li><li><p>共享内存</p><p>：共享内存可以很好解决拷贝消耗的时间。</p><ul><li><strong>允许多个进程共享一个给定的存储区，不同进程可以及时看到对方进程中对共享内存中数据变更</strong>。因为数据不需要在进程之间复制，所以这是<strong>最快的一种 IPC</strong></li><li>共享内存需要依靠某种同步操作，如互斥锁和信号量等，<strong>需要使用信号量用来同步对共享存储的访问</strong>。</li><li>系统加载一个进程的时候，分配给进程的内存并不是实际物理内存，而是虚拟内存空间。可以让<strong>两个进程各自拿出一块虚拟地址空间，然后映射到相同的物理内存中</strong>，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了内存共享机制了</li></ul></li><li><p>信号量（mutex）</p><p>：为了避免共享内存多进程竞争内存的问题（线程安全），使用信号量。</p><ul><li>信号量的<strong>本质就是一个计数器</strong>，用来<strong>实现进程之间的互斥与同步</strong>，<strong>用于为多个进程提供对共享数据对象的访问</strong>，信号量也是进程之间的一种通信方式。</li></ul></li><li><p><strong>Socket</strong>：Socket套接字进行通信，与其他机制不同的是，它<strong>可用于不同机器之间的进程间通信</strong>，应用非常广泛。</p></li></ul><h3 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h3><p>一. <strong>批处理系统</strong></p><ul><li><p>批处理系统没有太多的用户操作，在该系统中，<strong>调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>目标是保证吞吐量和周转时间</strong>（从提交到终止的时间）</p></li><li><p>先来先服务调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>（FCFS）：</p><ul><li>每次调度是<strong>从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li><li>比较有利于长作业（进程），而不利于短作业（进程）</li><li><strong>有利于CPU繁忙型作业（进程） ，而不利于I/O繁忙型作业（进程）</strong></li><li>用于批处理系统，不适于分时系统</li></ul></li><li><p>短进程优先调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ul><li><strong>从就绪队列中选出一个估计运行时间最短的进程</strong>，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li><li>对长作业不利，未考虑作业(进程)的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li></ul></li><li><p>最短剩余时间优先</p><p>shortest remaining time next（SRTN）</p><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul></li></ul><p>二. <strong>交互式系统</strong></p><ul><li><p>交互式系统有大量的用户交互操作，在该系统中调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>的目标是快速地进行响应</p></li><li><p>时间片轮转法</p><p>：</p><ul><li>系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，<strong>把CPU分配给队首进程，并令其执行一个时间片</strong>。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它<strong>送往就绪队列的末尾</strong>；然后，再把处理机分配给<strong>就绪队列中新的队首进程，同时也让它执行一个时间片</strong>。</li><li>紧迫任务响应慢。</li></ul></li><li><p>多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><ol><li><strong>设置多个就绪队列</strong>，并为各个队列赋予不同的<strong>优先级</strong>；该<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>赋予<strong>各个队列中进程执行时间片</strong>的大小也各不相同，在<strong>优先权愈高</strong>的队列中，为<strong>每个进程所规定的执行时间片就愈小</strong>。</li><li>当一个新进程进入内存后，首先将它放入<strong>第一队列的末尾</strong>，<strong>按FCFS原则排队等待调度</strong>；当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；<strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，<strong>再同样地按FCFS原则等待调度执行</strong>；</li><li><strong>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行</strong></li></ol></li><li><p>优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a></p><p>：</p><p>把处理机分配给就绪队列中优先权最高的进程</p><ul><li>**非抢占式优先权<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；</li><li><strong>抢占式优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a><strong>：系统把处理机分配给优先权最高的进程，使之执行。但</strong>在其执行期间</strong>，<strong>只要出现了另一个其优先权更高的进程</strong>，<strong>进程调度程序就立即停止当前进程</strong>(原优先权最高的进程)的执行，<strong>重新将处理机分配给新到的优先权最高的进程</strong>。</li><li>这种抢占式的优先权调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中</li></ul></li></ul><p>三. <strong>实时系统</strong></p><ul><li>实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</li></ul><h4 id="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"><a href="#Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？" class="headerlink" title="Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？"></a>Q：有5个任务，每个任务权重15524，执行时间15534，如何用最短的时间执行完？</h4><ul><li><strong>WARNING：这是我面试中遇到的问题，以下为我个人思考的答案，仅供参考</strong></li><li>可以采用**多级反馈队列调度<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**，可以看成时间片轮转调度和优先级调度的结合</li><li>最上面的队列，优先级最高，首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程</li><li><strong>如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾</strong>，若第二队列的时间片用完后作业还不能完成，一直进入下一级队列，直至完成</li><li>在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业即抢占式调度CPU</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源</li><li>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换【一个进程有多个线程】</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间，I/O 设备等，所付出的开销远大于创建或撤销线程时的开销；类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信：线程间可以通过直接读写同一进程中的数据进行通信【线程共享进程内存空间】，但是进程通信需要借助 IPC</li></ul><h2 id="多进程-amp-多线程"><a href="#多进程-amp-多线程" class="headerlink" title="多进程 &amp; 多线程"></a>多进程 &amp; 多线程</h2><ul><li><p>进程</p><p>：</p><ul><li><strong>优点</strong>：1. 顺序程序的特点：具有封闭性和可再现性；2.<strong>程序的并发执行和资源共享</strong>。多道程序设计出现后，实现了程序的并发执行和资源共享，提高了系统的效率和系统的资源利用率。</li><li><strong>缺点</strong>：1. <strong>操作系统调度切换多个线程要比切换调度进程在速度上快的多</strong>。而且<strong>进程间内存无法共享</strong>，通讯也比较麻烦；2. 线程之间由于共享进程内存空间，所以交换数据非常方便；在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</li></ul></li><li><p>线程</p><p>：</p><ul><li><strong>优点</strong>：</li></ul><ol><li>启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间（因为在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段。<strong>线程之间却可以使用相同的地址空间，共享大部分数据</strong>）；</li><li><strong>线程间方便的通信机制</strong>，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用，这不仅快捷，而且方便；</li><li>使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上；</li></ol><ul><li><strong>缺点</strong>：<strong>调度时, 要保存线程状态</strong>，频繁调度, 需要占用大量的机时；程序设计上容易出错（<strong>线程同步问题</strong>）</li></ul></li><li><p>多进程</p><ul><li><strong>多进程优点</strong>：1. <strong>每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系</strong>；2. 通过增加CPU，就可以容易扩充性能；3. 可以<strong>尽量减少线程加锁/解锁的影响，极大提高性能</strong>，就算是线程运行的模块<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>效率低也没关系；4. 每个子进程都有2GB地址空间和相关资源，总体能够达到的性能上限非常大。</li><li><strong>多进程缺点</strong>：1. 逻辑控制复杂，需要和主程序交互；2. 需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算；3. 多进程调度开销比较大。</li></ul></li><li><p>多线程</p><p>：</p><ul><li><strong>多线程的优点</strong>：1. 无需跨进程边界；2. 程序逻辑和控制方式简单；3. 所有线程可以直接共享内存和变量等；4. 线程方式消耗的总资源比进程方式好；</li><li><strong>多线程缺点</strong>：</li></ul><ol><li>每个线程与主程序共用地址空间，受限于2GB地址空间；</li><li><strong>线程之间的同步和加锁控制比较麻烦</strong>；</li><li>一个线程的崩溃可能影响到整个程序的稳定性；</li><li>到达一定的线程数程度后，即使再增加CPU也无法提高性能，例如Windows Server 2003，大约是1500个左右的线程数就快到极限了（线程堆栈设定为1M），如果设定线程堆栈为2M，还达不到1500个线程总数；</li><li><strong>线程能够提高的总性能有限</strong>，而且线程多了之后，线程本身的调度也是一个麻烦事儿，需要消耗较多的CPU</li></ol></li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li><p>进程/线程/协程区别</p><ul><li><strong>进程拥有自己独立的堆和栈</strong>，<strong>既不共享堆，亦不共享栈</strong>，进程<strong>由操作系统调度</strong></li><li><strong>线程拥有自己独立的栈</strong>和<strong>共享的堆</strong>，共享堆，不共享栈，<strong>线程亦由操作系统调度</strong></li><li><strong>协程</strong>和线程一样<strong>共享堆，不共享栈</strong>，协<strong>程由程序员在协程的代码里显示调度</strong></li></ul></li><li><p>协程与线程区别</p><p>：</p><ul><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU</li><li><strong>线程进程都是同步机制，而协程则是异步</strong></li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li><li><strong>协程避免了无意义的调度</strong>，由此可以提高性能，但也因此，<strong>程序员必须自己承担调度的责任</strong>，同时，<strong>协程也失去了标准线程使用多CPU的能力</strong></li></ul></li></ul><h3 id="Q：协程是如何更少占用资源的"><a href="#Q：协程是如何更少占用资源的" class="headerlink" title="Q：协程是如何更少占用资源的"></a>Q：协程是如何更少占用资源的</h3><ul><li>协程切换完全在用户空间进行，线程切换涉及用户态和内核态切换，需要在内核空间完成<ul><li>协程不依赖操作系统和其提供的线程</li><li><strong>协程之间的切换完全在用户态执行，在用户态没有时钟中断，系统调用等机制，因此效率高</strong>。<strong>协程切换只涉及基本的CPU上下文切换</strong>（寄存器保存 CPU运行任务所需要的信息），协程切换非常简单，就是把当前协程的 CPU 寄存器状态保存起来，然后将需要切换进来的协程的 CPU 寄存器状态加载的 CPU 寄存器上。</li><li>系统内核调度的对象是线程，<strong>线程的调度只有拥有最高权限的内核空间才可以完成，所以线程的切换涉及到用户空间和内核空间的切换</strong>，现代操作系统一般都采用抢占式调度，<strong>上下文切换一般发生在时钟中断和系统调用返回前</strong>，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，保存当前线程的环境，并且恢复目标线程的运行环境。</li></ul></li><li>协程占用内存少<ul><li>线程除了和协程相同基本的 CPU 上下文，还有线程私有的栈和寄存器等，上下文比协程多一些</li></ul></li></ul><h2 id="孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】"><a href="#孤儿进程-amp-僵尸进程【怎么产生的？有什么危害？怎么去预防？】" class="headerlink" title="孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】"></a>孤儿进程 &amp; 僵尸进程【怎么产生的？有什么危害？怎么去预防？】</h2><ul><li><p>一般进程，正常情况下：子进程由父进程创建，子进程再创建新的进程。父子进程是一个异步过程，父进程永远无法预测子进程的结束，所以，当子进程结束后，它的父进程会调用wait()或waitpid()取得子进程的终止状态，回收掉子进程的资源。</p></li><li><p><strong>孤儿进程</strong>：<strong>父进程结束了，而它的一个或多个子进程还在运行</strong>，那么这些子进程就成为孤儿进程(father died)。子进程的资源由init进程回收</p></li><li><p><strong>僵尸进程</strong>：<strong>子进程退出了，但是父进程没有用wait或waitpid去获取子进程的状态信息，子进程的进程描述符仍然保存在系统中</strong></p></li><li><p>危害</p><p>：</p><ul><li>如果父进程不调用wait或waitpid的话，那么保留的信息就不会被释放，其进程号就会被一直占用，但是系统所能使用的进程号是有限的，如果大量产生僵死进程，<strong>将因没有可用的进程号而导致系统无法产生新的进程</strong>，这就是僵尸进程的危害</li><li>孤儿进程是没有父进程的进程，它由init进程循环的wait()回收资源，init进程充当父进程。因此孤儿进程并没有什么危害</li></ul></li><li><p>预防/解决方法</p><p>：</p><ul><li>fork()两次，将子进程变成孤儿进程，从而其父进程变成init进程，通过init进程处理僵尸进程【fork函数的作用是从已经存在的进程中创建一个子进程，而原进程称为父进程】</li><li>通过信号机制，在处理函数中调用wait，回收资源</li></ul></li></ul><h3 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h3><ul><li><p>同步需要等待（阻塞），异步无需等待（不阻塞）</p></li><li><p>同步</p><p>：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令</p><ul><li>同步就是整个处理过程<strong>顺序执行</strong>，当各个过程都执行完毕，并返回结果。是一种<strong>线性执行的方式</strong>，<strong>执行的流程不能跨越</strong>。一般用于流程性比较强的程序，比如用户登录，需要对用户验证完成后才能登录系统。</li></ul></li><li><p>异步</p><p>：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程</p><ul><li><strong>异步</strong>则是只是发送了调用的指令，调用者无需等待被调用的方法完全执行完毕，而是继续执行下面的流程。<strong>是一种并行处理的方式</strong>，不必等待一个程序执行完，可以执行其它的任务，比如页面数据加载过程，不需要等所有数据获取后再显示页</li></ul></li></ul><h2 id="操作系统中的堆栈"><a href="#操作系统中的堆栈" class="headerlink" title="操作系统中的堆栈"></a>操作系统中的堆栈</h2><ul><li><p><strong>操作系统的堆和栈是指对内存进行操作和管理的一些方式</strong>这和数据结构中的堆和栈是有区别的</p></li><li><p>栈</p><p>：</p><ul><li>栈也可以称之为栈内存是一个具有动态内存区域，存储函数内部（包括main函数）的局部变量，方法调用及函数参数值</li><li><strong>由编译器/系统自动分配和释放</strong>。例如，声明在函数中一个局部变量，即int b，系统自动在栈中为变量b开辟空间</li><li>栈存放<strong>函数的参数值，局部变量的值</strong>等。其操作方式类似于数据结构中的栈，满足：“先进后出”的原则存取，也就是位于栈内的元素，必须等到其上面（对应的地址为较低的地址）的数据或函数执行完成后，弹出后才可以进行下面的元素的操作</li><li>栈是由系统自动分配的，一般速度较快（<strong>栈的速度高于堆的速度</strong>）</li><li>申请大小的限制：栈是向低地址扩展的，是一块连续的内存的区域。栈顶的地址和栈的最大容量<strong>是系统预先规定好的</strong>，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ，<strong>如果申请的空间超过栈的剩余空间时，将提示overflow</strong>。因此，<strong>能从栈获得的空间较小</strong>。</li></ul></li><li><p>堆</p><p>：</p><ul><li>一般由程序员分配释放，并指明大小，堆被程序申请使用的内存在被主动释放前一直有效。堆需要由由程序员手动释放，<strong>不及时回收容易产生内存泄露</strong>。 程序结束时可能由操作系统回收。</li><li>栈是存放在一级缓存中的，而堆则是存放在二级缓存中的，<strong>堆的生命周期由虚拟机的垃圾回收<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>来决定</strong>（并不是一旦成为孤儿对象就能被回收），所以调用这些对象的速度要相对来得低一些，故堆的速度慢于栈的速度</li><li>与数据结构中的堆是不同的，分配方式类似于<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>（空闲<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>法），<strong>堆是向高地址扩展的数据结构，是不连续的内存区域</strong>，这是由于系统是用<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>来存储空闲内存地址的，自然是不连续的，而<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>的遍历方向是由低地址向高地址。<strong>堆的大小受限于计算机系统中有效的虚拟内存</strong>。由此可见，堆获得的空间比较灵活，也比较大。</li></ul></li><li><p>区别</p><p>：</p><ul><li>空间分配：栈由操作系统自动分配释放；堆一般由程序员分配释放</li><li>申请效率对比：栈使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放；.堆使用二级缓存，生命周期与虚拟机的GC<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>有关，调用速度相对较低。</li><li>申请大小的限制：栈是向低地址扩展的数据结构，是一块连续的内存的区域；堆是向高地址扩展的数据结构，是不连续的内存区域</li></ul></li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><a href="https://juejin.im/post/5c37577e6fb9a049fd100da8#heading-0">参考文章</a></p><ul><li>死锁是指<strong>多个进程</strong>在运行过程中因<strong>争夺资源</strong>而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进</li></ul><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ul><li><strong>多个进程竞争资源</strong></li><li><strong>进程间推进顺序不当</strong></li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li><strong>互斥</strong>条件，在任何时刻一个资源只能被一个进程使用</li><li><strong>拥有和请求</strong>（请求和保持条件），已经得到某个资源的进程可以再请求新的资源</li><li><strong>不可抢占</strong>（不剥夺条件），已经分配给进程的资源不能被抢占，而只能被显式释放</li><li><strong>循环等待</strong>（环路等待条件），系统中有两个或多个的进程组成一条循环，该循环中的每个进程都等待着另一个进程占有的资源</li></ul><h3 id="处理策略"><a href="#处理策略" class="headerlink" title="处理策略"></a>处理策略</h3><ol><li><p>解决死锁：【<strong>撤销进程法</strong>】</p></li><li><p>死锁预防</p><p>：破坏死锁产生的四个必要条件中的一个或多个，以避免发生死锁。【</p><p>资源有序分配法</p><p>】</p><ul><li>破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源；</li><li>破坏拥有和请求：1. 已拥有资源的进程不能再去请求其他资源，要求进程在开始执行前请求需要的所有资源；2. 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源</li><li>破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占</li><li>破坏循环等待：1. 保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源；是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源</li></ul></li><li><p><strong>避免死锁</strong>：判断是否会出现死锁就是看是否能找到一个安全序列，使得进程按推进顺序为每个进程分配其所需资源，使每个进程都能顺序执行。例如：【**银行家<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>**】</p></li><li><p><strong>检测死锁并恢复</strong>：资源分配图；从一个或多个进程中抢占资源分配给死锁进程；终止所有的死锁进程。【<strong>资源分配图化简法</strong>】</p></li></ol><h3 id="如何发现死锁？"><a href="#如何发现死锁？" class="headerlink" title="如何发现死锁？"></a>如何发现死锁？</h3><ul><li>通过死锁检测工具，例如通过jdk工具jps、jstack排查死锁问题</li></ul><ol><li><strong>使用jsp查找程序进行</strong>：jps是jdk提供的一个工具，可以查看到正在运行的java进程</li><li><strong>使用jstack查看线程堆栈信息</strong>：jstack：jdk提供的一个工具，可以查看java进程中线程堆栈信息，后面可以查看到具体在代码哪一行。</li><li>也通过jdk提供的工具<strong>jconsole排查死锁问题</strong>：jconsole是<strong>jdk提供的一个可视化的工具</strong>，方便排查程序的一些问题，如：程序内存溢出、死锁问题等等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> operate </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2021/03/15/network/"/>
      <url>2021/03/15/network/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p><font color="green">时延指数据（一个报文或分组，甚至比特）从网络的一段传送到另一端所需的时间。</font></p><ul><li>$总时延=发送时延+传播时延+处理时延+排队时延$</li></ul><ol><li>发送时延</li></ol><p>主机或路由器发送数据帧所需要的时间。(从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间)。</p><p>$ sendTime=length of data(bit) / velocity(bit/s)$</p><ol start="2"><li>传播时延</li></ol><p>信道中传输时间。</p><p>$propagate=length of channel(m) / electromagnetic wave velocity (m/s) $</p><ol start="3"><li>处理时延</li></ol><p>主机或路由器收到分组，分析分组的首部、从分组中提取数据部分、进行差错检验、寻找下一个路由器地址等。</p><ol start="4"><li>排队时延</li></ol><p>分组进入路由器在输入队列排队，在发送后输出队列排队发送。</p><p><img src="/2021/03/15/network/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.PNG"></p><h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ul><li><p>速率(bit/s)</p><p>1K=$10^3$ M G T P E Z Y</p><p><font color="red">电脑上显示的M指的是 按照存储格式讲的，存储计算机1024bit $k=2^{10}$  K M G T P E Z Y</font></p></li><li><p>带宽</p></li></ul><p>通信上讲的带宽，3.0Ghz ~3.4 Ghz  0.4  按照频率范围上讲的。</p><p>计算机网络中，带宽指的是信道传输的最大速率。</p><h3 id="ADSL-Asymmetric-Digital-Subscriber-Line"><a href="#ADSL-Asymmetric-Digital-Subscriber-Line" class="headerlink" title="ADSL (Asymmetric Digital Subscriber Line)"></a>ADSL (Asymmetric Digital Subscriber Line)</h3><p><img src="/2021/03/15/network/adsl.PNG" alt="adsl"></p><h3 id="HFC-Hybrid-Fiber-Coax-光纤同轴混合网"><a href="#HFC-Hybrid-Fiber-Coax-光纤同轴混合网" class="headerlink" title="HFC(Hybrid Fiber Coax)光纤同轴混合网"></a>HFC(Hybrid Fiber Coax)光纤同轴混合网</h3><p><img src="/2021/03/15/network/%E8%B0%83%E5%88%B6%E8%A7%A3%E8%B0%83%E5%99%A8.PNG" alt="调制解调器"></p><h4 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h4><p>光纤到户(FTTH)</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="1-点对点信道"><a href="#1-点对点信道" class="headerlink" title="1. 点对点信道"></a>1. 点对点信道</h3><p>链路：一个点到邻近结点的一条物理线路。数据链路是除了链路，还要有必要的通信协议进行传输，把所有这些协议的硬件和软件加到链路，叫做数据链路。</p><ol><li><p>结点A把网络层IP数据报添加首部和尾部。</p></li><li><p>结点A把封装好的数据发送给B的数据链路层。</p></li><li><p>B先进行差错检验，无错提取IP数据报，否则丢弃。</p></li></ol><p>a) <font color="green">封装成帧</font></p><p>添加首尾部。最大传输数据单元(Maximum Transfer Unit,MTU)，数据部分的最大长度上限。帧定界符 开始 SOH (00000001)  结束EOT(00000100)。</p><p>b) <font color="green">透明传输</font></p><p>数据部分是文本文件中的字符时，不可能和控制字符相同，任何内容都可以通过帧传过去，所以是透明传输。</p><p>当信息是图片时，可能会出现控制符一样的二进制位。</p><p><img src="/2021/03/15/network/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png"></p><p>解决办法，插入转义字符ESC(00011011),接收端将数据发往网络层要删除所有的ESC。</p><p><img src="/2021/03/15/network/ESC%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png"></p><p>c) <font color="green">差错检验</font></p><p>循环冗余检测(Cyclic Redundancy Check，CRC)。增加n位冗余码（除以n+1位除数）。</p><p>FCS(Frame Check Sequence)。</p><p>接收端，如果R（余数）算出来是0，则accept。否则，丢弃。</p><p>增加了帧编号、确认、重传机制。</p><h3 id="PPP-Point-to-Point-Protocal"><a href="#PPP-Point-to-Point-Protocal" class="headerlink" title="PPP(Point-to-Point Protocal)"></a>PPP(Point-to-Point Protocal)</h3><ol><li><font color="green">协议的组成</font></li></ol><p>a) 封装到链路的方法。</p><p>b) <strong>LCP链路控制协议</strong>，建立配置和测试链路连接。RFC1661定义了11种类型的LCP分组。</p><p>c) <strong>网络控制协议NCP</strong>。其中的每一个协议支持不同的网络层协议，如IP、OSI的网络层。</p><ol start="2"><li><font color="green">协议帧的格式</font></li></ol><p><img src="/2021/03/15/network/PPP%E5%8D%8F%E8%AE%AE%E5%B8%A7%E7%9A%84%E6%A0%BC%E5%BC%8F.png"></p><p>首部4个字段：7E PPP的定界符。FF 03 至今没给出定义。协议 是2字节协议字段， 0x0021时，PPP的信息是IP数据报，0xC021，是PPP协议的控制协议LCP的数据。</p><p>信息部分可变化，最长1500字节。</p><p>FCS冗余码。</p><ol start="3"><li><font color="green">零比特填充</font>（同步传输）</li></ol><p>5个连续1后面插入0。以此来保证透明传输。</p><p><img src="/2021/03/15/network/%E9%9B%B6%E6%AF%94%E7%89%B9%E5%A1%AB%E5%85%85.png"></p><ol start="4"><li><font color="green">协议的工作状态</font></li></ol><p><img src="/2021/03/15/network/PPP%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E5%9B%BE.png"></p><p>PPP协议起始和终止都处于“链路静止”状态。之后用户向ISP拨号，与ISP建立物理链路，然后LCP链路开始进行协议协商，如果成功，则开始进行网络层协议（NCP）协商，如果是IP协议则是IPCP（IP控制协议），将IPCP封装成帧。网络层配置结束，数据链路开始工作（链路打开）。</p><p>图中可以看出PPP协议不是单纯的数据链路层协议，还包括物理层内容和网络层内容。</p><h3 id="2-使用广播信道的数据链路层（CSMA-CD"><a href="#2-使用广播信道的数据链路层（CSMA-CD" class="headerlink" title="2.使用广播信道的数据链路层（CSMA/CD)"></a>2.使用广播信道的数据链路层（CSMA/CD)</h3><p><img src="/2021/03/15/network/%E5%B1%80%E5%9F%9F%E7%BD%91%E6%8B%93%E6%89%91.png"></p><p><font color="green">1. 共享信道的两种划分方法</font></p><p>a) 静态划分信道</p><p>频分复用、时分复用、码分复用和波分复用等。开销较大。</p><p>b) 动态媒体接入控制</p><ul><li>随机接入</li></ul><p>用户根据自己的情况随机发送信息，可能产生碰撞，需要碰撞协议。</p><ul><li>受控接入</li></ul><p>不能随机发送，比如令牌环局域网和及集中控制的轮询和多点线路探询。</p><p><font color="green">2. 以太网的两个标准</font></p><p>IEEE 802委员会提出将数据链路层划分为 <strong>逻辑链路控制LLC</strong>（Logic Link Control) 和 <strong>媒体接入控制层MAC</strong>(Media Access Control)。</p><p><img src="/2021/03/15/network/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%88%92%E5%88%86.png"></p><p>LLC与传输媒体无关，MAC处理传输媒体有关的内容。</p><p>之后因为以太网的发展，局域网技术没落，目前大部分厂商只MAC协议，LLC作用已经消失。</p><p><font color="green">3. 适配器的作用</font></p><p>计算机和外界局域网连接需要<strong>适配器</strong>。适配器和计算机之间通过IO总线传输信息，适配器和局域网通过双绞线和电缆传输信息。</p><p>适配器功能不局限于数据链路层，适配器在接发各种帧时不使用CPU，当帧判断可用时，才会发出中断信息通知计算机，并交付协议栈中的网络层。</p><p><font color="green">4.CSMA/CD协议</font>(Carrier Sense Multiple Access with Collision Detection)<strong>载波监听多点接入/碰撞</strong></p><p>以太网发送数据都是用 <strong>曼彻斯特编码</strong>。变化频率变化了一倍，所以频率开销增大。</p><p><img src="/2021/03/15/network/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81.png"></p><ul><li>多点接入：多个计算机同时连接在一根总线上。</li><li>载波监听：使用电子技术检测总线上有没有其他计算机在发送数据。载波只是名词，就是检测信道，检测其他计算机发没发信息。</li><li>碰撞检测（冲突检测）：边发送边监听，适配器边发送边检测信道上的信号电压信号，以便于发送数据时监听其他计算机发没发数据。当两个计算机同时发送数据，则碰撞，随机等待一段时间再发送。</li><li><strong>电磁波在1km的电缆传播时延是5us。</strong></li><li>发送数据总有传播时延，当传播时延内另一个计算机发了数据，则碰撞。所以一个计算机最多消耗**两倍$2\tau$**的总线到端的传播时延。</li></ul><p><img src="/2021/03/15/network/%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6%E5%AF%B9%E8%BD%BD%E6%B3%A2%E7%9B%91%E5%90%AC%E7%9A%84%E5%BD%B1%E5%93%8D.png"></p><p>可以看出，一个计算机只能半双工通信，图中看出每次计算机发送信号都不确定是否会碰撞，$2\tau$时延就是<strong>碰撞窗口</strong>（争用期）。</p><ul><li><strong>截断二进制指数退避</strong>(truncated binary exponential backoff)</li></ul><ol><li>$2\tau$协议规定为51.2us。对于10Mbit/s以太网，发送512bit。所以碰撞窗口期是发送512bit时间。</li><li>$k=min[重传次数…10]$ 从离散整数集合$[0,1,…,(2^k-1)]$ 选取整数即为重传次数，必须小于10。</li><li>重传大于16次，丢弃帧，向高层报告。</li></ol><ul><li>强化碰撞</li></ul><p>当发送数据后，还要继续发送32或48bit人为干扰信号，让所有用户都知道已经发生了碰撞。</p><p><img src="/2021/03/15/network/%E4%BA%BA%E4%B8%BA%E5%B9%B2%E6%89%B0%E4%BF%A1%E5%8F%B7.png"></p><ul><li>设定帧间最小间隔9.6us.给接收方96bit时间做准备处理下一次数据。</li></ul><p><img src="/2021/03/15/network/CSMA%E5%8D%8F%E8%AE%AE%E8%A6%81%E7%82%B9.png"></p><ul><li>集线器 局域网星型拓扑，可靠性很好，使用双绞线连接，出现802.3i 10BASE-T标准。10代表10Mbit/s数据。</li></ul><p>实际上还是抽象成总线形式，所以每个时间只允许一个站发送数据。</p><p><strong>集线器工作在物理层</strong>，每个端口仅仅转发信号。</p><h3 id="3-信道利用率"><a href="#3-信道利用率" class="headerlink" title="3. 信道利用率"></a>3. 信道利用率</h3><h3 id="4-mac-地址"><a href="#4-mac-地址" class="headerlink" title="4.mac 地址"></a>4.mac 地址</h3><p>每一个适配器都有一个MAC地址。固化在适配器ROM中的地址。</p><p>MAC的格式：</p><p><img src="/2021/03/15/network/MAC%E5%9C%B0%E5%9D%80.png"></p><p>前两个字段是目的地址和源地址，分别占6个字节。第三个字段是类型，表明数据部分使用的协议是什么。最后是冗余码(fcs crc)。</p><p>数据部分最小长度46，不满46就填充够46。</p><p>MAC帧前还有8个字节，前7字节是为了同步时钟频率，最后一个帧开始界定符。</p><h3 id="5-扩展以太网"><a href="#5-扩展以太网" class="headerlink" title="5. 扩展以太网"></a>5. 扩展以太网</h3><ol><li>物理层扩展</li></ol><p>增加解调器扩大物理链路交流区域。</p><p><img src="/2021/03/15/network/%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82.png"></p><ol start="2"><li>数据链路层扩展</li></ol><p>交换式集线器称为以太网交换机或者第二层交换机。实质上是多接口的网桥。其内部通过自学习算法存储帧交换表。</p><p>独占传输媒体，无碰撞地传输数据。</p><p>生成树协议STP，不改变网络拓扑，逻辑上没有闭环，防止兜圈子问题。</p><ol start="3"><li>虚拟局域网VLAN</li></ol><p><img src="/2021/03/15/network/%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN.png"></p><p>可以防止广播风暴，A1发送信息只有A组能够看到。</p><p>帧格式：</p><p><img src="/2021/03/15/network/VLAN%E5%B8%A7%E6%A0%BC%E5%BC%8F.png"></p><p>在MAC帧中插入4字节VLAN标记，源地址后两位如果是0x8100时，表明后面加了VLAN。源地址的最后两个字节中，前3位是用户优先级字段，接着一位是规范格式符CFI，最后12位是虚拟局域网VLAN标识符VID，它标记了这个以太网帧属于哪个虚拟局域网。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层只提供尽最大努力交付服务，可以减少路由器价格成本等，因为计算机本身具有很强的计算能力，差错检验能力很强。</p><h4 id="1-网络协议IP"><a href="#1-网络协议IP" class="headerlink" title="1.网络协议IP"></a>1.网络协议IP</h4><p>一般指的是第四个版本IPv4。一般和<strong>地址解析协议</strong>(Address Resolution Protocol,ARP)、<strong>网际控制报文协议ICMP</strong>(Internet Control Message Protocol)、<strong>网际组管理协议IGMP</strong>（Internet Group Management Protocol）。</p><p><img src="/2021/03/15/network/IP%E5%8F%8A%E5%85%B6%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png"></p><p>2.网络互连的中间设备</p><ol><li><p>物理层使用的中间设备是<strong>转发器</strong>。</p></li><li><p>数据链路层使用的中间设备是<strong>网桥或桥接器</strong>。</p></li><li><p>网络层使用的中间设备是<strong>路由器</strong>。</p></li><li><p>网络层以上使用的中间设备叫<strong>网关</strong>。网关连接两个不兼容的系统需要在高层进行协议转换.</p><p>3.虚拟互联网络</p></li></ol><p>由于不同的计算机网络使用相同的IP协议。因此可以看做虚拟互连网络</p><p><strong>直接交付</strong>目的主机在本网络中不需要其他路由器转发。</p><p><strong>间接交付</strong>目的主机不在本网络。</p><h4 id="2-分类的IP地址"><a href="#2-分类的IP地址" class="headerlink" title="2.分类的IP地址"></a>2.分类的IP地址</h4><p>IP地址就是互联网上每一台主机的每一个接口分配一个在全世界范围内唯一的32位标识符。IP地址现在由<strong>互联网名字和数字分配机构ICANN</strong>（Internet Corporation for Assigned Names and Numbers)进行分配。</p><p>IP地址的<strong>第一个字段</strong>是网络号，标志主机所连接到的网络。一个网络号在整个互联网范围内是唯一的。<strong>第二个字段</strong>是主机号，它标志该主机</p><p><img src="/2021/03/15/network/IP%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%AD%97%E6%AE%B5.png"></p><p>$ IP地址 :: = {&lt;网络号&gt;,&lt;主机号&gt;}$</p><ul><li>A类、B类和C类网络号字段数分别是1、2和3.网络号字段的最前面有1-3位是类别位，数值分别是0,10，110。</li><li>A类、B类和C类地址的主机号分别为3、2和1。</li><li>D类地址用于多播。</li><li>E类地址保留为以后使用。</li></ul><h4 id="3-常用的3类地址"><a href="#3-常用的3类地址" class="headerlink" title="3.常用的3类地址"></a>3.常用的3类地址</h4><ul><li>A类 主机号占3个字节，因此每个A类网络最大主机数是$2^{24}-2$。全0主机号字段表示“这个”，保留地址意思是“本网络”，例如某主机IP5.6.7.8那么其本地网络就是5.0.0.0。全1表示网络上所有的主机。A类共有$2^{31}$个地址。</li><li>B类 两个字节，前面两位固定，剩下14位分配网络号。14位不可能全0和全1。<strong>所以不需要减2</strong>。但是<strong>128.0.0.0</strong>是不指派的，B类最小网路地址是<strong>128.1.0.0</strong>。所以网络数是$2^{14}-1$。B类共$2^{30}$地址。</li><li>C类 三个字节网络号，110。网络号还有21位可以分配。<strong>192.0.0.0</strong>不指派，C类<strong>192.0.0.0</strong>不指派，可以使用的最小网络地址是<strong>192.0.1.0</strong>。这样C类地址可以指派的网络总数是$2^{21}-1$。共$2^{29}$地址。</li></ul><p><img src="/2021/03/15/network/IP%E5%88%86%E9%85%8D%E8%8C%83%E5%9B%B4.png"></p><h4 id="4-IP地址和硬件地址"><a href="#4-IP地址和硬件地址" class="headerlink" title="4.IP地址和硬件地址"></a>4.IP地址和硬件地址</h4><p><img src="/2021/03/15/network/ip%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80.png"></p><p>数据从高层向底层传输。网络层和网络层以上使用IP地址，数据链路层及其以下的使用硬件地址。</p><p><img src="/2021/03/15/network/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%9C%B0%E5%9D%801.png"></p><p><img src="/2021/03/15/network/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%AC%A1%E7%9A%84%E5%9C%B0%E5%9D%80.png"></p><ol><li>路由器只根据目的站的IP地址的网络号进行选择。</li><li>局域网链路层只看到MAC帧。IP数据报被封装在MAC帧中，MAC帧在不同网络上传送时，其MAC帧首部中的源地址和目的地址发生变化。图中可以看出，MAC从H1到R1传送，源地址和目的地址是HA1和HA3，R1收到帧后，重新添加源地址和目的地址HA4和HA4。</li></ol><h4 id="5-地址解析协议ARP"><a href="#5-地址解析协议ARP" class="headerlink" title="5.地址解析协议ARP"></a>5.地址解析协议ARP</h4><p><strong>知道了IP地址，如何找到其对应的MAC地址呢？</strong></p><p><img src="/2021/03/15/network/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><p>还有一个RARP逆地址解析协议，现在的DHCP协议包含了RARP，不需要再讲。</p><ul><li><strong>ARP解决</strong>这个问题的方法是在主机ARP高速缓存中存放一个从<strong>IP地址到硬件地址的映射表</strong>，并且这个映射表还经常动态更新（新增或超时删除）。</li></ul><p>A向B发数据报，先在ARP高速缓存中查看B的IP地址，如果有再找ARP映射表，找到硬件地址就放到MAC帧中。如果B刚刚加入网络，找不到B硬件地址，则：</p><p><img src="/2021/03/15/network/ARP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><ul><li>ARP找硬件地址步骤：</li></ul><ol><li>A发送ARP请求广播。</li><li>网络上所有主机收到广播信息。</li><li>B收到请求，向A发送自己地址。（B可以收到A的所有ARP缓存信息，方便以后和本网络（局域网）中所有主机通信）。</li><li>A收到B地址更新ARP高速缓存。</li></ol><ul><li><strong>生存时间</strong>：10~20min。超时就剔除那个硬件地址。（防止某个时刻B的硬件更换导致硬件地址变化）。</li><li><strong>实际是按照硬件地址通信的</strong>，那么为什么还要有IP呢？</li></ul><p>全世界不同网络使用不同的硬件地址，这些网络互相通信就必须做硬件地址转换工作，会使网络十分复杂。IP就屏蔽了这个问题。</p><h4 id="6-IP数据报格式"><a href="#6-IP数据报格式" class="headerlink" title="6.IP数据报格式"></a>6.IP数据报格式</h4><p>TCP/IP中各种数据格式常常以32位（4字节）描述。</p><p><img src="/2021/03/15/network/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png"></p><ol><li>首部。</li></ol><p>5个4字节描述（共20字节，每个4*8=32位）。</p><ul><li><strong>版本</strong> 4位，IP协议的版本，双方通信的IP版本必须一致。</li><li><strong>首部长度</strong> 4位，可表示最大十进制数是15。一般是0101（5,5*4=20），当首部长度为最大值1111，则60字节（15*4）。</li><li><strong>区分服务</strong> 占8位，用来获得更好的服务。这个字段在旧的标准叫做服务类型。实际一直没用过。</li><li><strong>总长度</strong> 总长度指首部和数据之和的长度，单位为字节。总长度为16位，数据报最大长度为$2^{16}-1$字节。<strong>MTU</strong>(Maximum Transfer Unit)。当一个IP数据报封装成链路层的帧时，此数据报的总长度一定不能超过下面数据链路层规定的MTU值。当超过就要分片。</li><li><strong>标识</strong> 占16位，IP软件有一个计数器，产生一个数据报计数器加1，赋给标识字段，解决IP数据报不是按序接收的问题。</li><li><strong>标志</strong> 占3位，目前只有两位有意义。最低位MF=1，表示后面还有分片，MF=0表示最后数据分片中最后一个。中间一位DF=1表示不能分片，DF=0允许分片。</li><li><strong>片偏移</strong> 占13位。较长的分组在分片后，某片在原分组中的相对位置，相对用户数据字段的起点。片偏移以8个字节为偏移单位，每个分片长度一定是8字节的整数倍。</li><li><strong>生存时间</strong> 8位，TTL(Time To Live)，表明这是数据报在网络中的寿命。发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网兜圈子。现在TTL指传几跳路由器，经过一个路由器就减一。初始TTL=1只能在本地局域网络传送。</li><li><strong>协议</strong> 占8位，协议字段指出数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分交给上层哪个协议处理。</li><li><strong>首部检验和</strong> 16位，只检验数据报的首部，不检验数据部分可以减少工作量。检验方法如图：</li></ul><p><img src="/2021/03/15/network/ip%E6%A3%80%E9%AA%8C%E9%A6%96%E9%83%A8%E5%92%8C.png"></p><p><strong>发送方</strong>将所有首部划分为16位序列，所有16位相加计算反码写入检验和字段。</p><p><strong>接收方</strong>收到数据报后将首部的所有16位再使用反码算数相加，得到的和计算反码和数据报中的检验和字段相加，结果必为0，否则出错。</p><ul><li><p><strong>源地址</strong> 32位。</p></li><li><p><strong>目的地址</strong> 32位。</p></li><li><p><strong>可变部分</strong> 可变从1-40字节不等。用来支持排错、测量以及安全等措施。实际上很少使用（增加计算开销）。</p></li><li><p>路由表中主要信息：</p></li></ul><p>$(目的网络地址，下一跳地址)$</p><p><img src="/2021/03/15/network/ip%E8%B7%AF%E7%94%B1%E8%A1%A8%E4%BF%A1%E6%81%AF.png"></p><ol start="2"><li>默认路由</li></ol><p><img src="/2021/03/15/network/%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1.png"></p><p>主机发送IP数据报时要查找路由表，如果一台主机连接在一个小网络上，这个网络只用一台路由器连接，那么使用默认路由。</p><ol start="3"><li>分组转发</li></ol><p>路由器收到数据报，从路由表知道下一跳IP地址后，利用ARP将IP地址转换为硬件地址放入MAC帧首部，从而送给下一跳路由器或主机。</p><h4 id="7-划分子网"><a href="#7-划分子网" class="headerlink" title="7.划分子网"></a>7.划分子网</h4><ol><li>从两级IP地址到三级IP地址</li></ol><p>两级IP地址（网络号+主机号）问题：</p><ul><li><p>浪费。A类主机数超过1000万，B类超过6万。很多公司宁愿申请A和B类也不想要C。造成IP资源浪费。</p></li><li><p>每一个物理网络分配网络号使得路由表太大，网络性能变差。</p></li></ul><p><strong>三级IP</strong>增加子网号字段：<strong>划分子网</strong>。</p><p>$ IP地址 ::={&lt;网络号&gt;，&lt;子网号&gt;，&lt;主机号&gt;}$</p><ul><li>其他网络发给本单位的IP数据报，根据网络号找到本单位网络，本网络收到后，按照子网号找到目的子网。</li></ul><p><img src="/2021/03/15/network/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.png"></p><p><img src="/2021/03/15/network/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%911.png"></p><ol start="2"><li>子网掩码</li></ol><p>使用子网掩码找到子网中的目的主机。</p><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p><p>不管网络有没有划分子网，只要把子网掩码和IP地址进行按位与，就能得到网络地址。</p><p>如果网络没有划分子网，路由器就默认使用<strong>默认子网掩码</strong>。</p><p><img src="/2021/03/15/network/%E9%BB%98%E8%AE%A4%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.png"></p><p>路由器现在交换信息，必须把自己的子网掩码告诉相邻路由器，这样路由表还给出了每个网络的子网掩码。</p><ul><li>减少了可用主机数。</li><li><strong>划分子网的分组转发</strong>：</li></ul><p>$(目的网络地址，下一跳地址，子网掩码)$</p><ol><li>收到的数据报提取IP地址D。</li><li>判断直接交付。子网掩码与D按位与，得到网络号和<strong>本网络</strong>不匹配间接交付执行3，匹配直接交付。</li><li>路由表有D特定主机路由，则根据路由表IP发送下一跳，否则4。</li><li>对路由表每一行按位与得到结果N。若N与某行网络地址匹配，则发给下一跳，否则5。</li><li>发送默认路由，否则6。</li><li>分组出错。</li></ol><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E5%88%86%E7%BB%84%E8%BD%AC%E5%8F%91.png"></p><p><img src="/2021/03/15/network/%E5%AD%90%E7%BD%91%E4%BA%A4%E4%BB%98%E8%BF%87%E7%A8%8B.png"></p><h4 id="8-构造超网-（CIDR"><a href="#8-构造超网-（CIDR" class="headerlink" title="8.构造超网 （CIDR)"></a>8.构造超网 （CIDR)</h4><p><strong>无分类域间路由选择CIDR</strong>(Class Inter-Domain Routing)。</p><p>1）消除了传统的A类、B类和C类地址以及划分子网概念。把32位地址划分前后两个部分，前面的部分是<strong>网络前缀</strong>，后面的部分指明主机。</p><p>$IP地址 ::={&lt;网络前缀&gt;，&lt;主机号&gt;}$</p><p>在IP地址后面加上斜线“/”写上网络前缀所占的位数。例如：206.0.64.0/18</p><p>2）网络前缀都相同的连续IP组成一个“CIDR地址块”。只要知道CIDR地址块中的任何一个地址，就可以知道地址块的起始地址（最小地址）和最大地址。使用<strong>32位地址掩码</strong>。</p><p>3）最长前缀匹配。超网路由，网络前缀和下一跳地址组成。每次匹配可能会有多条匹配结果，选取匹配前缀最长的。</p><p>4）使用<strong>二叉线索</strong>查找路由表。</p><p><img src="/2021/03/15/network/%E4%BA%8C%E5%8F%89%E7%BA%BF%E7%B4%A2%E6%90%9C%E7%B4%A2%E6%A0%91.png"></p><h4 id="9-网际控制报文协议ICMP"><a href="#9-网际控制报文协议ICMP" class="headerlink" title="9.网际控制报文协议ICMP"></a>9.网际控制报文协议ICMP</h4><p><img src="/2021/03/15/network/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><ul><li>有<strong>ICMP差错报告报文</strong>和<strong>ICMP询问报文</strong> 两类。</li></ul><p><img src="/2021/03/15/network/ICMP%E6%8A%A5%E6%96%87%E6%95%B0%E6%8D%AE.png"></p><p>1）终点不可达。 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</p><p>2）时间超过 当数据报的生存时间为0，丢弃该数据包，还要向源点发送时间超过报文。<strong>或</strong>终点在预定时间内不能收到数据报的全部数据片，就将数据报片丢弃，并向源点发送时间超过报文。</p><p>3）参数问题 数据报首部中有字段的值不正确时，丢弃该数据报，并向IP发送参数问题报文。</p><p>4）改变路由（重定向） 路由器把改变报文发送给主机，让主机知道下次应该发给另外的路由器。</p><p>5）回送请求和回答 由主机或路由向特定目的主机发出询问。收到此报文的主机向源主机或路由器发送ICMP回送回答报文。主要来测试目的站是否可达以及了解相关状态。</p><p>6）时间戳请求和回答。 I请求某台主机回答当前日期和时间。可用于时钟同步和时间测量。</p><ul><li><p>应用</p><p><strong>PING</strong>测试两主机连通性。</p><p><strong>traceroute（unix，windows 是tracert）</strong> 跟踪从源点到终点的路径。</p></li></ul><h3 id="10-路由选择协议"><a href="#10-路由选择协议" class="headerlink" title="10. 路由选择协议"></a>10. 路由选择协议</h3><ol><li>分层次的路由选择协议。</li></ol><p>1）互联网的规模非常大。路由器如果要知所有网络路径，路由表非常大处理费时。</p><p>2）许多单位不愿意外界了解自己的布局细节但是还想连接到互联网上。</p><p>所以，分成很多自治系统（Autonomous System ,AS），一个AS对其他AS表现出的是一个单一的和一致的路由选择策略。</p><p>选择协议分为两类：<strong>内部网关协议IGP（Interior Gateway Protocol）</strong>和<strong>外部网关协议EGP（External Gateway Protocol）</strong>。</p><p>IGP：自治系统内部使用的路由选择协议，与其他自治系统选择什么路由协议无关。如RIP和OSPF。<strong>域内路由选择</strong>。</p><p>EGP：不同的自治系统间的协议。例如BGP版本4（BGP-4）。<strong>域间路由选择</strong>。</p><ol start="2"><li><strong>RIP</strong>（Routing Information Protocol）</li></ol><p>基于距离向量的路由选择协议。距离定义：每经过一跳路由器就+1。例如直连路由是1。所以RIP适用于（小型网络）。</p><ul><li>RIP不能在两个主机间同时使用多个路由，RIP选择一条最少路由器的路由，哪怕还存在另一条高速但路由器较多的路由。</li><li>仅和相邻路由交换信息。</li><li><strong>距离选择算法</strong></li></ul><p>1）对地址为X的相邻路由发来的RIP报文，把“下一跳”字段中的地址改为X，并把所有“距离”加1。每一个项目都有三个关键数据：目的网络N，距离d，下一跳路由器X。</p><p>2）对修改后的RIP报文每一个项目：</p><p>若原来路由表<strong>没有</strong>目的网络N，则把该项目添加到路由表中。</p><p>否则（有N）：</p><p>若下一跳路由器是X，则把收到的项目替换为原来的路由表中的项目。</p><p>否则（到目的网络N的下一跳不是X）：</p><p>收到的项目中的距离d小于路由表中的距离，则进行更新。否则什么也不做。</p><p>3）3分钟还没有收到相邻路由器的更新路由表，则把相邻路由器记为不可达的路由器，即距离设置为<strong>16</strong>。</p><p>4）返回。</p><p>这个算法基础是<strong>Bellman-Ford算法</strong>。（求A到B最短路径）</p><p>例题<strong>直接看书P155页 例题</strong>，看一眼如何更新表就懂了。</p><ul><li>RIP协议的报文格式</li></ul><p><img src="/2021/03/15/network/Rip%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F.png"></p><p>一个RIP报文最多携带25个路由，所以最大长度4+20*25=504字节。<strong>使用UDP传送</strong>。</p><p>RIP的首部占4个字节，其中命令字段指出报文的意义。例如1表示请求路由信息，2表示请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的必为0为了4字节对齐。</p><ul><li>RIP协议存在的问题</li></ul><p>当网络出现故障时，要经过较长时间才能将此信息传送到所有路由器。<strong>好消息传得快，坏消息传的慢</strong>。例子：</p><p><img src="/2021/03/15/network/Rip%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%99%90%E5%88%B6.png"></p><p>图中“1,1，直接“指到网络1,1跳，直接交付。 网络1出现了故障，R1无法到达网1。于是路由器R1把到网1的距离改为16。但是，很可能经过30秒钟后R1才把更新信息发送给R2。R2可能已经先把自己的路由表发给R1，其中有”1,2，R1“这一项。</p><p>R1收到R2的更新报文后，把1,2，R1更新为1,3，R2。之后会再把更新后的信息发给R2。R2又更新自己的路由表为1，4，R1。如此往复直到加到16。</p><ol start="3"><li><strong>OSPF</strong> 开放最短路径优先(Open Shortest Path First)</li></ol><p>它是为克服RIP的缺点在1989年开发出来的。</p><p>使用了Dijkstra提出的<strong>最短路径算法SPF</strong>。</p><p>特点：</p><p>1）向本自治系统中所有路由器发送信息。使用<strong>洪泛法</strong>。路由器通过所有输出端口向所有相邻路由器发送信息。而每一个相邻路由器又再将此信息发往所有相邻路由器。</p><p>2）发送的信息就是<strong>本路由器相邻的所有路由器的链路状态</strong>。<strong>度量</strong>表示费用、距离、时延、带宽等等，这些都是网络管理人员决定的，较为灵活。</p><p>3）只有链路发生变化时才会向所有路由器用洪泛法发送此信息。</p><p>OSPF将一个自治系统再划分为若干个更小的范围，叫做区域。图4-34就表示一个自治系统划分为4个区域。</p><p><img src="/2021/03/15/network/OSPF%E5%8C%BA%E5%9F%9F.png"></p><p>这样洪泛法就作用于每个区域内。上层叫<strong>主干区域</strong>，R3、R4和R7是<strong>区域边界路由器</strong>。R6是<strong>自治系统边界路由器</strong>。（和其他自治系统连接）</p><p><img src="/2021/03/15/network/OSPF%E6%A0%BC%E5%BC%8F.png"></p><p>使用24字节的首部长度：</p><p>1）版本。当前版本为2。</p><p>2）类型。5种类型中的一种。</p><p>3）分组长度。包括OSPF首部在内的分组长度。</p><p>4）路由器标识符。发送改分组的路由器接口的IP地址。</p><p>5）区域标识符。分组属于区域的标识符。</p><p>6）检验和。用来检验分组中的差错。</p><p>7）鉴别类型。0（不用）1（口令）。</p><p>8）鉴别。 鉴别类型为0填0。鉴别类型1填8个字符的口令。</p><h3 id="11-外部网关协议BGP"><a href="#11-外部网关协议BGP" class="headerlink" title="11.外部网关协议BGP"></a>11.外部网关协议BGP</h3><p>边界网关协议（BGP）</p><p>不同自治区域使用BGP的原因有：</p><ol><li><p>互联网规模太大。路由表维持开销太大。</p></li><li><p>不同自治区域用的协议可能不同。而且有的自治区域不喜欢让别的自治区域流量通过本区域。</p></li></ol><p>BGP采用<strong>路径向量路由选择协议</strong>，满足管理员的条件下，选择比较好的路径，并非找一条最佳路径。</p><p>一个BGP发言人与其他AS的BGP发言人要交换信息，首先建立TCP连接，端口号179，然后在此连接上交换BGP报文以建立BGP会话。</p><p><img src="/2021/03/15/network/BGP%E5%92%8CAS%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>有了BGP会使得路由表简化很多，BGP协议交换路由信息的结点数量级是自治系统个数的量级，这要比网络数小很多，只要找对正确的BGP发言人，就可以发送数据报，简化路由表信息。</p><ul><li>BGP-4的4种报文</li></ul><p>1）OPEN（打开）报文，用来和相邻的另一个BGP发言人建立关系，使通信初始化。</p><p>2）UPDATE（更新）报文，用来通告某一路由信息，以及列出要撤销的多条路由。</p><p>3）KEEPALIVE（保活），用来周期性地证实邻站的连通性。</p><p>4）NOTIFICATION（通知）报文，用来发送检测到的差错。</p><ul><li>BGP路由表包括目的网络前缀，下一跳路由以及到达该网络经过的自治系统序列。（如果一个BGP收到了其他BGP的路径通知，检查本自治系统是否在路径序列中，防止兜圈子）。</li></ul><p><img src="/2021/03/15/network/BGP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><ul><li><p>标记用来鉴别BGP报文，不使用鉴别，标记全部置1。长度字段指出包括通用首部在内的整个BGP报文长度，最小19，最大4096。类型1-4，上述BGP报文中的一种。</p></li><li><p>OPEN报文共有6个字段，即版本</p></li></ul><h3 id="12-IPV6"><a href="#12-IPV6" class="headerlink" title="12.IPV6"></a>12.IPV6</h3><p>IPV6将地址空间增大到128位，相当于IPV4的$2^{96}$倍。</p><p><img src="/2021/03/15/network/IPV6%E6%A0%BC%E5%BC%8F.png"></p><ul><li>首部固定40字节。</li><li><strong>版本</strong> 占4位。协议的版本，IPV6是6.</li><li><strong>通信量类</strong> 占8位，为了区分不同的IPV6数据类型和优先级。</li><li><strong>流标号</strong> 占20位。<strong>流</strong>指的是从特定源点到特定终点的一系列数据报，流所经过的路径上路由器都保证指明的服务质量。属于同一个流的数据报都有一样的流标号。</li><li><strong>有效载荷长度</strong> 占16位。IPV6数据报除基本首部以外的字节数。这个字段的最大值是64KB。</li><li><strong>下一个首部</strong> 占8位。</li></ul><p>1）IPv6没有扩展首部时，指明后面的数据应该交付IP层哪一个协议。</p><p>2）出现扩展首部时，下一个字段的值标识第一个扩展首部的类型。</p><ul><li><strong>跳数限制</strong> 占8位。防止数据报在网络中无限期存在。最大255跳。</li><li><strong>源地址</strong> 128位。发送数据报的IP地址。</li><li><strong>目的地址</strong> 128位。接收数据报的IP地址。</li></ul><ol><li><strong>IPV6地址</strong></li></ol><p>1）<strong>单播</strong> 传统的点对点通信。</p><p>2）<strong>多播</strong> 一点对多点通信。</p><p>3）<strong>任播</strong> 终点是一组计算机，数据报只交付其中一个，通常是距离较近的那个。</p><p>2.<strong>冒号十六进制法</strong></p><p><img src="/2021/03/15/network/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%92%E5%8F%B7%E6%B3%95.png"></p><p><img src="/2021/03/15/network/v6%E5%8E%8B%E7%BC%A9.png"></p><p>CIDR无分类网络地址同样可以适用。直接在后面加上/。</p><p><img src="/2021/03/15/network/IPV6%E6%97%A0%E5%88%86%E7%B1%BB.png"></p><ul><li>地址分类</li></ul><p><img src="/2021/03/15/network/IPV6%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png"></p><p>1） 未指明地址。16字节全0地址。只能为某个主机当源地址适用，使用条件是这个主机还未分配IP地址。仅此一个。</p><p>2）环回地址。功能和V4一样。仅此一个。</p><p>3）多播地址。功能和V4一样。1/256个。</p><p>4）本地链路多播地址。有些主机没有连接到互联网上，占1/1024。</p><p>5）全球单播地址。 如图。</p><ol start="3"><li><strong>从IPV4向IPV6过渡</strong></li></ol><p>1）<strong>双协议栈</strong></p><p>一部分主机装有IPV4和IPV6两个协议栈。这样这个主机可以两种类型的网络数据通信。使用<strong>DNS</strong>查询目的主机使用的是那种协议。</p><p><img src="/2021/03/15/network/%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88.png"></p><p>2）<strong>隧道技术</strong></p><p>IPv6数据报进入IPv4网络时，使用IPv4数据报封装IPv6。这样就可以在IPv4网络中传播。在离开v4网络时，只交付数据部分（即v6）。双协议栈的主机想知道封装的是一个v6数据报，v4首部协议字段置为41。</p><ol start="4"><li><strong>ICMPv6</strong></li></ol><p>也需要使用类似ICMP反馈差错信息。</p><p><img src="/2021/03/15/network/ICMPv6%E5%88%86%E7%B1%BB.png"></p><h3 id="13-IP多播"><a href="#13-IP多播" class="headerlink" title="13.IP多播"></a>13.IP多播</h3><ul><li>一对多通信。一个源点发送给很多终点。</li></ul><p><img src="/2021/03/15/network/%E5%8D%95%E6%92%AD%E4%B8%8E%E5%A4%9A%E6%92%AD%E6%AF%94%E8%BE%83.png"></p><ul><li>多播实际上是IP地址中D类地址。只能用于目的地址，不能用于源地址。没有ICMP差错报文。</li><li>协议。IGMP网际组管理协议。</li></ul><p><img src="/2021/03/15/network/IGMP.png"></p><p>IGMP让连接在本地局域网上的多播路由器知道本局域网上是否有主机参与或退出了某个多播组。</p><p>配合<strong>多播路由选择协议</strong>一起工作，</p><p><img src="/2021/03/15/network/%E5%A4%9A%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png"></p><ul><li>IGMP两个工作阶段</li></ul><p>1）加入。某台主机加入多播组时，该主机应向多播组的多播地址发送一个IGMP报文，声明自己要成为该组的成员。本地多播路由器收到IGMP报文后，还要利用多播路由选择协议把这种组成员关系发给其他多播路由器。</p><p>2）删除。本地多播路由器周期性探询主机，查询这些主机是否还是组的成员。只要有一台主机对某个组响应，那么多播路由器就认为这个组是活跃的。只要几次探询后没有一个主机响应，那么就不会再把这个组的成员关系转发给其他转播路由器。</p><ul><li>多播路由选则协议</li></ul><p>多播路由选择协议尚未标准化。（此部分学习了解一下即可）</p><p>多播路由选择实际上要找出以源主机为根节点的多播转发树。转发数据报使用如下方法：</p><p>1）<strong>洪泛与剪除</strong></p><p>这种方法适用于较小的多播组，所有组成员接入的局域网也都是相邻接的。使用的是<strong>反向路径广播</strong>（RPB）。</p><p>洪泛就是广播，剪除就是。</p><p>洪泛与剪除示例：</p><p><img src="/2021/03/15/network/%E6%B4%AA%E6%B3%9B%E4%B8%8E%E5%89%AA%E9%99%A4.png"></p><p>如果多播转发树上的某个路由器发现它的下游树枝没有多播组成员，则下游树枝一起<strong>剪除</strong>。图中虚线椭圆就是剪除。当有新成员增加，再加回多播转发树。</p><p>2）<strong>隧道技术</strong></p><p>适用于多播组位置在地理上分布很分散。</p><p>路由器R1和R2不支持多播，那么R1和R2需要对多播数据报封装，再加上普通数据报首部，使之成为向单一目的站发送的单播数据报，然后“隧道”一样从R1发到R2。</p><p><img src="/2021/03/15/network/IP%E5%A4%9A%E6%92%AD%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF.png"></p><p>3）<strong>基于核心的发现技术</strong></p><p>对每一个多播组G指定一个核心路由器，给出它的IP单播地址。核心路由器按照前面的方法创建出多播组G的转发树。如果有一个路由器R1向核心路由器发送数据报，那么它途中经过的每一个路由器都要检查其内容。</p><p>书上没讲明白（P184）。了解一下算了。</p><h3 id="14-虚拟专用网和网络地址转换NAT"><a href="#14-虚拟专用网和网络地址转换NAT" class="headerlink" title="14 虚拟专用网和网络地址转换NAT"></a>14 虚拟专用网和网络地址转换NAT</h3><ol><li><strong>虚拟专用网</strong></li></ol><p>IPv4中有内部网络专用地址（为了防止和公网地址重叠，产生二义性问题）：</p><p>1）<code>10.0.0.0</code> 到 <code>10.255.255.255</code>(10.0.0.0/8，24位块)对应A类地址</p><p>2）<code>172.16.0.0</code>到<code>172.31.255.255</code>(172.16.0.0/12它又称为20位块) 对应B类</p><p>3）<code>192.168.0.0</code>到<code>196.168.255.255</code>（192.168.0.0/16，16位块）对应C类</p><p>这样的IP地址叫<strong>专用互联网</strong>或<strong>本地互联网</strong>。</p><ul><li>利用公用的作为本机构专用网之间的通信载体，这种专用网叫<strong>虚拟专用网VPN(Virtual Private Network)<strong>，用于机构的内部通信。所有经过互联网传输的</strong>数据要加密</strong>。</li><li>IP隧道技术</li></ul><p>隧道技术就是封装（把原来数据放到新的数据报，以方便通信）。</p><p><img src="/2021/03/15/network/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%A4%BA%E4%BE%8B.png"></p><p>从X到Y，源地址X、目的地址Y+真实数据报。A发到了R1，R1会对所有数据加密封装，发给R2.R2在解密，就知道发给Y。</p><p>逻辑上看起来就是一个从R1到R2的直接路径（实际上经过了很多路由器传输），所以叫隧道。</p><ol start="2"><li><strong>网络地址转换NAT</strong></li></ol><p>分到了本地专用地址（内部网络专用地址），但是需要和外网通信咋办？<strong>公网IPv4地址太少啦。</strong></p><p>NAT就出来解决这个问题，一个NAT软件至少有一个有效的公网IP地址，使用NAT地址转换表来对应公网IP地址。</p><p><img src="/2021/03/15/network/NAT%E8%B7%AF%E7%94%B1%E8%A1%A8.png"></p><p><img src="/2021/03/15/network/NAT%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>比如主机A向主机B发送信息，NAT路由器会将其地址<code>192.168.0.3</code>映射成<code>172.38.1.5</code>。B看到的A的地址实际上就是NAT的这个地址。B不知道A的实际地址是什么。B发给A信息目的地址就写NAT的IP就行。收到B的信息，NAT路由器根据NAT转换表转成A的<code>192.168.0.3</code>。</p><p>有一个问题来了，我们家庭的路由器，实际就一个IP地址，为什么那么多设备都能访问外网？</p><p>虽然只有一个公网IP地址，但是发明了<strong>端口号</strong>（运输层）啊！！！</p><p><img src="/2021/03/15/network/NAT%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p><p>这个新的表叫<strong>网络地址与端口号转换NAPT</strong>。实际上现在很多人还是叫NAT转换表。</p><h3 id="15-多协议标记交换-MPLS-MultiProtocol-Label-Switching"><a href="#15-多协议标记交换-MPLS-MultiProtocol-Label-Switching" class="headerlink" title="15. 多协议标记交换 MPLS(MultiProtocol Label Switching)"></a>15. 多协议标记交换 MPLS(MultiProtocol Label Switching)</h3><p>增强IP功能的协议。采用面向连接的技术，每个分组携带一个叫做标记的小整数。当分组到达交换机时，交换机读取分组的标记，并采用标记值来检索分组标记，</p><ul><li>基本工作过程</li></ul><p>在传统的IP路由器查找路由表时，需要找最长匹配的前缀，耗时很大。MPLS对这个进行了优化。</p><p>在MPLS入口处，给每一个IP数据报打上固定长度的标记，然后对打上标记的IP数据报用硬件转发，速度大大加快。</p><p>使用硬件技术对打上标记的IP数据报进行转发成为标记交换，根据标记在数据链路层（硬件）上直接转发。</p><p><img src="/2021/03/15/network/MPLS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png"></p><p>MPLS的基本工作流程书中没细讲，主要有：（了解一下）</p><p>1）MPLS域指各LSR（标记交换路由器）使用专门的<strong>标记分配协议LDP</strong>交换报文，并找出特定标记相对应的路径，即<strong>标记交换路径LSP</strong>，如图中的ABCD。各LSR根据路径构造<strong>转发表</strong>。</p><p>2）IP数据报进入MPLS就给它打标记，按照转发表发给下一个LSR。</p><p><img src="/2021/03/15/network/LDP%E5%8D%8F%E8%AE%AE.png"></p><p>3）一个标记仅仅在两个标记交换路由器LSR之间才有意义。每经过一个LSR，LSR就要更换新的标记并转发，即把入标记换位出标记，这叫标记交换。</p><p>如图中B从入口0收到标记为3的分组，要将出接口换为1并且标记重新打1。</p><p>4）数据离开MPLS时，MPLS的出口结点就把MPLS标记删除，交付非MPLS路由器，按照普通的转发规则继续传递。</p><ul><li>MPLS中的重要概念 <strong>FEC转发等价类</strong></li></ul><p>转发等价类就是路由器按照同样方式对待的IP数据报的集合，即同样的接口转发到同样的下一跳地址，具有同样的服务类别和同样的丢弃优先级等。</p><p><img src="/2021/03/15/network/FEC%E7%9A%84%E4%BE%8B%E5%AD%90.png"></p><p>划分FEC的方法不受限制，只接受管理员控制。图中是FEC用于负载平衡的例子。传统的路由选择H1和H2分别向H3和H4发送信息，都只能选择最短路径ABC，导致过载。FEC可以指定H2选择ADEC。</p><ul><li>MPLS的首部位置和协议格式</li></ul><p><img src="/2021/03/15/network/MPLS%E9%A6%96%E9%83%A8%E4%BD%8D%E7%BD%AE.png"></p><p>IP数据报首部之间插入4字节的MPLS首部。把加上MPLS的IP数据报封装成帧时，以太网字段单播时为$8847_{16}$和$8848_{16}$这样来判断是否使用MPLS。</p><p><img src="/2021/03/15/network/MPLS%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>1）标记值。 最大$2^{20}$。在设置MPLS标记时可以使用所有的20位。</p><p>2）试验。 3位，目前保留用于试验。</p><p>3）栈S 。1位，“标记栈”时使用。</p><p>4）生存时间TTL。 8位，防止MPLS在MPLS兜圈子。</p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="1-运输层协议概述"><a href="#1-运输层协议概述" class="headerlink" title="1. 运输层协议概述"></a>1. 运输层协议概述</h3><p>端到端的通信实际上是两个主机中的应用进程之间的通信。</p><p>运输层“复用”和“分用”。复用指的是发送方不同的应用进程都可以使用同一个运输层协议传送数据，而“分用”是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。</p><p><img src="/2021/03/15/network/%E8%BF%90%E8%BE%93%E5%B1%82.png"></p><p>运输层的两个主要协议：UDP(User Datagram Protocol)和TCP(Transmission Control Protocol)。</p><p><img src="/2021/03/15/network/%E8%BF%90%E8%BE%93%E5%B1%82%E4%B8%A4%E4%B8%AA%E5%8D%8F%E8%AE%AE.png"></p><p>按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫<strong>运输协议数据单元</strong>。</p><p><img src="/2021/03/15/network/%E4%BD%BF%E7%94%A8UDP%E5%92%8CTCP%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE.png"></p><p><strong>协议端口号</strong>通常又称为<strong>端口</strong>，虽然通信的终点是应用进程，但只要把所传送的报文交到目的主机的某个合适的目的端口，剩下的工作交由TCP或UDP来完成。（这里的端口主义和交换机或路由器上的端口区分，那个是硬件端口，这个是软件端口）。</p><p>TCP/IP运输层用一个16位（<strong>共65535个</strong>）的端口号来标志一个端口。端口号只具有本地意义，它只是标记本计算机应用层中的各个进程在运输层交互时的层间接口。</p><p>通信时，<strong>不仅要知道对方的IP地址，还要知道对方的端口号</strong>。</p><ul><li><strong>服务端</strong>使用的端口号。</li></ul><p>1）熟知端口号或系统端口号</p><p>数值 0~1023。</p><p><img src="/2021/03/15/network/%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3%E5%8F%B7.png"></p><p>2）登记端口号。数值 1024~49151。这类端口号为了没有熟知端口号的应用程序使用的。</p><ul><li><strong>客户端</strong>使用的端口号</li></ul><p>数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，因此又叫<strong>短暂端口号</strong>。</p><h3 id="2-UDP-用户数据报协议"><a href="#2-UDP-用户数据报协议" class="headerlink" title="2. UDP 用户数据报协议"></a>2. UDP 用户数据报协议</h3><p>UDP(User Datagram Protocol)只在IP的数据报服务上增加了很少的一点功能。</p><p>1）无连接的。发送数据之前不需要建立连接，减少开销和发送数据之前的时延。</p><p>2）尽最大努力 交付。不需要维护复杂的连接状况。</p><p>3）面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后交付IP层。<strong>UDP一次交付一个完整的报文</strong>。如果报文太长，IP会对其进行分片，降低IP层的效率。</p><p><img src="/2021/03/15/network/UDP%E9%9D%A2%E5%90%91%E6%8A%A5%E6%96%87.png"></p><p>4）没有拥塞控制。网络出现的拥塞不会使源主机发送速率降低。这对实时应用很重要。</p><p>5）UDP支持一对一，一对多，多对一，多对多的交互通信。</p><p>6）UDP的首部开销少，只有8个字节，比TCP的20字节要短。</p><h3 id="3-UDP的首部格式"><a href="#3-UDP的首部格式" class="headerlink" title="3.UDP的首部格式"></a>3.UDP的首部格式</h3><p><img src="/2021/03/15/network/UDP%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>数据字段和首部字段。首部字段中划分的每个字段<strong>都是两个字节</strong>。</p><p>1）源端口 源端口号。在需要对方回信时选用，不需要时全用0。</p><p>2）目的端口 目的端口号。终点交付时必须使用。</p><p>3）长度 UDP用户数据报的长度，最小值8（仅有首部）。</p><p>4） 检验和 检测UDP用户数据报在传输时是否有错。有错就丢弃。</p><p>UDP基于端口的复用：</p><p><img src="/2021/03/15/network/UDP%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E5%A4%8D%E7%94%A8.png"></p><p>比如UDP发现端口号不正确，丢弃该报文，由ICMP发送端口不可达差错报文给发送方。</p><p>UDP计算检验和，UDP要在用户数据报之前加上<strong>12个字节的伪首部</strong>。计算检验和时<strong>临时</strong>加在数据报前，得到临时的UDP数据报。检验和就是按照这个临时的UDP用户数据包来进行计算。<strong>伪首部不向上传递也不想下传递</strong>，只是为了计算检验和。</p><p>UDP的检验和是把首部和数据部分一起检验（和IP只检验首部不同）。</p><p><img src="/2021/03/15/network/%E8%AE%A1%E7%AE%97UDP%E6%A3%80%E9%AA%8C%E5%92%8C.png"></p><p>发送方把检验和字段记为0。伪首部以及UDP数据报看成许多16位子串。若UDP数据部分不是偶数字节，需要填入一个全零字节，按照<strong>二进制反码</strong>计算出16位字的和。将此二进制反码写入检验和字段，发送给目的主机。</p><p>接收方收到UDP，按二进制反码求16位字的和，无差错其结果应全为1。否则就表明差错出现。</p><p>差错检验能力并不强，但简单快速。</p><h3 id="4-传输控制协议TCP"><a href="#4-传输控制协议TCP" class="headerlink" title="4.传输控制协议TCP"></a>4.传输控制协议TCP</h3><p>1） 面向连接。打电话一样，通信之前需要拨号建立连接，结束时需要挂断结束连接。</p><p>2）TCP只能<strong>点对点</strong>。 端点对端点。</p><p>3）TCP提供<strong>可靠交付</strong>的服务。 可以检查传送的数据无差错、不丢失、不重复并且按序到达。</p><p>4）全双工通信。通信双方的应用进程在任何时候都可以发送数据。</p><p>5）面向字节流。 流 指的是流入进程或者从进程流出的字节序列。虽然应用进程和TCP的交互是一次一个数据块，但是TCP把这些数据看成是一连串的无结构的字节流。TCP并不知道所传送的字节流的含义。TCP只保证收到的字节流和发送的字节流一样。</p><p><img src="/2021/03/15/network/TCP%E5%AD%97%E8%8A%82%E6%B5%81.png"></p><ul><li>TCP的连接</li></ul><p>$套接字 socket=(IP地址 : 端口号)$ </p><p>TCP连接 : :=${socket_1,socket_2}={(IP_1 : port_1),(IP_2,port_2)} $</p><ul><li>可靠传输原理</li></ul><p>1） 停止等待协议</p><p><img src="/2021/03/15/network/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png"></p><p>正常情况下，A发送M1，B收到发送确认M1，A收到确认继续发送。</p><p>超时情况下，A发送的M1可能丢失或者错误，B没收到或者收到错误的会没有任何响应。A一段时间没收到确认需要重发。</p><p>所以，需要注意的要点是：</p><p>1）A发送后必须保留发送数据的副本，以备重传。</p><p>2）分组和确认分组都需要编号，确认哪个没收到哪个收到。</p><p>3）合理的超时重传时间十分重要。</p><ul><li>确认丢失和确认迟到</li></ul><p><img src="/2021/03/15/network/%E7%A1%AE%E8%AE%A4%E4%B8%A2%E5%A4%B1%E5%92%8C%E8%BF%9F%E5%88%B0.png"></p><p>图中a的情况：</p><p>1）B的确认丢失，A重发，B又收到M1，需要将M1扔掉。</p><p>2）B需要重发M1确认报文，A发了两次M1说明没收到确认。</p><p>图中b的情况：</p><p>B的确认报文因为第一次的报文迟到了，所以A要丢弃一个确认报文。</p><p><img src="/2021/03/15/network/TCP%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%871.png"></p><p><img src="/2021/03/15/network/TCP%E4%BF%A1%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87.png"></p><p>U表示信道利用率。A发送分组时间是$T_D$，收到确认时间是$T_A$。可以发现这样信道利用率比较低，很长时间才能发送下一个数据，发明了流水线发送：（ARQ协议或滑动窗口协议）</p><p><img src="/2021/03/15/network/TCP%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%91%E9%80%81.png"></p><ul><li>连续ARQ协议。</li></ul><p><img src="/2021/03/15/network/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.png"></p><p>发送窗口，一下子发送5个分组。收到一个确认，窗口就向前滑动一个。</p><p><strong>累积确认方式，按序到达的最后一个分组确认</strong>。例如，12345中的3丢了，会收到2的确认报文，因为只有12是有序的，这里就要重新发345。</p><ul><li><strong>首部报文格式</strong></li></ul><p><img src="/2021/03/15/network/TCP%E7%9A%84%E9%A6%96%E9%83%A8%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><p>首部固定20字节，可选40字节，首部最长60字节。</p><ul><li><p>源端口 目的端口 。如字面意思。</p></li><li><p>序号。 4字节，$[0,2^{32}-1]$，序号增加到$2^{32}-1$后重新从0开始发。每一个字节都按顺序编号，当前发了301-400字节，那么下一个报文的序号是401。</p></li><li><p>确认。 <strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。比如B收到了A发送过来的501-600的数据。则发送601确认。若确认号等于N，则N-1个字节都收到了。</p></li><li><p>数据偏移。 占4位。记录数据的起始字段距离TCP报文起始距离多远。数据偏移的单位是32位字（以4字节作为基本单位），所以最大这个字段占4位最大15，15*4=60字节。所以TCP的首部长度最大60字节。</p></li><li><p>保留。 占6位，保留今后使用。</p></li><li><p>紧急URG。 URG=1时，紧急数据应该不能排队直接优先发送分组。</p></li><li><p>确认ACK。 连接建立后所有传送的报文段都为1。</p></li><li><p>推送PSH。 接收方收到PSH=1时，不能等缓冲区满才交付上层，要直接交付，事情紧急。</p></li><li><p>复位RST。 RST=1表示TCP发生严重错误，要释放连接。RST=1还可拒绝一个非法报文段。</p></li><li><p>同步SYN。 在建立连接时来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1。因此SYN置1就表示这是一个连接请求或连接接受报文。</p></li><li><p>结束FIN。 用来释放一个连接。当FIN=1时，表明报文段发送方的数据已发送完毕，并要求释放运输连接。</p></li><li><p>窗口。 2字节。窗口值是[0,$2^{16}-1$]之间的整数。窗口指的是发送报文段的一方的接收窗口。窗口值告诉对方，从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量，这是因为接收方的数据缓存空间是有限的。窗口值作为接收方让发送方设置其发送窗口的依据。</p></li><li><p>检验和。 占2字节。检验和字段检验的范围包括首部和数据两部分。</p></li><li><p>紧急指针。 占2字节。仅在URG=1时有意义。指出本报文段中紧急数据的字节数。紧急指针指出了紧急数据的末尾在报文段中的位置</p></li><li><p>选项。最长可达40字节。当没有选项时，TCP的首部是20字节。</p></li></ul><h3 id="5-TCP可靠传输的实现"><a href="#5-TCP可靠传输的实现" class="headerlink" title="5. TCP可靠传输的实现"></a>5. TCP可靠传输的实现</h3><ol><li>以字节为单位的滑动窗口</li></ol><p><img src="/2021/03/15/network/%E6%9E%84%E9%80%A0%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png"></p><p>发送方A的发送窗口，发送窗口表示在没有收到B确认的情况下，A可以连续把窗口内的数据都发出去。凡是发过的数据都要暂时备份，以便超时重传。</p><p>TCP标准不同意窗口前沿向后收缩，因为有可能已经发送过，收缩后表示没法送这些数据，会产生错误。</p><p><img src="/2021/03/15/network/%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3.png"></p><p>p3-p1 发送窗口</p><p>P2-P1 已发送但未收到确认。</p><p>P3-P2 允许发送但未发送（可用窗口或有效窗口）</p><p>详细的窗口滑动距离可以参考书 P 222。只要明白确认号是有序序列的下一个，都能说对。</p><p><img src="/2021/03/15/network/TCP%E7%BC%93%E5%AD%98%E5%92%8C%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>发送方：</p><p>发送窗口只是发送缓存的一部分。已确认的数据应该从缓存删除，因此发送窗口和缓存的后沿是重合的。</p><p>接收方：</p><p>缓存存放按序到达、但尚未被应用程序读取的数据。未按序到达的数据。</p><p>要点：</p><p>1）A的发送窗口是根据B的接收窗口设置的，但同一时刻A的发送窗口并不和B的接收窗口一样大（网络传送窗口值需要经历一定的时间滞后）。A可能还要根据网络拥塞情况控制发送窗口的数值。</p><p>2）接收方都是累积确认。但是不应该过分推迟发送确认，否则会导致发送方不必要的重传。</p><ol start="2"><li>超时重传时间选择</li></ol><p>使用<strong>自适应算法</strong>设置重传时间。</p><p>记录报文发出的时间，以及收到相应的确认时间，时间差就是<strong>报文段的往返时间RTT</strong>。TCP保留RTT的加权平均往返时间。</p><p><img src="/2021/03/15/network/TCP%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4.png"></p><p>建议$\alpha$=1/8。确认重传时间RTO：</p><p><img src="/2021/03/15/network/TCP%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4.png"></p><p>$新的RTT_{D}=（1-\beta)\times(旧的RTT_{D})+\beta \times |RTT_{s}-新的RTT样本|$</p><p>$\beta=0.25$</p><p><img src="/2021/03/15/network/TCP%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%A4%BA%E4%BE%8B.png"></p><p>正常的RTO按照上面公式计算即可。对于需要重传的数据，每次重传一次，就直接把RTO=2*RTO。两倍的原来的RTO就行。</p><ol start="3"><li>选择确认SACK</li></ol><p><img src="/2021/03/15/network/SACK%E5%AD%97%E8%8A%82%E6%B5%81%E4%B8%8D%E8%BF%9E%E7%BB%AD.png"></p><p><strong>为了减少不必要的重传</strong>。每一个字节块都有两个边界，例如图中的L1和R1来标记接收方收到的字节。首部可变选项长度最大40字节，选项中先加上“允许SACK”。一个边界使用32位（4字节），所以一个标记需要8字节（L和R），还需要两个字节，一个指明使用SACK，一个指明这个选项占用多少字节。（书上也没讲清楚，看看得了）</p><h3 id="6-TCP流量控制"><a href="#6-TCP流量控制" class="headerlink" title="6.TCP流量控制"></a>6.TCP流量控制</h3><p>流量控制指的是<strong>发送方发送数据不要太快，接收方来得及接收</strong>。</p><p><img src="/2021/03/15/network/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png"></p><p>接收方B进行了流量控制，告诉A应该发多少。当rwnd=0 A只能等待不能发送。直到B发回新的ACK。</p><p>有一种特殊情况，如果最后rwnd=0后，B有了新的缓存空间，给A发了新的确认和窗口，但是这个消息丢了，会导致A和B互相等待死锁。为了解决这种情况，设置持续计时器，持续计时器到时，A就发送<strong>零窗口探测报文段</strong>，对方就在这个探测报文段给出新的窗口值。</p><ol><li>TCP的传输效率</li></ol><p>缓存只管把当前窗口内的数据交付TCP，发送的数据直接由TCP去处理。</p><p><strong>例子1</strong>：TCP何时发送数据关乎网络利用率。如果用户每次只发1个字节，那么加上头部40个字节（iP20+TCP20)共41字节。接收方发送确认信息40字节。这么一个字节就传送81个字节，利用率很低。</p><p>书中提到两个方法：</p><p>1）Nagle方法：应用程序把要发送的数据缓存到发送缓存，TCP先发送第一个数据字节，缓存后面到达的数据，收到确认后，把缓存区所有数据装成一个TCP报文一起发送，同时对后续的数据继续缓存，收到前一个确认再继续发送。Nagle规定，数据达到发送窗口一半或报文段的最大长度（MSS)就立即发送一个报文段。<strong>差不多是控制发送方接收窗口大小</strong>。</p><p>2）糊涂窗口：糊涂窗口就是指例子1的情况，不断地发送1个字节，网络利用率很低。为了解决问题，规定让接收方等一段时间，接收缓存有足够空间或接收缓存有了一半空间。这两种情况下才让发送方发送一个长TCP。<strong>差不多是控制接收方窗口大小，不要有一点空间就着急告诉发送方</strong></p><p>这两种方法可配合使用，达到效果。</p><h3 id="7-TCP的拥塞控制"><a href="#7-TCP的拥塞控制" class="headerlink" title="7.TCP的拥塞控制"></a>7.TCP的拥塞控制</h3><p>拥塞控制就是防止过多的数据注入网络，这样可以使网络中的路由器或链路不至于过载。网络能够承受现有的网络负荷。拥塞控制是一个全局的过程，涉及所有的主机和路由器。</p><p>简单地将处理机速率提高，可能会把瓶颈移到其他地方。比如某个结点缓存太小，我就给它弄成无限缓存，结果缓存排队的数据太多了，很多信息又全部重传，我这还没发出去你就又来一轮，越来越慢。<strong>拥塞控制是个全局的控制，所以说拥塞不能只看某一个地方，需要全局把控</strong>。</p><p>流量控制是点对点通信量的控制。</p><p><img src="/2021/03/15/network/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%89%80%E8%B5%B7%E7%9A%84%E4%BD%9C%E7%94%A8.png"></p><p>从控制理论的角度看拥塞控制，分为<strong>开环控制</strong>和<strong>闭环控制</strong>两种方法。</p><p>开环控制就是设计网络时事先将有关发生的拥塞因素考虑周到，力求网络在工作时不产生拥塞。但一旦整个系统运行起来，就不再中途进行改正了。</p><p>闭环控制基于反馈环路的概念，主要有：</p><p>1）检测网络系统以便检测到拥塞在何时发生、何处发生。</p><p>2）把拥塞发生的信息传送到可采取行动的地方。</p><p>3）调整网络系统的运行以解决出现的问题。</p><ul><li>TCP的拥塞控制</li></ul><p>1）慢开始和拥塞避免</p><p>基于窗口的拥塞控制。发送方维持一个叫做拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地变化。<strong>发送方让自己的发送窗口等于拥塞窗口。</strong></p><p>原则：只要网络没有出现拥塞，拥塞窗口可以再增大一些，以便发送更多分组，提高网路利用率。但只要出现拥塞，就把拥塞窗口减小。</p><p>只要发送的报文出现了丢失（需要重传）就判断为拥塞。</p><p><strong>慢开始</strong>算法：当主机开始发送数据时，由于并不清楚网络状况，由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。</p><p>刚开始cwnd设置为不超过2至4个SMSS（Sender Maximum Segment Size）最大报文段的数值。</p><p>若SMSS&gt;2190字节，则设置初始拥塞窗口cwnd=2*SMSS。且不超过2个报文段。</p><p>若SMSS&gt;1095字节且SMSS&lt;2190字节，则设置初始拥塞窗口cwnd=3*SMSS字节，且不超过3个报文段。</p><p>若SMSS&lt;=1095字节，则cwnd=4*SMSS字节，不超过4个报文段。</p><p>以此限制初始窗口的拥塞字节数。每收到一个对新的报文段确认后，拥塞窗口增加最多一个SMSS数值。</p><p>$拥塞窗口cwnd每次的增加量=min(N,SMSS)$</p><p>N是原先未被确认的，现在刚收到的确认报文段所确认的字节数。</p><p>不难看出，当N&lt;SMSS时，拥塞窗口每次的增加量要小于SMSS。</p><p><img src="/2021/03/15/network/%E5%8F%91%E9%80%81%E6%96%B9wend%E7%9A%84%E6%83%85%E5%86%B5.png"></p><p>使用慢开始算法，收到确认号就根据确认号扩大窗口，可以看到窗口是成倍增加的。例如：第一次发送的收到了（窗口内是1）2。那么窗口就是（2,3）期望收到4，变为4，下次（4,5,6,7），期望收到8，变为8。</p><p><strong>拥塞避免</strong>算法不像慢开始算法成倍，它只加1（1指的是一个MSS最大数据报文段），<strong>更加缓慢地增大</strong>。</p><p>为了防止拥塞cwnd增长过大，设置慢开始门限。慢开始门限ssthresh：</p><p>当cwnd&lt;ssthresh时，使用上述慢开始算法。</p><p>当cwnd&gt;sshthresh时，停止使用慢开始算法而改用拥塞避免算法。</p><p>当=时，即可使用慢开始算法，也可使用拥塞避免算法。</p><p><img src="/2021/03/15/network/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png"></p><p>这幅图中讲了拥塞控制的例子，具体看书中P234。</p><p><img src="/2021/03/15/network/%E5%BF%AB%E9%87%8D%E4%BC%A0.png"></p><p><strong>快速重传算法</strong>可以让发送方<strong>尽快知道报文发生了丢失</strong>。图中M3丢了要不停地发确认M2，只要<strong>一连收到3个重复确认</strong>，发送方就知道应立即重传。</p><p>图中发现了丢失个别报文段，于是采用<strong>快恢复算法</strong>，调整门限值<code>cwnd=ssthresh=cwnd/2</code>，并开始执行拥塞避免算法。</p><p>在拥塞避免阶段，拥塞窗口是<strong>线性增大</strong>，称为**加法增大AI(Additive Increase)<strong>。而一旦出现超时或3个重复的确认，就要把门限值设为当前拥塞窗口的一半，并且大大减少拥塞窗口的数值，称为</strong>“乘法减小”MD（Multiplicative Decrease)**。二者合并一起就是AIMD算法</p><p>可归纳为如下流程图：</p><p><img src="/2021/03/15/network/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>以上讨论全是假设接收方窗口无限大。接收方窗口称为通知窗口，实际运行中发送方的窗口一定不能超过对方给出的接收方窗口值rwnd。</p><p>所以$发送方窗口的上限值=Min[rwnd,cwnd]$</p><ul><li>主动队列管理（AQM,Active Queue Management）</li></ul><p>路由器缓存都有限制，如果数据报文太多，路由器队列缓存尾部会丢弃报文，导致一连串的报文丢失，重传导致判定网络拥塞。很多TCP会同时进入慢开始状态，使得全网的通信量突然下降，网络恢复正常后，这些TCP又同时信息量增大。</p><p>为了避免这种全局同步现象，提出了主动队列管理(AQM)，不要等到路由器队列长度最大值了才丢弃分组，而是当长度达到某个值时主动丢弃分组，提醒发送方放慢发送速率。</p><h3 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h3><ul><li><strong>三次握手</strong>：</li></ul><p><img src="/2021/03/15/network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png"></p><p>最初两台主机都处于关闭状态，A要主动连接，叫主动打开，B是被动打开连接。A和B都有传输控制模块TCB，这个模块用来发起请求。</p><p>A打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择初始序号seq=x。SYN报文段不能携带数据，但要消耗一个序号。这时A主机进入SYN-SENT（同步已发送）状态。</p><p>B收到连接请求报文段后，如同意建立连接，则向A发送确认。把SYN和ACK都置为1，<code>ack = x+1</code>。选择一个初始序号<code>seq = y</code>，并消耗一个序号。服务器B进入SYN-RCVD（同步收到）状态。</p><p>TCP客户进程收到B的确认后，向B发送确认。确认报文段的ACK置1，确认号<code>ack=y+1</code>，而自己的序号<code>seq=x+1</code>。ACK报文段可以携带数据，但如果不携带数据则不消耗序号，下一个数据报文段的序号仍是seq=x+1。这时建立了连接A进入ESTABLISHED（已建立连接）状态。</p><p><strong>问题：为什么A还要最后发一次确认呢？</strong></p><p>主要是为了防止已失效的连接请求报文段突然又传到了B。本来是一个失效的报文段，如果没有确认，B会立马同意连接，这情况如果多了，B主机岂不是卡死。</p><ul><li>TCP连接释放</li></ul><p>数据传输完毕后，通信双方要释放连接。A和B处于ESTABLISHED状态时，A的应用发出连接释放报文段，停止发送数据，关闭TCP连接。</p><p>A把控制位FIN置为1，其序号<code>seq = u</code>，等于前面已经传送过来数据最后一个字节加1。A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。注意FIN报文段即使不携带数据，也要消耗一个序号。</p><p><img src="/2021/03/15/network/TCP%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B.png"></p><p>B收到连接释放报文发出确认，确认号是<code>ack = u+1</code>，而这个报文段自己的序号是v，等于B前面已经发送的数据最后一个字节加1。B进入CLOSE-WAIT（关闭等待）状态。TCP处于<strong>半关闭</strong>状态。</p><p>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</p><p>B如果没有向A发送的数据，发送FIN=1，假定B现在的序号是w（可能B向A发了一些数据，如果没发，那序号是u+1），但B还是继续重复上次发过的确认号则<code>ACK = u+1</code>。B进入LAST-ACK（最后确认状态），等待A的确认。</p><p>A在收到对此发出确认。ACK置为1，<code>ack =</code>W+1`，而自己的序号是 seq = u+1。进入TIME-WAIT(时间等待)状态。经过**时间等待计时器（Maximum Segment Lifetime)**设置的2MSL后，A进入CLOSED状态。</p><p><strong>为什么A需要等待2MSL时间？</strong></p><p>1）为了保证A发送的最后ACK报文段到达B。这个ACK报文段可能丢失，B收不到对重传FIN+ACK报文段的确认，B会在一定时间内重传，A就能够2MSL时间内等到B的信息。A重传，并且重新启动2MSL计时器。直到A和B都进入CLOSED状态。</p><p>2）防止“已失效的连接请求报文段”出现在本连接中。A发送完最后ACK后，再经过2MSL，可使本连接持续的时间内所产生的所有报文段从网络中消失，这样就可以使下一个新的连接不会出现旧的报文请求文段。</p><p>注意，以为2MSL的存在，B结束TCP的时间比A早一些。</p><p>TCP还有<strong>保活计时器（keepalive timeer）</strong>如果某个client和服务器建立连接但突然故障，服务器一直等待，不能总是等啊。若服务器两个小时还没有收到客户数据，服务器就开始发送探测报文段，并且每隔75秒发送一次，若连续发送10个探测报文段client无响应，服务器认为client故障，关闭连接。</p><ul><li>TCP的有限状态机（相当于总体流程图）</li></ul><p><img src="/2021/03/15/network/TCP%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png"></p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1. 域名系统DNS"></a>1. 域名系统DNS</h3><p>DNS(Domain Name System)是用来将机器名字转换为IP地址。互联网的命名系统中使用了很多的“域”，域是名字空间中一个可被管理的划分，还可被划分子域，出现了顶级域、二级域、三级域等等，因此就出现了“域名”这个名词。</p><p>DNS现在设计成了分布式系统，大部分解析在本地进行，少量解析在互联网上通信，DNS效率很高。</p><p>域名到IP地址的解析是由许多<strong>域名服务器程序</strong>共同完成，运行域名服务器程序的机器叫<strong>域名服务器</strong>。</p><p>解析要点：当某一个应用进程把主机名解析成IP地址时，该应用进程就要调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以<strong>UDP</strong>的形式发送本地域名服务器。本地域名服务器查找后，把对应的IP地址放在回答报文中返回。若本地域名服务器不能找到地址，则此域名服务器暂时成为DNS中的另一个客户，并向其他应服务器请求，直到找到回答。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D.png"></p><p>域名标号由英文字母和数字组成，<strong>每一个标号不超过63个字符</strong>，也<strong>不区分大小写字母</strong>，标号中除了连字符-外不能使用其他标点符号。级别最低的域名写在左边，级别高的写在右边。<strong>由多个标号组成的完整域名不可超过255个字符</strong>。</p><p>最高的顶级域名由ICANN管理，域名可使每一个域名在全互联网内都是唯一的。</p><p>2012年顶级域名共分为3大类：</p><p>1）国家顶级域名nTLD。cn表示中国，us表示美国，uk表示英国等。国家顶级域名达到296个。</p><p>2）通用顶级域名gTLD。com（公司企业）aero（航空运输业）asia（亚太地区）。。。等。</p><p>3）基础结构域名。只有一个arpa，用于反向域名解析，也叫<strong>反向域名</strong>。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D%E5%B1%82%E6%AC%A1.png"></p><p>我国把二级域名划分为“<strong>类别域名</strong>和<strong>行政区域名</strong>两大类：</p><p>“类别域名”共7个，分别为：ac（科研机构），com（工、商、金融等企业），edu（中国的教育机构），gov（中国的政府机构），mil（中国的国防机构），net（提供互联网网络服务机构），org（非营利性组织）。</p><p>行政域名共34个，适用于我国的各省、自治区、直辖市例如：bj（北京），js（江苏）</p><ul><li>域名服务器</li></ul><p><img src="/2021/03/15/network/DNS%E5%88%92%E5%88%86%E5%8C%BA.png"></p><p>一个服务器所管辖的范围叫区，每一个区有权限域名服务器。区小于等于域，但不能大于域。</p><p><img src="/2021/03/15/network/%E5%9F%9F%E5%90%8D%E5%8C%BA%E8%A7%A3%E9%87%8A.png"></p><p>1）根域名服务器：知道所有顶级域名服务器域名和IP地址。本地域名服务器只要无法解析某个域名，就要请求根域名服务器。某个客户请求根域名服务，就找最近的根域名服务器地址发查询。根域名服务器会告诉本地域名服务器下一步找哪个顶级域名服务器。</p><p>2）顶级域名服务器：负责管理在该顶级域名服务器注册的所有二级域名。</p><p>3）权限域名服务器：负责一个区的域名服务器，当权限服务器不能给出最后的查询回答时，就会告诉DNS客户下一步找哪个权限域名服务器。</p><p>4）本地域名服务器：本地域名服务器不属于图6-3中的层次结构。每一个互联网服务提供者ISP，或者一个大学都可以拥有一个本地域名服务器，也叫默认域名服务器。本地域名服务器离客户很近。</p><p>主机向本地域名服务器的查询都是<strong>递归查询</strong>。如果本地域名服务器不知道IP地址，就以DNS客户身份向其他根域名服务器发起请求，递归查询结果。</p><p>本地域名服务器向根域名查询是<strong>迭代查询</strong>。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出IP地址，要么告诉本地域名服务器“下一步应该向哪个域名服务器查询（把自己知道的顶级域名服务器地址）”，然后本地域名服务器查询顶级域名服务器，查到就结束，没查到顶级域名服务器告诉它查询哪个权限域名服务器值，直到查到。</p><p><img src="/2021/03/15/network/DNS%E6%9F%A5%E8%AF%A2%E4%B8%BE%E4%BE%8B.png"></p><p> 每个服务器（本地、根、顶级等）都有高速缓存，保存最近查询过的域名地址，减少网络通信量。</p><h3 id="2-FTP文件传送协议"><a href="#2-FTP文件传送协议" class="headerlink" title="2.FTP文件传送协议"></a>2.FTP文件传送协议</h3><p>FTP使用TCP可靠传输服务。</p><p>FTP由两大部分组成：<strong>主进程</strong>，负责接受新的请求。<strong>从属进程</strong>，负责处理单个请求。</p><p>主进程工作步骤：</p><p>1）打开熟知端口（端口号21），使客户进程能够连接上。</p><p>2）等待客户进程发出连接请求。</p><p>3）启动从属进程处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后终止，但从属进程可能在运行期间根据需要创建一些其他子进程。</p><p>4）回到等待状态，继续接受其他客户进程发来的请求。主进程和从属进程的处理是并行进行的。</p><p><img src="/2021/03/15/network/FTP%E8%BF%9E%E6%8E%A5.png"></p><p>进行文件传输时，FTP客户和服务器之间要建立两个并行的TCP连接：“控制连接”和”数据连接“。控制连接在整个会话期间一直保持打开，FTP客户发出传送请求，通过控制连接发送给服务端的控制进程。实际传输文件的是数据连接，服务端控制进程收到FTP客户文件传输请求后就创建数据传送进程和数据连接。</p><p>网络文件系统NFS和FTP不同，NFS允许应用进程远程打开一个远地文件，并且能在该文件的某一个特定的位置上开始读写数据。</p><ul><li>简单文件传送协议TFTP</li></ul><p>TCP/IP协议族中还有一个简单文件传送协议TFTP，<strong>使用UDP数据报</strong>，因此TFTP需要有自己的差错改正措施。TFTP只支持文件传输而不支持交互。</p><p>TFTP可用于UDP环境。TFTP代码所占内存小。</p><p>1）它每次传送512字节数据，但最后一次不足512。</p><p>2）数据报文按序编号，从1开始。</p><p>3）支持ASCII码或二进制传送。</p><p>4）可对文件进行读写。</p><p>5）使用很简单的首部。</p><h3 id="3-WWW万维网"><a href="#3-WWW万维网" class="headerlink" title="3. WWW万维网"></a>3. WWW万维网</h3><ul><li>URL统一资源定位符</li></ul><p>用来表示从互联网上得到的资源位置和访问这些资源的方法。URL给出资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</p><p><img src="/2021/03/15/network/URL%E5%BD%A2%E5%BC%8F.png"></p><p>URL左边第一部分是协议，这里的协议是指什么协议获取该万维网文档。最常用的是http，其次是ftp。</p><p>协议后面加” ://“是规定的格式。右边是第二部分主机，指出这个万维网文档在哪一台主机上。主机指的是该主机在互联网上的域名。再后面是端口和路径，有时可以省略。</p><p>现在的浏览器为了方便用户，可以把前面的http://甚至www省略，浏览器会自动填充。</p><ul><li>使用HTTP的URL</li></ul><p><img src="/2021/03/15/network/HTTP%E7%9A%84URL.png"></p><p>HTTP默认端口号是80。</p><ul><li>超文本传输协议HTTP （<strong>hyper transport text protocol</strong>）</li></ul><p>HTTP定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。</p><p><img src="/2021/03/15/network/%E4%B8%87%E7%BB%B4%E7%BD%91%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p><p>服务器进程监听TCP的端口80，发现请求即建立请求，一旦监听连接建立，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求页面作为响应。最后TCP连接释放。</p><p>HTTP规定HTTP客户和服务器之间的每次交互，都由一个ASCII码串构成的请求和一个类似的通用互联网扩充，即“MIME(MIME-like)”的响应组成。HTTP报文都是用TCP连接传送。</p><p><img src="/2021/03/15/network/HTTP%E8%AF%B7%E6%B1%82%E6%97%B6%E9%97%B4.png"></p><p>HTTP1.0版本是<strong>非持续连接</strong>。每次同一个客户的新请求都建立新的TCP连接。不仅耗时而且导致服务器负担过重。</p><p>HTTP1.1协议较好地解决了这个问题，它使用<strong>持续连接</strong>，万维网服务器在发送响应之后仍然在一段时间内保持这条连接，使同一个客户和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><p>1.1协议持续连接有两种方式：<strong>非流水线方式</strong>和<strong>流水线方式</strong>。</p><p>非流水线：客户收到前一个响应后才能发出下一个请求。因此客户没访问以此对象都要用去一个RTT往返时间。</p><p>流水线方式：客户收到HTTP的响应报文之前就能够接着发送新的请求报文。于是一个个请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式，客户访问<strong>所有对象</strong>只需花费一个RTT时间。使得TCP连接中的空闲时间减少，提高了下载文档效率。</p><ul><li>HTTP的报文结构</li></ul><p>HTTP有两类报文：</p><p>1）请求报文——从客户向服务器发送请求报文。</p><p>2）响应报文——从服务器到客户的回答。</p><p><img src="/2021/03/15/network/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png"></p><p>1）开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行，而在响应报文中的开始行叫做状态行。开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表回车和换行。</p><p>2）首部行。说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但可以不使用。每一行中都有首部字段名和它的值，每一行在结束的地方都要有回车和换行。整个首部行结束时，还有一空行将首部和后面的实体主体分开。</p><p>3）实体主体，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</p><p><img src="/2021/03/15/network/HTTP%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95.PNG"></p><p><img src="/2021/03/15/network/HTTP%E6%96%B9%E6%B3%95.png"></p><p><img src="/2021/03/15/network/HTTP%E6%8A%A5%E6%96%87%E8%AF%B7%E6%B1%82%E4%BE%8B%E5%AD%90.png"></p><p>相应报文经常见到的状态行：</p><p>HTTP/1.1 202 Accepted {接受}</p><p>HTTP/1.1 400 Bad Request {错误的请求}</p><p>HTTP/1.1 404 Not Found {找不到}</p><ul><li>服务器上存放用户信息</li></ul><p>万维网网站点可以使用Cookie来跟踪用户。当用户A浏览某个Cookie网站时，该网站的服务器就为A产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着给A的HTTP响应报文中添加一个叫做Set-cookie的首部行。这里的首部字段名就是Set-cookie，而后面的“值”就是赋予该用户的“识别码”。</p><p>当A收到这个响应时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括这个服务器的主机名和Set-cookie后面给出的识别码。</p><ul><li>超文本标记语言HTML</li></ul><p>对HTML学习过，这里可以不用看。</p><ul><li>动态文档</li></ul><p>动态文档是指文档的内容在浏览器访问万维网服务器时才由应用程序动态创建。当浏览器请求到达时，万维网服务器要运行另一个应用程序，并把控制转移到此应用程序。应用程序对HTTP报文处理输出HTTP格式的文档，万维网服务器把应用程序的输出作为对浏览器的响应。</p><ul><li>活动万维网文档</li></ul><p>动态文档一旦建立，内容就固定下来无法刷新。所以为了解决这个问题，设计了活动万维网文档。</p><p>两种技术可用于浏览器屏幕显示的连续更新。<strong>服务器推送</strong>，这种技术是将所有工作都交给服务器。服务器不断地运行与动态文档相关联的应用程序，定期更新信息，并发送更新过的文档。</p><p><strong>活动文档</strong>，这种技术把所有工作交给浏览器，每当请求一个活动文档，服务器就返回一段活动文档的副本，使该程序副本在浏览器端运行。这时活动文档可与用户直接交互。</p><ul><li>万维网的信息检索系统</li></ul><p>搜索引擎分为两类：<strong>全文检索搜索引擎</strong>和<strong>分类目录搜索引擎</strong>。</p><p>全文搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件（爬虫）到互联网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站，按照一定规则建立一个很大的在线索引数据库供用户查询。用户输入关键字从已经建立的索引数据库里进行查询。（google）</p><p>分类目录搜索利用各网站向搜索引擎提交网站信息时填写的关键词和网站描述等信息，经过人工审核后，输入分类目录数据库中，供网上用户查询。因此分类目录搜索叫分类网站搜索。</p><p><img src="/2021/03/15/network/%E4%B8%A4%E7%A7%8D%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB.png"></p><h3 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4.电子邮件"></a>4.电子邮件</h3><p>简单邮件传送协议SMTP(Simple Mail Transfer Protocol)和互联网文本报文格式。</p><p>邮件系统构件：用户代理、邮件服务器以及邮件发送协议(SMTP)和邮件读取协议（POP3)</p><p><img src="/2021/03/15/network/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9E%84%E4%BB%B6.png"></p><p>POP3是邮局协议（版本3）。</p><p>SMTP和POP3都是使用TCP来作为传输协议的。</p><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>规定了两个相互通信的SMTP进程之间如何交换信息。邮件内部格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP也都<strong>未</strong>做出规定。</p><p>SMTP规定了14条命令和21种应答信息。每条命令用几个字母组成，而每一种应答信息一般都只有一行信息，由一个3位数字的代码开始，后面附上（也可以不附上）很简单的文字说明。</p><p>1）连接建立。</p><p>发件人的邮件发送到发送方的邮件服务器邮件缓存后，SMTP客户每隔一段时间对邮件缓存扫描一次。如发现有邮件，使用SMTP熟知端口25与接收方邮件服务器的SMTP服务器建立TCP连接。建立连接后，接收方SMTP服务器发出“220 Service ready”（服务就绪）应答。然后客户向SMTP服务器发送HELO命令，附上发送方的主机名。SMTP服务器若有能力接收邮件，则回答：“250 OK”，表示已准备好接收。若SMTP服务器不可用，则回答“421 Service not available”（服务不可用）。</p><p>若一定时间内（比如三天）发送不了邮件，邮件服务器就会把情况通知发件人。</p><p>SMTP不使用中间的邮件服务器，TCP连接总是点对点。</p><p>2）邮件发送</p><p><code>MAIN</code>命令开始，如：“<code>MAIL FROM</code>：<a href="mailto:xiexiren@tsinghua.org.cn">xiexiren@tsinghua.org.cn</a>”。若SMTP服务器已准备好接收邮件，则回答“250 OK”。否则返回代码指出原因：</p><p><img src="/2021/03/15/network/SMTP%E8%BF%94%E5%9B%9E%E4%BB%A3%E7%A0%81.png"></p><p>后面跟着一个或多个RCPT命令（发送一个还是多个收件人），RCPT格式：<code>RCPT TO:&lt;收件人地址&gt;</code>。RCPT是recipient（收件人）的缩写。每发送一个RCPT命令，都应当有相应的信息从SMTP服务器返回，如：“250 OK”，表明指明的邮箱在接收方的系统中，或“550 No such user here”,即不存在此邮箱。</p><p>RCPT命令的作用就是：先弄清楚接收方系统是否已做好接收邮件的准备，然后才发送邮件。</p><p>3）连接释放</p><p>邮件发送完毕后，SMTP客户应发送QUIT命令。SMTP服务器返回的信息是“221（服务关闭）”，表示SMTP同意释放TCP连接。邮件传送的全部过程结束。</p><h4 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h4><p>一封电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分。</p><p><code>To</code>：后面填入一个或多个收件人的电子邮件地址。在电子邮件软件中，用户把经常通信的对象姓名和电子邮件地址写到<strong>地址簿</strong>。</p><p><code>Subject</code>：是邮件的<strong>主题</strong>。</p><h4 id="邮件读取协议POP3和IMAP"><a href="#邮件读取协议POP3和IMAP" class="headerlink" title="邮件读取协议POP3和IMAP"></a>邮件读取协议POP3和IMAP</h4><p>邮局协议POP3和IMAP网际报文存取协议(Internet Message Access Protocol)。</p><p>POP3协议的一个特点就是只要用户从POP3服务器读取了邮件，POP3服务器就该把邮件删除。</p><p>IMAP比POP3复杂很多，IMAP和POP都按照客户服务器方式工作，但它们有很大区别。用户可以在不同的地方使用不同的计算机，随时处理自己的邮件服务。使用IMAP时，在用户的计算机上运行IMAP客户程序，然后与接收方的邮件服务器上的IMAP建立TCP连接。用户在自己的计算机上就可以操纵邮件服务器的邮箱，就像本地操纵一样，IMAP是一个联机协议。</p><p><img src="/2021/03/15/network/IMAP%E5%92%8CPOP3.png"></p><ul><li>通用互联网邮件扩充MIME</li></ul><p><img src="/2021/03/15/network/MIME%E5%92%8CSMTP%E7%9A%84%E5%85%B3%E7%B3%BB.png"></p><p>MIME主要包括以下三部分：</p><p>1）5个新的邮件首部字段，它们可以包含在原来的邮件首部中。这些字段提供了有关邮件主体的信息。</p><p>2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p><p>3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p><p><img src="/2021/03/15/network/MIME%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png"></p><p>其中，4）内容传送编码。MEME对ACSII码构成的邮件不进行任何转换。另一种编码方式是quoted-printable，这种编码方式等号“=”和不可打印的ACSII码，除特殊字符等号“=”外，都不可改变。（<font color="red">这个地方在介绍其他编码方式，可以不用看</font>）</p><p>5)内容类型</p><p>内容类型必须有两个标识符，即“内容类型”和“子类型”，中间用“/“分开。</p><p><img src="/2021/03/15/network/MIME%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B.png"></p><p><img src="/2021/03/15/network/MIME%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B1.png"></p><h3 id="5-动态主机控制协议DHCP"><a href="#5-动态主机控制协议DHCP" class="headerlink" title="5.动态主机控制协议DHCP"></a>5.动态主机控制协议DHCP</h3><p>协议软件参数化，让很多不同的计算机有可能使用同一个经过编译后的二进制代码。一台计算机需求不同，可以通过参数对代码行为进行控制。</p><p>协议软件中给这些参数赋值的动作叫做<strong>协议配置</strong>。一个协议软件在使用之前必须是正确配置的。协议软件配置的项目如下：</p><ul><li>IP地址</li><li>子网掩码</li><li>默认路由器的IP地址</li><li>域名服务器的IP地址</li></ul><p>因为IP地址中还包括网络号，如果一个主机生产出来后就固定一个IP是不行的。</p><p>现在广泛使用的是**动态主机配置协议DHCP(Dynamic Host Configuration Protocol)**，它提供了即插即用联网机制。</p><p>DHCP使用客户服务器方式。需要IP地址的主机在启动时就向DHCP服务器广播发送<strong>发现报文</strong>(将目的IP地址置为全1，即255.255.255.255)，，本机地址设置为0.0.0.0（本机还不知道，只能这么设置）。这个报文只有DHCP服务器能够进行回答。DHCP服务器现在其数据库中查找该计算机的配置信息，若找到，则返回信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器回答报文叫<strong>提供报文</strong>，表示“提供”了IP地址等配置信息。</p><p>为了防止DHCP服务器太多，每个网络至少有一个DHCP中继代理，通常是一台路由器，它配置了DHCP服务器的IP地址信息。当DHCP中继代理收到主机A以广播形式发送的报文后，就以单播的形式向DHCP服务器发送此报文，等待回答。</p><p><img src="/2021/03/15/network/DHCP%E4%B8%AD%E7%BA%A7%E4%BB%A3%E7%90%86.png"></p><p>DHCP服务器分配给DHCP客户的IP的地址是临时的，因此DHCP客户只能在一段有限时间内使用这个IP地址，这个时间叫<strong>租用期</strong>。DHCP协议规定租用期用4字节表示，单位是秒。因此租用期范围是1秒到136年。DHCP客户也可在自己发送的报文中提出对租用期的要求。</p><p>DHCP客户使用<strong>UDP</strong>端口68，服务器使用67。</p><p><img src="/2021/03/15/network/DHCP%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png"></p><p>工作协议的解释详情看P297。</p><h3 id="6-简单网络管理协议SNMP"><a href="#6-简单网络管理协议SNMP" class="headerlink" title="6. 简单网络管理协议SNMP"></a>6. 简单网络管理协议SNMP</h3><p>管理站又称为管理器，是整个网络系统的核心。它通常是个有良好图形界面的高性能工作站，并由网络管理员直接操作和控制。</p><p>SNMP中的管理程序和代理程序按客户服务器方式工作。在被管理对象上运行的SNMP服务器程序不停地监听来自客户程序的请求，一旦发现就返回所需要的信息，或者执行某个动作。</p><p>网络管理有一个基本<strong>原理</strong>：若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”对原有对象的影响必须尽量小些。</p><p>SNMP网络管理由三个部分组成，即SNMP本身、管理信息结构SMI和管理信息库MIB。</p><ul><li>管理信息结构SMI</li></ul><p>SMI是SNMP的重要组成部分。SMI的功能有：</p><p>1）被管对象如何命名。</p><p>2）用来存储被管对象的数据类型有哪些。</p><p>3）在网络上传送的管理数据应如何编码。</p><ol><li>被管对象的命名。</li></ol><p>SMI规定，所有的被管对象都必须处在对象命名树上。</p><p><img src="/2021/03/15/network/SMI%E5%AF%B9%E8%B1%A1%E5%91%BD%E5%90%8D%E6%A0%91.png"></p><p>对象命名树的根没有名字，它下面有三个顶级对象，都是世界上著名的标准指定单位，即ITU-T，ISO以及这两个组织的联合体。internet节点下面的标号为2的节点是mgmt（管理）。再下面是mib-2，包含了所有被SNMP管理的对象。</p><ol start="2"><li>被管对象的数据类型</li></ol><p>SMI使用基本的抽象语法记法1（即ISO制定的ASN.1)来定义数据类型。这里的ISO ASN.1不用管，它只是描述数据的结构形式。</p><p>SMI把数据类型分为两大类：<strong>简单类型</strong>和<strong>结构化类型</strong>。简单类型是最基本的、直接使用ASN.1定义的类型。</p><p><img src="/2021/03/15/network/SMI%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png"></p><ol start="3"><li>编码方法</li></ol><p>使用**基本编码规则BER(Basic Encoding Rule)**进行数据的编码。BER指明了每种数据的类型和值。ASN.1把所有数据元素都表示为T-L-V三个字段组成的序列。T字段定义数据的类型，L字段定义V字段的长度，而V字段定义数据的值。</p><p><img src="/2021/03/15/network/TLV%E6%96%B9%E6%B3%95.png"></p><p>T字段叫做<strong>标记字段</strong>。占1字节。T字段比较复杂，因为他要定义数据类型较多。T字段又分为以下三个子字段：</p><p>1）类别（2位）共四种：通用类（00），即ASN.1定义的类型。应用类（01）即SMI定义的类型。上下文类（10），即上下文所定义的类型；专用类（11），保留为特定厂商定义的类型。</p><p>2）格式（1位）共两种，指出数据类型的种类：简单数据类型（0）、结构化数据类型（1）。</p><p>3）编号（5位），共两种，标志不同的数据类型。编号的范围是0-30。当编号大于30时，T字段就要扩展多个字节。</p><p>L字段又叫做长度字段。L字段为单字节时，其最高位为0，后面的7位定义V字段的长度。当L字段为多个字节时，其最高位为1，而后面的7位定义后续字节的字节数。</p><p><img src="/2021/03/15/network/L%E5%AD%97%E6%AE%B5%E7%9A%84%E6%A0%BC%E5%BC%8F.png"></p><p>V字段又叫值字段，用于定义数据元素的值。</p><ul><li>管理信息库MIB</li></ul><p>管理信息指互联网的网管框架中被管对象的集合。被管对象构成了一个虚拟的信息存储器，所以才称为管理信息库MIB。管理程序就使用MIB中的这些信息对网络进行管理。只有在MIB中的对象才是SNMP所能够管理的。</p><p>MIB的意义：节点<code>ip</code>下面有个名为<code>ipInReceives</code>的MIB变量，表示收到的IP数据报数量。在图6-22中，这个变量的标号是3，变量的名字是:<code>iso.org.dod.internet.mgmt.mib.ip.ipInReceives</code>，而相应的数值表示是1.3.6.1.2.1.4.3。</p><ul><li>SNMP的协议数据单元和报文</li></ul><p>1）<strong>“读”</strong>操作，用Get报文来检测各被管对象的状况。</p><p>2）<strong>”写“</strong>操作，用Set报文来改变各被管对象的状况。</p><p>SNMP的这些功能通过探询操作来实现，即SNMP管理进程定时向被管理设备周期性地发送探询信息。上述时间间隔可通过SNMP的管理信息库MIB来建立。探询的好处是：第一，可使系统相对简单。第二，能限制通过网络所产生的管理信息的通信量。</p><p>SNMP同时不是完全的探寻协议，它不允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。但这种陷阱信息的参数是受限制的。</p><p><strong>使用无连接的UDP</strong>。服务器端使用161来接收Get或Set报文和发送响应报文，但运行管理程序的客户端则使用熟知端口162来接收来自各代理的trap报文。</p><p><img src="/2021/03/15/network/SNMP%E7%9A%84%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png"></p><p>SNMP报文没有固定的字段，共分为以下四个部分：</p><p>1）版本</p><p>2）首部</p><p>3）安全参数</p><p>4）数据部分</p><h3 id="7-应用进程跨越网络的通信"><a href="#7-应用进程跨越网络的通信" class="headerlink" title="7. 应用进程跨越网络的通信"></a>7. 应用进程跨越网络的通信</h3><p>实际上应用程序调用系统接口。此接口把控制权交给操作系统，操作系统执行完成后，在返回给应用进程。系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。</p><p>书中后面在讲开发的Socket套接字接口例子(套接字现在已经成为操作系统内核的一部分），熟悉编程了这东西比书上懂得多多了。</p><p><img src="/2021/03/15/network/%E5%A5%97%E6%8E%A5%E5%AD%97.png"></p><p>常用的系统调用（TCP服务）</p><p>1） 连接建立阶段。</p><p>套接字创建后，它的端口号和IP地址都是空的，因此应用进程要调用bind（绑定）来指明套接字的本地地址（本地端口号和本地IP地址）。</p><p>服务器调用bind后，还必须调用listen（监听）把套接字设置为被动方式，以便随时接受客户的服务请求。UDP服务器由于只是提供无连接服务，不使用listen系统调用。</p><p>然后调用accept（接受），能够处理多个连接（并发）。</p><p>客户请求连接后，服务器把套接字的标识符返回给发起连接的客户方。</p><p>2）数据传送阶段</p><p>send系统调用传送数据，使用recv系统调用接收数据。</p><p>通常send调用把数据复制到操作系统内核的缓存种，若系统的缓存已经满了，send就暂时阻塞，直到缓存有空间存放新的数据。</p><p>3）连接释放</p><p>close调用释放连接和撤销套接字。</p><p><img src="/2021/03/15/network/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F.png"></p>]]></content>
      
      
      <categories>
          
          <category> network </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
